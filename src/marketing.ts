/**
 * Hapz Marketing API
 * This is the Marketing API for Hapz.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest from 'request'
import http from 'http'
import Promise from 'bluebird';

let defaultBasePath = process.env.MARKETING_MANAGEMENT_SERVICE_API!;

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class BaseDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return BaseDto.attributeTypeMap;
    }
}

export class CampaignCategoryDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignCategoryDto.attributeTypeMap;
    }
}

export class CampaignDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignDto.attributeTypeMap;
    }
}

export class CampaignPricingCategoryDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignPricingCategoryDto.attributeTypeMap;
    }
}

export class CardIssuerDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'issuerIdentificationNumbers'?: Array<IssuerIdentificationNumberDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "issuerIdentificationNumbers",
            "baseName": "issuerIdentificationNumbers",
            "type": "Array<IssuerIdentificationNumberDto>"
        }    ];

    static getAttributeTypeMap() {
        return CardIssuerDto.attributeTypeMap;
    }
}

export class Column {
    'data'?: string;
    'name'?: string;
    'searchable': boolean;
    'orderable': boolean;
    'search': Search;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "searchable",
            "baseName": "searchable",
            "type": "boolean"
        },
        {
            "name": "orderable",
            "baseName": "orderable",
            "type": "boolean"
        },
        {
            "name": "search",
            "baseName": "search",
            "type": "Search"
        }    ];

    static getAttributeTypeMap() {
        return Column.attributeTypeMap;
    }
}

export class DataTablesInput {
    'draw': number;
    'start': number;
    'length': number;
    'search': Search;
    'order'?: Array<Order>;
    'columns'?: Array<Column>;
    'columnsAsMap'?: { [key: string]: Column; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "length",
            "baseName": "length",
            "type": "number"
        },
        {
            "name": "search",
            "baseName": "search",
            "type": "Search"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Array<Order>"
        },
        {
            "name": "columns",
            "baseName": "columns",
            "type": "Array<Column>"
        },
        {
            "name": "columnsAsMap",
            "baseName": "columnsAsMap",
            "type": "{ [key: string]: Column; }"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesInput.attributeTypeMap;
    }
}

export class DataTablesOutput {
    'draw'?: number;
    'recordsTotal'?: number;
    'recordsFiltered'?: number;
    'data'?: Array<any>;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "recordsTotal",
            "baseName": "recordsTotal",
            "type": "number"
        },
        {
            "name": "recordsFiltered",
            "baseName": "recordsFiltered",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<any>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesOutput.attributeTypeMap;
    }
}

export class EmailAddressDomainDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'emailAddressDomain'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "emailAddressDomain",
            "baseName": "emailAddressDomain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailAddressDomainDto.attributeTypeMap;
    }
}

export class IssuerIdentificationNumberDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'issuerIdentificationNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "issuerIdentificationNumber",
            "baseName": "issuerIdentificationNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssuerIdentificationNumberDto.attributeTypeMap;
    }
}

export class ItemsPageResponse {
    'start'?: number;
    'rows'?: number;
    'total'?: number;
    'items'?: Array<BaseDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<BaseDto>"
        }    ];

    static getAttributeTypeMap() {
        return ItemsPageResponse.attributeTypeMap;
    }
}

export class MarketingCampaignAffiliatePromoCodeDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'promoCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "promoCode",
            "baseName": "promoCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MarketingCampaignAffiliatePromoCodeDto.attributeTypeMap;
    }
}

export class MarketingCampaignClickDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return MarketingCampaignClickDto.attributeTypeMap;
    }
}

export class MarketingCampaignDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: MarketingCampaignDto.TypeEnum;
    'name'?: string;
    'startDateTime'?: Date;
    'endDateTime'?: Date;
    'utmCampaign'?: string;
    'clicks'?: number;
    'marketingCampaignAffiliatePromoCodes'?: Array<MarketingCampaignAffiliatePromoCodeDto>;
    'marketingCampaignTargetCampaigns'?: Array<MarketingCampaignTargetCampaignDto>;
    'marketingCampaignClicks'?: Array<MarketingCampaignClickDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "MarketingCampaignDto.TypeEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "startDateTime",
            "baseName": "startDateTime",
            "type": "Date"
        },
        {
            "name": "endDateTime",
            "baseName": "endDateTime",
            "type": "Date"
        },
        {
            "name": "utmCampaign",
            "baseName": "utmCampaign",
            "type": "string"
        },
        {
            "name": "clicks",
            "baseName": "clicks",
            "type": "number"
        },
        {
            "name": "marketingCampaignAffiliatePromoCodes",
            "baseName": "marketingCampaignAffiliatePromoCodes",
            "type": "Array<MarketingCampaignAffiliatePromoCodeDto>"
        },
        {
            "name": "marketingCampaignTargetCampaigns",
            "baseName": "marketingCampaignTargetCampaigns",
            "type": "Array<MarketingCampaignTargetCampaignDto>"
        },
        {
            "name": "marketingCampaignClicks",
            "baseName": "marketingCampaignClicks",
            "type": "Array<MarketingCampaignClickDto>"
        }    ];

    static getAttributeTypeMap() {
        return MarketingCampaignDto.attributeTypeMap;
    }
}

export namespace MarketingCampaignDto {
    export enum TypeEnum {
        GOOGLEADWORDS = <any> 'GOOGLE_ADWORDS',
        FACEBOOKADS = <any> 'FACEBOOK_ADS',
        EDM = <any> 'EDM',
        PARTNERSHIPS = <any> 'PARTNERSHIPS',
        AFFILIATES = <any> 'AFFILIATES',
        CORPORATEORGANISATIONBENEFITS = <any> 'CORPORATE_ORGANISATION_BENEFITS',
        FACEBOOKPOSTS = <any> 'FACEBOOK_POSTS',
        CAROUSELL = <any> 'CAROUSELL',
        INSTAGRAM = <any> 'INSTAGRAM',
        BLOG = <any> 'BLOG',
        BULKPURCHASE = <any> 'BULK_PURCHASE',
        INSTAGRAMINFLUENCERS = <any> 'INSTAGRAM_INFLUENCERS',
        YAHOOADS = <any> 'YAHOO_ADS',
        BINGADS = <any> 'BING_ADS'
    }
}
export class MarketingCampaignTargetCampaignDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'campaign'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MarketingCampaignTargetCampaignDto.attributeTypeMap;
    }
}

export class Order {
    'column': number;
    'dir': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "column",
            "baseName": "column",
            "type": "number"
        },
        {
            "name": "dir",
            "baseName": "dir",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Order.attributeTypeMap;
    }
}

export class PromoCodeCampaignDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'campaign'?: CampaignDto;
    'campaignPricingCategories'?: Array<PromoCodeCampaignPricingCategoryDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "CampaignDto"
        },
        {
            "name": "campaignPricingCategories",
            "baseName": "campaignPricingCategories",
            "type": "Array<PromoCodeCampaignPricingCategoryDto>"
        }    ];

    static getAttributeTypeMap() {
        return PromoCodeCampaignDto.attributeTypeMap;
    }
}

export class PromoCodeCampaignPricingCategoryDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'pricingCategory'?: CampaignPricingCategoryDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "pricingCategory",
            "baseName": "pricingCategory",
            "type": "CampaignPricingCategoryDto"
        }    ];

    static getAttributeTypeMap() {
        return PromoCodeCampaignPricingCategoryDto.attributeTypeMap;
    }
}

export class PromoCodeCategoryDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'campaignCategory'?: CampaignCategoryDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "campaignCategory",
            "baseName": "campaignCategory",
            "type": "CampaignCategoryDto"
        }    ];

    static getAttributeTypeMap() {
        return PromoCodeCategoryDto.attributeTypeMap;
    }
}

export class PromoCodeDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: PromoCodeDto.TypeEnum;
    'usageType'?: PromoCodeDto.UsageTypeEnum;
    'description'?: string;
    'code'?: string;
    'value'?: number;
    'minimumSpend'?: number;
    'minimumQuantity'?: number;
    'currency'?: string;
    'percent'?: boolean;
    'perQuantity'?: boolean;
    'currentQuantityRedemption'?: number;
    'maxQuantityRedemption'?: number;
    'city'?: string;
    'state'?: string;
    'iso3166CountryCode'?: string;
    'validFrom'?: Date;
    'validTo'?: Date;
    'expiresAfter'?: number;
    'allowMultipleUses'?: boolean;
    'campaigns'?: Array<PromoCodeCampaignDto>;
    'categories'?: Array<PromoCodeCategoryDto>;
    'redemptionLedgers'?: Array<PromoCodeRedemptionLedgerDto>;

    static discriminator: string | undefined = "type";

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "PromoCodeDto.TypeEnum"
        },
        {
            "name": "usageType",
            "baseName": "usageType",
            "type": "PromoCodeDto.UsageTypeEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "minimumSpend",
            "baseName": "minimumSpend",
            "type": "number"
        },
        {
            "name": "minimumQuantity",
            "baseName": "minimumQuantity",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "percent",
            "baseName": "percent",
            "type": "boolean"
        },
        {
            "name": "perQuantity",
            "baseName": "perQuantity",
            "type": "boolean"
        },
        {
            "name": "currentQuantityRedemption",
            "baseName": "currentQuantityRedemption",
            "type": "number"
        },
        {
            "name": "maxQuantityRedemption",
            "baseName": "maxQuantityRedemption",
            "type": "number"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "iso3166CountryCode",
            "baseName": "iso3166CountryCode",
            "type": "string"
        },
        {
            "name": "validFrom",
            "baseName": "validFrom",
            "type": "Date"
        },
        {
            "name": "validTo",
            "baseName": "validTo",
            "type": "Date"
        },
        {
            "name": "expiresAfter",
            "baseName": "expiresAfter",
            "type": "number"
        },
        {
            "name": "allowMultipleUses",
            "baseName": "allowMultipleUses",
            "type": "boolean"
        },
        {
            "name": "campaigns",
            "baseName": "campaigns",
            "type": "Array<PromoCodeCampaignDto>"
        },
        {
            "name": "categories",
            "baseName": "categories",
            "type": "Array<PromoCodeCategoryDto>"
        },
        {
            "name": "redemptionLedgers",
            "baseName": "redemptionLedgers",
            "type": "Array<PromoCodeRedemptionLedgerDto>"
        }    ];

    static getAttributeTypeMap() {
        return PromoCodeDto.attributeTypeMap;
    }
}

export namespace PromoCodeDto {
    export enum TypeEnum {
        PARTNERCODE = <any> 'PARTNER_CODE',
        EMAILADDRESSDOMAINPARTNERPROMOTION = <any> 'EMAIL_ADDRESS_DOMAIN_PARTNER_PROMOTION',
        SPOTIFYPARTNERPROMOTION = <any> 'SPOTIFY_PARTNER_PROMOTION',
        MARKETINGCAMPAIGNPARTNERPROMOTION = <any> 'MARKETING_CAMPAIGN_PARTNER_PROMOTION',
        CORPORATESPARTNERPROMOTION = <any> 'CORPORATES_PARTNER_PROMOTION',
        ONEUSECODE = <any> 'ONE_USE_CODE',
        DEPRECATED = <any> 'DEPRECATED'
    }
    export enum UsageTypeEnum {
        MARKETING = <any> 'MARKETING',
        MERCHANT = <any> 'MERCHANT',
        DISTRIBUTION = <any> 'DISTRIBUTION'
    }
}
export class PromoCodeRedemptionLedgerDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'account'?: string;
    'quantity'?: number;
    'expiresAt'?: Date;
    'redeemedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "account",
            "baseName": "account",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "redeemedAt",
            "baseName": "redeemedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PromoCodeRedemptionLedgerDto.attributeTypeMap;
    }
}

export class Search {
    'value': string;
    'regex': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "regex",
            "baseName": "regex",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Search.attributeTypeMap;
    }
}

export class CorporatePartnerPromotionPromoCodeDto extends PromoCodeDto {
    'showFixedPrice'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "showFixedPrice",
            "baseName": "showFixedPrice",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CorporatePartnerPromotionPromoCodeDto.attributeTypeMap);
    }
}

export namespace CorporatePartnerPromotionPromoCodeDto {
}
export class EmailAddressDomainPartnerPromotionPromoCodeDto extends PromoCodeDto {
    'showFixedPrice'?: boolean;
    'emailAddressDomains'?: Array<EmailAddressDomainDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "showFixedPrice",
            "baseName": "showFixedPrice",
            "type": "boolean"
        },
        {
            "name": "emailAddressDomains",
            "baseName": "emailAddressDomains",
            "type": "Array<EmailAddressDomainDto>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(EmailAddressDomainPartnerPromotionPromoCodeDto.attributeTypeMap);
    }
}

export namespace EmailAddressDomainPartnerPromotionPromoCodeDto {
}
export class MarketingCampaignPartnerPromotionPromoCodeDto extends PromoCodeDto {
    'showFixedPrice'?: boolean;
    'marketingCampaign'?: MarketingCampaignDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "showFixedPrice",
            "baseName": "showFixedPrice",
            "type": "boolean"
        },
        {
            "name": "marketingCampaign",
            "baseName": "marketingCampaign",
            "type": "MarketingCampaignDto"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MarketingCampaignPartnerPromotionPromoCodeDto.attributeTypeMap);
    }
}

export namespace MarketingCampaignPartnerPromotionPromoCodeDto {
}
export class OneUseCodePromoCodeDto extends PromoCodeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OneUseCodePromoCodeDto.attributeTypeMap);
    }
}

export namespace OneUseCodePromoCodeDto {
}
export class PartnerCodePromoCodeDto extends PromoCodeDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PartnerCodePromoCodeDto.attributeTypeMap);
    }
}

export namespace PartnerCodePromoCodeDto {
}
export class SpotifyPartnerPromotionPromoCodeDto extends PromoCodeDto {
    'showFixedPrice'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "showFixedPrice",
            "baseName": "showFixedPrice",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SpotifyPartnerPromotionPromoCodeDto.attributeTypeMap);
    }
}

export namespace SpotifyPartnerPromotionPromoCodeDto {
}

let enumsMap: {[index: string]: any} = {
        "MarketingCampaignDto.TypeEnum": MarketingCampaignDto.TypeEnum,
        "PromoCodeDto.TypeEnum": PromoCodeDto.TypeEnum,
        "PromoCodeDto.UsageTypeEnum": PromoCodeDto.UsageTypeEnum,
}

let typeMap: {[index: string]: any} = {
    "BaseDto": BaseDto,
    "CampaignCategoryDto": CampaignCategoryDto,
    "CampaignDto": CampaignDto,
    "CampaignPricingCategoryDto": CampaignPricingCategoryDto,
    "CardIssuerDto": CardIssuerDto,
    "Column": Column,
    "DataTablesInput": DataTablesInput,
    "DataTablesOutput": DataTablesOutput,
    "EmailAddressDomainDto": EmailAddressDomainDto,
    "IssuerIdentificationNumberDto": IssuerIdentificationNumberDto,
    "ItemsPageResponse": ItemsPageResponse,
    "MarketingCampaignAffiliatePromoCodeDto": MarketingCampaignAffiliatePromoCodeDto,
    "MarketingCampaignClickDto": MarketingCampaignClickDto,
    "MarketingCampaignDto": MarketingCampaignDto,
    "MarketingCampaignTargetCampaignDto": MarketingCampaignTargetCampaignDto,
    "Order": Order,
    "PromoCodeCampaignDto": PromoCodeCampaignDto,
    "PromoCodeCampaignPricingCategoryDto": PromoCodeCampaignPricingCategoryDto,
    "PromoCodeCategoryDto": PromoCodeCategoryDto,
    "PromoCodeDto": PromoCodeDto,
    "PromoCodeRedemptionLedgerDto": PromoCodeRedemptionLedgerDto,
    "Search": Search,
    "CorporatePartnerPromotionPromoCodeDto": CorporatePartnerPromotionPromoCodeDto,
    "EmailAddressDomainPartnerPromotionPromoCodeDto": EmailAddressDomainPartnerPromotionPromoCodeDto,
    "MarketingCampaignPartnerPromotionPromoCodeDto": MarketingCampaignPartnerPromotionPromoCodeDto,
    "OneUseCodePromoCodeDto": OneUseCodePromoCodeDto,
    "PartnerCodePromoCodeDto": PartnerCodePromoCodeDto,
    "SpotifyPartnerPromotionPromoCodeDto": SpotifyPartnerPromotionPromoCodeDto,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum CampaignClicksApiApiKeys {
    JWT,
}

export class CampaignClicksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignClicksApiApiKeys, value: string) {
        (this.authentications as any)[CampaignClicksApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a marketing campaign click
     * @param campaignId Campaign ID
     * @param {*} [options] Override http request options.
     */
    public addMarketingCampaignClick (campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MarketingCampaignClickDto;  }> {
        const localVarPath = this.basePath + '/marketing/campaigns/{campaignId}/clicks'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling addMarketingCampaignClick.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MarketingCampaignClickDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MarketingCampaignClickDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsApiApiKeys {
    JWT,
}

export class CampaignsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignsApiApiKeys, value: string) {
        (this.authentications as any)[CampaignsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new marketing campaign
     * @param type Marketing Campaign Type (1 &#x3D; Google Adwords, 2 &#x3D; Facebook (Ads), 3 &#x3D; EDM, 4 &#x3D; Partnerships, 5 &#x3D; Affiliates, 6 &#x3D; Corporate / Organisation Benefits, 7 &#x3D; Facebook (Posts), 8 &#x3D; Carousell, 9 &#x3D; Instagram, 10 &#x3D; Blog, 11 &#x3D; Bulk Purchase, 12 &#x3D; Instagram (Influencers), 13 &#x3D; Yahoo (Ads), 14 &#x3D; Bing (Ads))
     * @param name Marketing Campaign Name
     * @param startDateTime Start Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param endDateTime End Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param affiliatePromoCodes Affiliate Promo Codes
     * @param targetCampaigns Target Campaigns
     * @param utmCampaign UTM Campaign
     * @param {*} [options] Override http request options.
     */
    public addMarketingCampaign (type: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14, name: string, startDateTime: Date, endDateTime: Date, affiliatePromoCodes?: string, targetCampaigns?: string, utmCampaign?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MarketingCampaignDto;  }> {
        const localVarPath = this.basePath + '/campaigns';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling addMarketingCampaign.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addMarketingCampaign.');
        }

        // verify required parameter 'startDateTime' is not null or undefined
        if (startDateTime === null || startDateTime === undefined) {
            throw new Error('Required parameter startDateTime was null or undefined when calling addMarketingCampaign.');
        }

        // verify required parameter 'endDateTime' is not null or undefined
        if (endDateTime === null || endDateTime === undefined) {
            throw new Error('Required parameter endDateTime was null or undefined when calling addMarketingCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (startDateTime !== undefined) {
            localVarFormParams['startDateTime'] = ObjectSerializer.serialize(startDateTime, "Date");
        }

        if (endDateTime !== undefined) {
            localVarFormParams['endDateTime'] = ObjectSerializer.serialize(endDateTime, "Date");
        }

        if (affiliatePromoCodes !== undefined) {
            localVarFormParams['affiliatePromoCodes'] = ObjectSerializer.serialize(affiliatePromoCodes, "string");
        }

        if (targetCampaigns !== undefined) {
            localVarFormParams['targetCampaigns'] = ObjectSerializer.serialize(targetCampaigns, "string");
        }

        if (utmCampaign !== undefined) {
            localVarFormParams['utmCampaign'] = ObjectSerializer.serialize(utmCampaign, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MarketingCampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MarketingCampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a marketing campaign
     * @param campaignId Campaign ID
     * @param {*} [options] Override http request options.
     */
    public deleteMarketingCampaign (campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/campaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling deleteMarketingCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a marketing campaign
     * @param campaignId Campaign ID
     * @param {*} [options] Override http request options.
     */
    public getMarketingCampaign (campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MarketingCampaignDto;  }> {
        const localVarPath = this.basePath + '/campaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling getMarketingCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MarketingCampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MarketingCampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all marketing campaigns
     * @param start Start Row
     * @param rows Number of Rows
     * @param searchTerm Search Term
     * @param {*} [options] Override http request options.
     */
    public getMarketingCampaigns (start: number, rows: number, searchTerm?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemsPageResponse;  }> {
        const localVarPath = this.basePath + '/campaigns';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getMarketingCampaigns.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getMarketingCampaigns.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPageResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsPageResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a marketing campaign
     * @param type Marketing Campaign Type (1 &#x3D; Google Adwords, 2 &#x3D; Facebook (Ads), 3 &#x3D; EDM, 4 &#x3D; Partnerships, 5 &#x3D; Affiliates, 6 &#x3D; Corporate / Organisation Benefits, 7 &#x3D; Facebook (Posts), 8 &#x3D; Carousell, 9 &#x3D; Instagram, 10 &#x3D; Blog, 11 &#x3D; Bulk Purchase, 12 &#x3D; Instagram (Influencers), 13 &#x3D; Yahoo (Ads), 14 &#x3D; Bing (Ads))
     * @param name Marketing Campaign Name
     * @param startDateTime Start Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param endDateTime End Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param campaignId Campaign ID
     * @param utmCampaign UTM Campaign
     * @param affiliatePromoCodes Affiliate Promo Codes
     * @param targetCampaigns Target Campaigns
     * @param campaignIds List of Campaign IDs (Comma-seperated) to restrict the promo code to
     * @param {*} [options] Override http request options.
     */
    public updateMarketingCampaign (type: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14, name: string, startDateTime: Date, endDateTime: Date, campaignId: string, utmCampaign: string, affiliatePromoCodes?: string, targetCampaigns?: string, campaignIds?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MarketingCampaignDto;  }> {
        const localVarPath = this.basePath + '/campaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling updateMarketingCampaign.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateMarketingCampaign.');
        }

        // verify required parameter 'startDateTime' is not null or undefined
        if (startDateTime === null || startDateTime === undefined) {
            throw new Error('Required parameter startDateTime was null or undefined when calling updateMarketingCampaign.');
        }

        // verify required parameter 'endDateTime' is not null or undefined
        if (endDateTime === null || endDateTime === undefined) {
            throw new Error('Required parameter endDateTime was null or undefined when calling updateMarketingCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateMarketingCampaign.');
        }

        // verify required parameter 'utmCampaign' is not null or undefined
        if (utmCampaign === null || utmCampaign === undefined) {
            throw new Error('Required parameter utmCampaign was null or undefined when calling updateMarketingCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (startDateTime !== undefined) {
            localVarFormParams['startDateTime'] = ObjectSerializer.serialize(startDateTime, "Date");
        }

        if (endDateTime !== undefined) {
            localVarFormParams['endDateTime'] = ObjectSerializer.serialize(endDateTime, "Date");
        }

        if (affiliatePromoCodes !== undefined) {
            localVarFormParams['affiliatePromoCodes'] = ObjectSerializer.serialize(affiliatePromoCodes, "string");
        }

        if (targetCampaigns !== undefined) {
            localVarFormParams['targetCampaigns'] = ObjectSerializer.serialize(targetCampaigns, "string");
        }

        if (utmCampaign !== undefined) {
            localVarFormParams['utmCampaign'] = ObjectSerializer.serialize(utmCampaign, "string");
        }

        if (campaignIds !== undefined) {
            localVarFormParams['campaignIds'] = ObjectSerializer.serialize(campaignIds, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MarketingCampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MarketingCampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsDatatableApiApiKeys {
    JWT,
}

export class CampaignsDatatableApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignsDatatableApiApiKeys, value: string) {
        (this.authentications as any)[CampaignsDatatableApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve all marketing campaigns
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public getMarketingCampaigns1 (body?: DataTablesInput, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DataTablesOutput;  }> {
        const localVarPath = this.basePath + '/campaigns/datatable';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DataTablesInput")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataTablesOutput;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataTablesOutput");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CardIssuersApiApiKeys {
    JWT,
}

export class CardIssuersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CardIssuersApiApiKeys, value: string) {
        (this.authentications as any)[CardIssuersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new card issuer
     * @param name Card Issuer Name
     * @param issuerIdentificationNumbers List of Issuer Identification Numbers (Comma-seperated)
     * @param {*} [options] Override http request options.
     */
    public addCardIssuer (name?: string, issuerIdentificationNumbers?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CardIssuerDto;  }> {
        const localVarPath = this.basePath + '/cards/issuers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (issuerIdentificationNumbers !== undefined) {
            localVarFormParams['issuerIdentificationNumbers'] = ObjectSerializer.serialize(issuerIdentificationNumbers, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CardIssuerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CardIssuerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a card issuer
     * @param issuer Card Issuer ID
     * @param {*} [options] Override http request options.
     */
    public deleteCardIssuer (issuer: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/cards/issuers/{issuer}'
            .replace('{' + 'issuer' + '}', encodeURIComponent(String(issuer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'issuer' is not null or undefined
        if (issuer === null || issuer === undefined) {
            throw new Error('Required parameter issuer was null or undefined when calling deleteCardIssuer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a card issuer
     * @param issuer Card Issuer ID
     * @param {*} [options] Override http request options.
     */
    public getCardIssuer (issuer: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CardIssuerDto;  }> {
        const localVarPath = this.basePath + '/cards/issuers/{issuer}'
            .replace('{' + 'issuer' + '}', encodeURIComponent(String(issuer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'issuer' is not null or undefined
        if (issuer === null || issuer === undefined) {
            throw new Error('Required parameter issuer was null or undefined when calling getCardIssuer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CardIssuerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CardIssuerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all card issuers
     * @param start Start Row
     * @param rows Number of Rows
     * @param searchTerm Search Term
     * @param {*} [options] Override http request options.
     */
    public getCardIssuers (start: number, rows: number, searchTerm?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemsPageResponse;  }> {
        const localVarPath = this.basePath + '/cards/issuers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getCardIssuers.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getCardIssuers.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPageResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsPageResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a card issuer
     * @param issuer Card Issuer ID
     * @param name Card Issuer Name
     * @param issuerIdentificationNumbers List of Issuer Identification Numbers (Comma-seperated)
     * @param {*} [options] Override http request options.
     */
    public updateCardIssuer (issuer: string, name?: string, issuerIdentificationNumbers?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CardIssuerDto;  }> {
        const localVarPath = this.basePath + '/cards/issuers/{issuer}'
            .replace('{' + 'issuer' + '}', encodeURIComponent(String(issuer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'issuer' is not null or undefined
        if (issuer === null || issuer === undefined) {
            throw new Error('Required parameter issuer was null or undefined when calling updateCardIssuer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (issuerIdentificationNumbers !== undefined) {
            localVarFormParams['issuerIdentificationNumbers'] = ObjectSerializer.serialize(issuerIdentificationNumbers, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CardIssuerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CardIssuerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CardIssuersDatatableApiApiKeys {
    JWT,
}

export class CardIssuersDatatableApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CardIssuersDatatableApiApiKeys, value: string) {
        (this.authentications as any)[CardIssuersDatatableApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve all card issuers
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public getMarketingCampaigns2 (body?: DataTablesInput, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DataTablesOutput;  }> {
        const localVarPath = this.basePath + '/cards/issuers/datatable';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DataTablesInput")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataTablesOutput;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataTablesOutput");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LookupApiApiKeys {
    JWT,
}

export class LookupApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LookupApiApiKeys, value: string) {
        (this.authentications as any)[LookupApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param campaignId 
     * @param promoCodeId 
     * @param {*} [options] Override http request options.
     */
    public getCampaignPromoCode (campaignId: string, promoCodeId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PromoCodeDto;  }> {
        const localVarPath = this.basePath + '/lookup/campaigns/{campaignId}/promoCodes/{promoCodeId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)))
            .replace('{' + 'promoCodeId' + '}', encodeURIComponent(String(promoCodeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling getCampaignPromoCode.');
        }

        // verify required parameter 'promoCodeId' is not null or undefined
        if (promoCodeId === null || promoCodeId === undefined) {
            throw new Error('Required parameter promoCodeId was null or undefined when calling getCampaignPromoCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PromoCodeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PromoCodeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaignId 
     * @param promoCodeId 
     * @param usageTypeId 
     * @param {*} [options] Override http request options.
     */
    public getCampaignPromoCodeByUsageType (campaignId: string, promoCodeId: string, usageTypeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PromoCodeDto;  }> {
        const localVarPath = this.basePath + '/lookup/campaigns/{campaignId}/promoCodes/{promoCodeId}/usage/{usageTypeId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)))
            .replace('{' + 'promoCodeId' + '}', encodeURIComponent(String(promoCodeId)))
            .replace('{' + 'usageTypeId' + '}', encodeURIComponent(String(usageTypeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling getCampaignPromoCodeByUsageType.');
        }

        // verify required parameter 'promoCodeId' is not null or undefined
        if (promoCodeId === null || promoCodeId === undefined) {
            throw new Error('Required parameter promoCodeId was null or undefined when calling getCampaignPromoCodeByUsageType.');
        }

        // verify required parameter 'usageTypeId' is not null or undefined
        if (usageTypeId === null || usageTypeId === undefined) {
            throw new Error('Required parameter usageTypeId was null or undefined when calling getCampaignPromoCodeByUsageType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PromoCodeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PromoCodeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaignId 
     * @param {*} [options] Override http request options.
     */
    public getCampaignPromoCodes (campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PromoCodeDto>;  }> {
        const localVarPath = this.basePath + '/lookup/campaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling getCampaignPromoCodes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PromoCodeDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PromoCodeDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaignId 
     * @param usageTypeId 
     * @param {*} [options] Override http request options.
     */
    public getCampaignPromoCodesByUsageType (campaignId: string, usageTypeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PromoCodeDto>;  }> {
        const localVarPath = this.basePath + '/lookup/campaigns/{campaignId}/usage/{usageTypeId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)))
            .replace('{' + 'usageTypeId' + '}', encodeURIComponent(String(usageTypeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling getCampaignPromoCodesByUsageType.');
        }

        // verify required parameter 'usageTypeId' is not null or undefined
        if (usageTypeId === null || usageTypeId === undefined) {
            throw new Error('Required parameter usageTypeId was null or undefined when calling getCampaignPromoCodesByUsageType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PromoCodeDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PromoCodeDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param cardIssuerId 
     * @param {*} [options] Override http request options.
     */
    public isCardIssuerExists (cardIssuerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/isCardIssuerExists/{cardIssuerId}'
            .replace('{' + 'cardIssuerId' + '}', encodeURIComponent(String(cardIssuerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cardIssuerId' is not null or undefined
        if (cardIssuerId === null || cardIssuerId === undefined) {
            throw new Error('Required parameter cardIssuerId was null or undefined when calling isCardIssuerExists.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param promoCode 
     * @param account 
     * @param {*} [options] Override http request options.
     */
    public isPromoCodeUsed (promoCode: string, account?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/promoCodes/{promoCode}/isUsed'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling isPromoCodeUsed.');
        }

        if (account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(account, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PromoCodeRedemptionLedgerApiApiKeys {
    JWT,
}

export class PromoCodeRedemptionLedgerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PromoCodeRedemptionLedgerApiApiKeys, value: string) {
        (this.authentications as any)[PromoCodeRedemptionLedgerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a promo code redemption ledger
     * @param promoCode Promo Code ID
     * @param quantity Quantity
     * @param expiresAt Expires Date/Time of inventory ledger with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param account Account ID
     * @param {*} [options] Override http request options.
     */
    public addPromoCodeRedemptionLedger (promoCode: string, quantity: number, expiresAt: Date, account?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PromoCodeRedemptionLedgerDto;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/ledgers'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling addPromoCodeRedemptionLedger.');
        }

        // verify required parameter 'quantity' is not null or undefined
        if (quantity === null || quantity === undefined) {
            throw new Error('Required parameter quantity was null or undefined when calling addPromoCodeRedemptionLedger.');
        }

        // verify required parameter 'expiresAt' is not null or undefined
        if (expiresAt === null || expiresAt === undefined) {
            throw new Error('Required parameter expiresAt was null or undefined when calling addPromoCodeRedemptionLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (account !== undefined) {
            localVarFormParams['account'] = ObjectSerializer.serialize(account, "string");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expiresAt'] = ObjectSerializer.serialize(expiresAt, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PromoCodeRedemptionLedgerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PromoCodeRedemptionLedgerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a promo code redemption ledger
     * @param promoCode 
     * @param ledger 
     * @param {*} [options] Override http request options.
     */
    public deletePromoCodeRedemptionLedger (promoCode: string, ledger: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/ledgers/{ledger}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'ledger' + '}', encodeURIComponent(String(ledger)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling deletePromoCodeRedemptionLedger.');
        }

        // verify required parameter 'ledger' is not null or undefined
        if (ledger === null || ledger === undefined) {
            throw new Error('Required parameter ledger was null or undefined when calling deletePromoCodeRedemptionLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a promo code redemption ledger
     * @param promoCode 
     * @param ledger 
     * @param {*} [options] Override http request options.
     */
    public getPromoCodeRedemptionLedger (promoCode: string, ledger: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PromoCodeRedemptionLedgerDto;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/ledgers/{ledger}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'ledger' + '}', encodeURIComponent(String(ledger)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling getPromoCodeRedemptionLedger.');
        }

        // verify required parameter 'ledger' is not null or undefined
        if (ledger === null || ledger === undefined) {
            throw new Error('Required parameter ledger was null or undefined when calling getPromoCodeRedemptionLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PromoCodeRedemptionLedgerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PromoCodeRedemptionLedgerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Redeems a promo code redemption ledger
     * @param promoCode 
     * @param ledger 
     * @param {*} [options] Override http request options.
     */
    public redeemPromoCodeRedemptionLedger (promoCode: string, ledger: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/ledgers/{ledger}/redeem'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'ledger' + '}', encodeURIComponent(String(ledger)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling redeemPromoCodeRedemptionLedger.');
        }

        // verify required parameter 'ledger' is not null or undefined
        if (ledger === null || ledger === undefined) {
            throw new Error('Required parameter ledger was null or undefined when calling redeemPromoCodeRedemptionLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a promo code redemption ledger
     * @param promoCode 
     * @param ledger 
     * @param quantity 
     * @param expiresAt 
     * @param {*} [options] Override http request options.
     */
    public updatePromoCodeRedemptionLedger (promoCode: string, ledger: string, quantity?: number, expiresAt?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/ledgers/{ledger}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'ledger' + '}', encodeURIComponent(String(ledger)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling updatePromoCodeRedemptionLedger.');
        }

        // verify required parameter 'ledger' is not null or undefined
        if (ledger === null || ledger === undefined) {
            throw new Error('Required parameter ledger was null or undefined when calling updatePromoCodeRedemptionLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expiresAt'] = ObjectSerializer.serialize(expiresAt, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PromoCodesApiApiKeys {
    JWT,
}

export class PromoCodesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PromoCodesApiApiKeys, value: string) {
        (this.authentications as any)[PromoCodesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Sign-up Bonus, Partner Code, Partner Promotion, and One-use Code can only be created by Administrators and Marketing Executives. Partner Code can be created by Account Managers and Merchants. User Referral can be created by Customer Service Officers and Users.
     * @summary Adds a new promo code to this account
     * @param account Account ID
     * @param body Promo Code
     * @param {*} [options] Override http request options.
     */
    public addPromoCode (account?: string, body?: PromoCodeDto, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PromoCodeDto;  }> {
        const localVarPath = this.basePath + '/promoCodes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(account, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PromoCodeDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PromoCodeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PromoCodeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a promo code
     * @param promoCode 
     * @param {*} [options] Override http request options.
     */
    public deletePromoCode (promoCode: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling deletePromoCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a promo code
     * @param promoCode 
     * @param {*} [options] Override http request options.
     */
    public getPromoCode (promoCode: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PromoCodeDto;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling getPromoCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PromoCodeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PromoCodeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve Valid Promo Code by Code
     * @param code 
     * @param {*} [options] Override http request options.
     */
    public getPromoCode1 (code: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/promoCodes/valid/{code}'
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getPromoCode1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all promo codes
     * @param start Start Row
     * @param rows Number of Rows
     * @param searchTerm Search Term
     * @param type Promo Code Type (1 &#x3D; Sign-up Bonus, 2 &#x3D; User Referral, 3 &#x3D; Partner Code, 501 &#x3D; Email Address Domain Partner Promotion, 502 &#x3D; Spotify Partner Promotion, 503 &#x3D; Marketing Campaign Partner Promotion, 6 &#x3D; One-use Code)
     * @param {*} [options] Override http request options.
     */
    public getPromoCodes (start: number, rows: number, searchTerm?: string, type?: 1 | 2 | 3 | 501 | 502 | 503 | 6, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemsPageResponse;  }> {
        const localVarPath = this.basePath + '/promoCodes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getPromoCodes.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getPromoCodes.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "1 | 2 | 3 | 501 | 502 | 503 | 6");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPageResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsPageResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a promo code
     * @param promoCode Promo Code ID
     * @param body Promo Code
     * @param {*} [options] Override http request options.
     */
    public putPromoCode (promoCode: string, body?: PromoCodeDto, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PromoCodeDto;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling putPromoCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PromoCodeDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PromoCodeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PromoCodeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PromoCodesCampaignsApiApiKeys {
    JWT,
}

export class PromoCodesCampaignsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PromoCodesCampaignsApiApiKeys, value: string) {
        (this.authentications as any)[PromoCodesCampaignsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds one or more campaigns to this promo code
     * @param promoCode Promo Code Id
     * @param campaign Campaign Id
     * @param {*} [options] Override http request options.
     */
    public addPromoCodeCampaign (promoCode: string, campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PromoCodeCampaignDto;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/campaigns'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling addPromoCodeCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addPromoCodeCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (campaign !== undefined) {
            localVarFormParams['campaign'] = ObjectSerializer.serialize(campaign, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PromoCodeCampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PromoCodeCampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a campaign from this promo code
     * @param promoCode Promo Code Id
     * @param campaign Campaign Id
     * @param {*} [options] Override http request options.
     */
    public deletePromoCodeCampaign (promoCode: string, campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/campaigns/{campaign}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling deletePromoCodeCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deletePromoCodeCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a campaign from this promo code
     * @param promoCode Promo Code Id
     * @param campaign Campaign Id
     * @param {*} [options] Override http request options.
     */
    public getPromoCodeCampaign (promoCode: string, campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PromoCodeCampaignDto;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/campaigns/{campaign}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling getPromoCodeCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPromoCodeCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PromoCodeCampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PromoCodeCampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all campaigns from this promo code
     * @param promoCode Promo Code Id
     * @param {*} [options] Override http request options.
     */
    public getPromoCodeCampaigns (promoCode: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PromoCodeCampaignDto>;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/campaigns'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling getPromoCodeCampaigns.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PromoCodeCampaignDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PromoCodeCampaignDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PromoCodesCampaignsPricingCategoriesApiApiKeys {
    JWT,
}

export class PromoCodesCampaignsPricingCategoriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PromoCodesCampaignsPricingCategoriesApiApiKeys, value: string) {
        (this.authentications as any)[PromoCodesCampaignsPricingCategoriesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a pricing category to this promo code campaign
     * @param promoCode Promo Code Id
     * @param campaign Campaign Id
     * @param pricingCategory Pricing Category Id
     * @param {*} [options] Override http request options.
     */
    public addCampaignPricingCategory (promoCode: string, campaign: string, pricingCategory: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PromoCodeCampaignPricingCategoryDto;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/campaigns/{campaign}/pricingCategories'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling addCampaignPricingCategory.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addCampaignPricingCategory.');
        }

        // verify required parameter 'pricingCategory' is not null or undefined
        if (pricingCategory === null || pricingCategory === undefined) {
            throw new Error('Required parameter pricingCategory was null or undefined when calling addCampaignPricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (pricingCategory !== undefined) {
            localVarFormParams['pricingCategory'] = ObjectSerializer.serialize(pricingCategory, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PromoCodeCampaignPricingCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PromoCodeCampaignPricingCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a campaign from this promo code
     * @param promoCode Promo Code Id
     * @param campaign Campaign Id
     * @param pricingCategory Pricing Category Id
     * @param {*} [options] Override http request options.
     */
    public deleteCampaignPricingCategory (promoCode: string, campaign: string, pricingCategory: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/campaigns/{campaign}/pricingCategories/{pricingCategory}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'pricingCategory' + '}', encodeURIComponent(String(pricingCategory)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling deleteCampaignPricingCategory.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteCampaignPricingCategory.');
        }

        // verify required parameter 'pricingCategory' is not null or undefined
        if (pricingCategory === null || pricingCategory === undefined) {
            throw new Error('Required parameter pricingCategory was null or undefined when calling deleteCampaignPricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all pricing categories from this promo code campaign
     * @param promoCode Promo Code Id
     * @param campaign Campaign Id
     * @param {*} [options] Override http request options.
     */
    public getCampaignPricingCategories (promoCode: string, campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PromoCodeCampaignPricingCategoryDto>;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/campaigns/{campaign}/pricingCategories'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling getCampaignPricingCategories.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getCampaignPricingCategories.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PromoCodeCampaignPricingCategoryDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PromoCodeCampaignPricingCategoryDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a campaign from this promo code
     * @param promoCode Promo Code Id
     * @param campaign Campaign Id
     * @param pricingCategory Pricing Category Id
     * @param {*} [options] Override http request options.
     */
    public getCampaignPricingCategory (promoCode: string, campaign: string, pricingCategory: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PromoCodeCampaignPricingCategoryDto;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/campaigns/{campaign}/pricingCategories/{pricingCategory}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'pricingCategory' + '}', encodeURIComponent(String(pricingCategory)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling getCampaignPricingCategory.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getCampaignPricingCategory.');
        }

        // verify required parameter 'pricingCategory' is not null or undefined
        if (pricingCategory === null || pricingCategory === undefined) {
            throw new Error('Required parameter pricingCategory was null or undefined when calling getCampaignPricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PromoCodeCampaignPricingCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PromoCodeCampaignPricingCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PromoCodesCategoriesApiApiKeys {
    JWT,
}

export class PromoCodesCategoriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PromoCodesCategoriesApiApiKeys, value: string) {
        (this.authentications as any)[PromoCodesCategoriesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds one or more categories to this promo code
     * @param promoCode 
     * @param categories List of Category IDs (Comma-seperated)
     * @param {*} [options] Override http request options.
     */
    public addPromoCodeCategories (promoCode: string, categories: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PromoCodeCategoryDto>;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/categories'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling addPromoCodeCategories.');
        }

        // verify required parameter 'categories' is not null or undefined
        if (categories === null || categories === undefined) {
            throw new Error('Required parameter categories was null or undefined when calling addPromoCodeCategories.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (categories !== undefined) {
            localVarFormParams['categories'] = ObjectSerializer.serialize(categories, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PromoCodeCategoryDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PromoCodeCategoryDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a category from this promo code
     * @param promoCode 
     * @param category 
     * @param {*} [options] Override http request options.
     */
    public deletePromoCodeCategory (promoCode: string, category: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/categories/{category}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'category' + '}', encodeURIComponent(String(category)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling deletePromoCodeCategory.');
        }

        // verify required parameter 'category' is not null or undefined
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling deletePromoCodeCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all categories from this promo code
     * @param promoCode 
     * @param {*} [options] Override http request options.
     */
    public getPromoCodeCategories (promoCode: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PromoCodeCategoryDto>;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/categories'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling getPromoCodeCategories.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PromoCodeCategoryDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PromoCodeCategoryDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a category from this promo code
     * @param promoCode 
     * @param category 
     * @param {*} [options] Override http request options.
     */
    public getPromoCodeCategory (promoCode: string, category: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PromoCodeCategoryDto;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/categories/{category}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'category' + '}', encodeURIComponent(String(category)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling getPromoCodeCategory.');
        }

        // verify required parameter 'category' is not null or undefined
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling getPromoCodeCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PromoCodeCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PromoCodeCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PromoCodesDatatableApiApiKeys {
    JWT,
}

export class PromoCodesDatatableApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PromoCodesDatatableApiApiKeys, value: string) {
        (this.authentications as any)[PromoCodesDatatableApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve all promo codes
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public getPromoCodes1 (body?: DataTablesInput, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DataTablesOutput;  }> {
        const localVarPath = this.basePath + '/promoCodes/datatable';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DataTablesInput")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataTablesOutput;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataTablesOutput");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PromoCodesEmailsApiApiKeys {
    JWT,
}

export class PromoCodesEmailsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PromoCodesEmailsApiApiKeys, value: string) {
        (this.authentications as any)[PromoCodesEmailsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds one or more email address domains to this Email Address Domain Partnership Promotion Code
     * @param promoCode 
     * @param emailAddressDomain Email Address Domain to add to this promotion code
     * @param {*} [options] Override http request options.
     */
    public addEmailAddressDomain (promoCode: string, emailAddressDomain: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EmailAddressDomainDto;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/emails'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling addEmailAddressDomain.');
        }

        // verify required parameter 'emailAddressDomain' is not null or undefined
        if (emailAddressDomain === null || emailAddressDomain === undefined) {
            throw new Error('Required parameter emailAddressDomain was null or undefined when calling addEmailAddressDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (emailAddressDomain !== undefined) {
            localVarFormParams['emailAddressDomain'] = ObjectSerializer.serialize(emailAddressDomain, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EmailAddressDomainDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailAddressDomainDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an email address domain from this Email Address Domain Partnership Promotion Code
     * @param promoCode 
     * @param emailAddressDomain 
     * @param {*} [options] Override http request options.
     */
    public deleteEmailAddressDomain (promoCode: string, emailAddressDomain: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/emails/{emailAddressDomain}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'emailAddressDomain' + '}', encodeURIComponent(String(emailAddressDomain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling deleteEmailAddressDomain.');
        }

        // verify required parameter 'emailAddressDomain' is not null or undefined
        if (emailAddressDomain === null || emailAddressDomain === undefined) {
            throw new Error('Required parameter emailAddressDomain was null or undefined when calling deleteEmailAddressDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves an email address domain from this Email Address Domain Partnership Promotion Code
     * @param promoCode 
     * @param emailAddressDomain 
     * @param {*} [options] Override http request options.
     */
    public getEmailAddressDomain (promoCode: string, emailAddressDomain: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EmailAddressDomainDto;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/emails/{emailAddressDomain}'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)))
            .replace('{' + 'emailAddressDomain' + '}', encodeURIComponent(String(emailAddressDomain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling getEmailAddressDomain.');
        }

        // verify required parameter 'emailAddressDomain' is not null or undefined
        if (emailAddressDomain === null || emailAddressDomain === undefined) {
            throw new Error('Required parameter emailAddressDomain was null or undefined when calling getEmailAddressDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EmailAddressDomainDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailAddressDomainDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the email address domains from this Email Address Domain Partner Promotion Code
     * @param promoCode 
     * @param {*} [options] Override http request options.
     */
    public getEmailAddressDomains (promoCode: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<EmailAddressDomainDto>;  }> {
        const localVarPath = this.basePath + '/promoCodes/{promoCode}/emails'
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling getEmailAddressDomains.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<EmailAddressDomainDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EmailAddressDomainDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
