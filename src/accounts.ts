/**
 * Hapz Account API
 * This is the Account API for Hapz.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest from 'request'
import http from 'http'
import Promise from 'bluebird';

let defaultBasePath = process.env.ACCOUNT_MANAGEMENT_SERVICE_API!;

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AccessControlDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'accessControl'?: AccessControlDto.AccessControlEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "accessControl",
            "baseName": "accessControl",
            "type": "AccessControlDto.AccessControlEnum"
        }    ];

    static getAttributeTypeMap() {
        return AccessControlDto.attributeTypeMap;
    }
}

export namespace AccessControlDto {
    export enum AccessControlEnum {
        USERSFULLCONTROL = <any> 'USERS_FULL_CONTROL',
        CAMPAIGNSFULLCONTROL = <any> 'CAMPAIGNS_FULL_CONTROL'
    }
}
export class AccountBySession {
    'accountId'?: string;
    'accountDisabled'?: boolean;
    'roles'?: Array<AccountBySession.RolesEnum>;
    'accessControls'?: Array<AccountBySession.AccessControlsEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "accountDisabled",
            "baseName": "accountDisabled",
            "type": "boolean"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<AccountBySession.RolesEnum>"
        },
        {
            "name": "accessControls",
            "baseName": "accessControls",
            "type": "Array<AccountBySession.AccessControlsEnum>"
        }    ];

    static getAttributeTypeMap() {
        return AccountBySession.attributeTypeMap;
    }
}

export namespace AccountBySession {
    export enum RolesEnum {
        USER = <any> 'USER',
        MERCHANT = <any> 'MERCHANT',
        ACCOUNTMANAGER = <any> 'ACCOUNT_MANAGER',
        ADMINISTRATOR = <any> 'ADMINISTRATOR',
        DATAANALYST = <any> 'DATA_ANALYST',
        CUSTOMERSERVICEOFFICER = <any> 'CUSTOMER_SERVICE_OFFICER',
        MARKETINGEXECUTIVE = <any> 'MARKETING_EXECUTIVE',
        POSTERMINAL = <any> 'POS_TERMINAL'
    }
    export enum AccessControlsEnum {
        USERSFULLCONTROL = <any> 'USERS_FULL_CONTROL',
        CAMPAIGNSFULLCONTROL = <any> 'CAMPAIGNS_FULL_CONTROL'
    }
}
export class AccountCreditsLedgerDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'description'?: string;
    'value'?: number;
    'currency'?: string;
    'exchangeRateFromCreditsToBaseCurrency'?: number;
    'exchangeRateFromCreditsToSGD'?: number;
    'expired'?: boolean;
    'committed'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "exchangeRateFromCreditsToBaseCurrency",
            "baseName": "exchangeRateFromCreditsToBaseCurrency",
            "type": "number"
        },
        {
            "name": "exchangeRateFromCreditsToSGD",
            "baseName": "exchangeRateFromCreditsToSGD",
            "type": "number"
        },
        {
            "name": "expired",
            "baseName": "expired",
            "type": "boolean"
        },
        {
            "name": "committed",
            "baseName": "committed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AccountCreditsLedgerDto.attributeTypeMap;
    }
}

export class AccountDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'loginId'?: string;
    'filteredLoginId'?: string;
    'emailAddress'?: string;
    'emailAddressVerified'?: boolean;
    'firstName'?: string;
    'lastName'?: string;
    'image'?: Document;
    'localeInfo'?: LocaleInfoDto;
    'creditsBaseCurrency'?: string;
    'disabledAt'?: Date;
    'disabledBy'?: string;
    'thirdPartyLogins'?: Array<ThirdPartyLoginDto>;
    'roles'?: Array<RoleDto>;
    'accessControls'?: Array<AccessControlDto>;
    'creditsBalance'?: number;
    'disabled'?: boolean;
    'passwordLogin'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "loginId",
            "baseName": "loginId",
            "type": "string"
        },
        {
            "name": "filteredLoginId",
            "baseName": "filteredLoginId",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "emailAddressVerified",
            "baseName": "emailAddressVerified",
            "type": "boolean"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Document"
        },
        {
            "name": "localeInfo",
            "baseName": "localeInfo",
            "type": "LocaleInfoDto"
        },
        {
            "name": "creditsBaseCurrency",
            "baseName": "creditsBaseCurrency",
            "type": "string"
        },
        {
            "name": "disabledAt",
            "baseName": "disabledAt",
            "type": "Date"
        },
        {
            "name": "disabledBy",
            "baseName": "disabledBy",
            "type": "string"
        },
        {
            "name": "thirdPartyLogins",
            "baseName": "thirdPartyLogins",
            "type": "Array<ThirdPartyLoginDto>"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<RoleDto>"
        },
        {
            "name": "accessControls",
            "baseName": "accessControls",
            "type": "Array<AccessControlDto>"
        },
        {
            "name": "creditsBalance",
            "baseName": "creditsBalance",
            "type": "number"
        },
        {
            "name": "disabled",
            "baseName": "disabled",
            "type": "boolean"
        },
        {
            "name": "passwordLogin",
            "baseName": "passwordLogin",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AccountDto.attributeTypeMap;
    }
}

export class AccountSessionDto {
    'account'?: AccountDto;
    'accessToken'?: string;
    'refreshToken'?: string;
    'expiresIn'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "account",
            "baseName": "account",
            "type": "AccountDto"
        },
        {
            "name": "accessToken",
            "baseName": "access_token",
            "type": "string"
        },
        {
            "name": "refreshToken",
            "baseName": "refresh_token",
            "type": "string"
        },
        {
            "name": "expiresIn",
            "baseName": "expires_in",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AccountSessionDto.attributeTypeMap;
    }
}

export class ApiKey {
    'type'?: ApiKey.TypeEnum;
    'apiKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "ApiKey.TypeEnum"
        },
        {
            "name": "apiKey",
            "baseName": "apiKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiKey.attributeTypeMap;
    }
}

export namespace ApiKey {
    export enum TypeEnum {
        GLOBAL = <any> 'GLOBAL'
    }
}
export class ApiKeyDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'apiKey'?: ApiKey;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "apiKey",
            "baseName": "apiKey",
            "type": "ApiKey"
        }    ];

    static getAttributeTypeMap() {
        return ApiKeyDto.attributeTypeMap;
    }
}

export class BaseDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return BaseDto.attributeTypeMap;
    }
}

export class CampaignDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'aliasId'?: string;
    'name'?: string;
    'description'?: string;
    'categoryId'?: string;
    'categoryName'?: string;
    'categoryUrl'?: string;
    'subcategoryId'?: string;
    'subcategoryName'?: string;
    'bannerImage1800x562'?: string;
    'bannerImage800x533'?: string;
    'termsAndConditions'?: string;
    'creditsPercentage'?: number;
    'merchant'?: CampaignMerchantDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "aliasId",
            "baseName": "aliasId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "string"
        },
        {
            "name": "categoryName",
            "baseName": "categoryName",
            "type": "string"
        },
        {
            "name": "categoryUrl",
            "baseName": "categoryUrl",
            "type": "string"
        },
        {
            "name": "subcategoryId",
            "baseName": "subcategoryId",
            "type": "string"
        },
        {
            "name": "subcategoryName",
            "baseName": "subcategoryName",
            "type": "string"
        },
        {
            "name": "bannerImage1800x562",
            "baseName": "bannerImage1800x562",
            "type": "string"
        },
        {
            "name": "bannerImage800x533",
            "baseName": "bannerImage800x533",
            "type": "string"
        },
        {
            "name": "termsAndConditions",
            "baseName": "termsAndConditions",
            "type": "string"
        },
        {
            "name": "creditsPercentage",
            "baseName": "creditsPercentage",
            "type": "number"
        },
        {
            "name": "merchant",
            "baseName": "merchant",
            "type": "CampaignMerchantDto"
        }    ];

    static getAttributeTypeMap() {
        return CampaignDto.attributeTypeMap;
    }
}

export class CampaignMerchantDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'facebookPixelId'?: string;
    'googleAnalyticsPixelId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "facebookPixelId",
            "baseName": "facebookPixelId",
            "type": "string"
        },
        {
            "name": "googleAnalyticsPixelId",
            "baseName": "googleAnalyticsPixelId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignMerchantDto.attributeTypeMap;
    }
}

export class CampaignTimeslotDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'pricingPackageId'?: string;
    'pricingPackageName'?: string;
    'startDateTime'?: Date;
    'startDateTimeOffset'?: string;
    'endDateTime'?: Date;
    'endDateTimeOffset'?: string;
    'location'?: LocationDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "pricingPackageId",
            "baseName": "pricingPackageId",
            "type": "string"
        },
        {
            "name": "pricingPackageName",
            "baseName": "pricingPackageName",
            "type": "string"
        },
        {
            "name": "startDateTime",
            "baseName": "startDateTime",
            "type": "Date"
        },
        {
            "name": "startDateTimeOffset",
            "baseName": "startDateTimeOffset",
            "type": "string"
        },
        {
            "name": "endDateTime",
            "baseName": "endDateTime",
            "type": "Date"
        },
        {
            "name": "endDateTimeOffset",
            "baseName": "endDateTimeOffset",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "LocationDto"
        }    ];

    static getAttributeTypeMap() {
        return CampaignTimeslotDto.attributeTypeMap;
    }
}

export class CardDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: CardDto.TypeEnum;
    'customerReference'?: string;
    'paymentSourceReference'?: string;
    'name'?: string;
    'issuerIdentificationNumber'?: string;
    'brand'?: string;
    'country'?: string;
    'expiryMonth'?: number;
    'expiryYear'?: number;
    'last4'?: string;
    'fingerprint'?: string;
    'card3DSecure'?: CardDto.Card3DSecureEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CardDto.TypeEnum"
        },
        {
            "name": "customerReference",
            "baseName": "customerReference",
            "type": "string"
        },
        {
            "name": "paymentSourceReference",
            "baseName": "paymentSourceReference",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "issuerIdentificationNumber",
            "baseName": "issuerIdentificationNumber",
            "type": "string"
        },
        {
            "name": "brand",
            "baseName": "brand",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "expiryMonth",
            "baseName": "expiryMonth",
            "type": "number"
        },
        {
            "name": "expiryYear",
            "baseName": "expiryYear",
            "type": "number"
        },
        {
            "name": "last4",
            "baseName": "last4",
            "type": "string"
        },
        {
            "name": "fingerprint",
            "baseName": "fingerprint",
            "type": "string"
        },
        {
            "name": "card3DSecure",
            "baseName": "card3DSecure",
            "type": "CardDto.Card3DSecureEnum"
        }    ];

    static getAttributeTypeMap() {
        return CardDto.attributeTypeMap;
    }
}

export namespace CardDto {
    export enum TypeEnum {
        CARD = <any> 'CARD'
    }
    export enum Card3DSecureEnum {
        UNSUPPORTED = <any> 'UNSUPPORTED',
        OPTIONAL = <any> 'OPTIONAL',
        REQUIRED = <any> 'REQUIRED'
    }
}
export class Column {
    'data'?: string;
    'name'?: string;
    'searchable': boolean;
    'orderable': boolean;
    'search': Search;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "searchable",
            "baseName": "searchable",
            "type": "boolean"
        },
        {
            "name": "orderable",
            "baseName": "orderable",
            "type": "boolean"
        },
        {
            "name": "search",
            "baseName": "search",
            "type": "Search"
        }    ];

    static getAttributeTypeMap() {
        return Column.attributeTypeMap;
    }
}

export class DataTablesInput {
    'draw': number;
    'start': number;
    'length': number;
    'search': Search;
    'order'?: Array<Order>;
    'columns'?: Array<Column>;
    'columnsAsMap'?: { [key: string]: Column; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "length",
            "baseName": "length",
            "type": "number"
        },
        {
            "name": "search",
            "baseName": "search",
            "type": "Search"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Array<Order>"
        },
        {
            "name": "columns",
            "baseName": "columns",
            "type": "Array<Column>"
        },
        {
            "name": "columnsAsMap",
            "baseName": "columnsAsMap",
            "type": "{ [key: string]: Column; }"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesInput.attributeTypeMap;
    }
}

export class DataTablesOutput {
    'draw'?: number;
    'recordsTotal'?: number;
    'recordsFiltered'?: number;
    'data'?: Array<any>;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "recordsTotal",
            "baseName": "recordsTotal",
            "type": "number"
        },
        {
            "name": "recordsFiltered",
            "baseName": "recordsFiltered",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<any>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesOutput.attributeTypeMap;
    }
}

export class DataTablesOutputAccountDto {
    'draw'?: number;
    'recordsTotal'?: number;
    'recordsFiltered'?: number;
    'data'?: Array<AccountDto>;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "recordsTotal",
            "baseName": "recordsTotal",
            "type": "number"
        },
        {
            "name": "recordsFiltered",
            "baseName": "recordsFiltered",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<AccountDto>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesOutputAccountDto.attributeTypeMap;
    }
}

export class DataTablesOutputMerchantDto {
    'draw'?: number;
    'recordsTotal'?: number;
    'recordsFiltered'?: number;
    'data'?: Array<MerchantDto>;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "recordsTotal",
            "baseName": "recordsTotal",
            "type": "number"
        },
        {
            "name": "recordsFiltered",
            "baseName": "recordsFiltered",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<MerchantDto>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesOutputMerchantDto.attributeTypeMap;
    }
}

export class DataTablesOutputOnboardingCampaignDto {
    'draw'?: number;
    'recordsTotal'?: number;
    'recordsFiltered'?: number;
    'data'?: Array<OnboardingCampaignDto>;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "recordsTotal",
            "baseName": "recordsTotal",
            "type": "number"
        },
        {
            "name": "recordsFiltered",
            "baseName": "recordsFiltered",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<OnboardingCampaignDto>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesOutputOnboardingCampaignDto.attributeTypeMap;
    }
}

export class DataTablesOutputReportingViewDto {
    'draw'?: number;
    'recordsTotal'?: number;
    'recordsFiltered'?: number;
    'data'?: Array<ReportingViewDto>;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "recordsTotal",
            "baseName": "recordsTotal",
            "type": "number"
        },
        {
            "name": "recordsFiltered",
            "baseName": "recordsFiltered",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<ReportingViewDto>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesOutputReportingViewDto.attributeTypeMap;
    }
}

export class Document {
    'id'?: string;
    'type'?: Document.TypeEnum;
    'filename'?: string;
    'contentType'?: string;
    'contentLength'?: number;
    'preSignedUrl'?: string;
    'preSignedUrlExpiredAt'?: number;
    'originalDocumentId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "Document.TypeEnum"
        },
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "contentType",
            "baseName": "contentType",
            "type": "string"
        },
        {
            "name": "contentLength",
            "baseName": "contentLength",
            "type": "number"
        },
        {
            "name": "preSignedUrl",
            "baseName": "preSignedUrl",
            "type": "string"
        },
        {
            "name": "preSignedUrlExpiredAt",
            "baseName": "preSignedUrlExpiredAt",
            "type": "number"
        },
        {
            "name": "originalDocumentId",
            "baseName": "originalDocumentId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Document.attributeTypeMap;
    }
}

export namespace Document {
    export enum TypeEnum {
        IMAGE = <any> 'IMAGE',
        TICKET = <any> 'TICKET',
        TICKETTEMPLATE = <any> 'TICKET_TEMPLATE',
        ATTACHMENT = <any> 'ATTACHMENT'
    }
}
export class ErrorResponse {
    'errorCode'?: string;
    'errorDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errorCode",
            "baseName": "error_code",
            "type": "string"
        },
        {
            "name": "errorDescription",
            "baseName": "error_description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ErrorResponse.attributeTypeMap;
    }
}

export class ItemsPageResponse {
    'start'?: number;
    'rows'?: number;
    'total'?: number;
    'items'?: Array<BaseDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<BaseDto>"
        }    ];

    static getAttributeTypeMap() {
        return ItemsPageResponse.attributeTypeMap;
    }
}

export class ItemsPageResponseAccountDto {
    'start'?: number;
    'rows'?: number;
    'total'?: number;
    'items'?: Array<AccountDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<AccountDto>"
        }    ];

    static getAttributeTypeMap() {
        return ItemsPageResponseAccountDto.attributeTypeMap;
    }
}

export class ItemsPageResponseMerchantDto {
    'start'?: number;
    'rows'?: number;
    'total'?: number;
    'items'?: Array<MerchantDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<MerchantDto>"
        }    ];

    static getAttributeTypeMap() {
        return ItemsPageResponseMerchantDto.attributeTypeMap;
    }
}

export class ItemsPageResponseOnboardingCampaignDto {
    'start'?: number;
    'rows'?: number;
    'total'?: number;
    'items'?: Array<OnboardingCampaignDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<OnboardingCampaignDto>"
        }    ];

    static getAttributeTypeMap() {
        return ItemsPageResponseOnboardingCampaignDto.attributeTypeMap;
    }
}

export class ItemsPageResponseReportingViewDto {
    'start'?: number;
    'rows'?: number;
    'total'?: number;
    'items'?: Array<ReportingViewDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<ReportingViewDto>"
        }    ];

    static getAttributeTypeMap() {
        return ItemsPageResponseReportingViewDto.attributeTypeMap;
    }
}

export class ItemsPageResponseSingleSignOnClientDto {
    'start'?: number;
    'rows'?: number;
    'total'?: number;
    'items'?: Array<SingleSignOnClientDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<SingleSignOnClientDto>"
        }    ];

    static getAttributeTypeMap() {
        return ItemsPageResponseSingleSignOnClientDto.attributeTypeMap;
    }
}

export class LocaleInfoDto {
    'iso3166CountryCode'?: string;
    'currencyCode'?: string;
    'currencySymbol'?: string;
    'currencyFractionDigits'?: number;
    'timezone'?: string;
    'city'?: string;
    'state'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "iso3166CountryCode",
            "baseName": "iso3166CountryCode",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currencyCode",
            "type": "string"
        },
        {
            "name": "currencySymbol",
            "baseName": "currencySymbol",
            "type": "string"
        },
        {
            "name": "currencyFractionDigits",
            "baseName": "currencyFractionDigits",
            "type": "number"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocaleInfoDto.attributeTypeMap;
    }
}

export class LocationDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'postalAddress'?: string;
    'postalCode'?: string;
    'city'?: string;
    'state'?: string;
    'iso3166CountryCode'?: string;
    'latitude'?: number;
    'longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "postalAddress",
            "baseName": "postalAddress",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "iso3166CountryCode",
            "baseName": "iso3166CountryCode",
            "type": "string"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LocationDto.attributeTypeMap;
    }
}

export class MailDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: MailDto.TypeEnum;
    'templateId'?: string;
    'subject'?: string;
    'recipients'?: Array<MailRecipientDto>;
    'attachments'?: Array<Document>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "MailDto.TypeEnum"
        },
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "Array<MailRecipientDto>"
        },
        {
            "name": "attachments",
            "baseName": "attachments",
            "type": "Array<Document>"
        }    ];

    static getAttributeTypeMap() {
        return MailDto.attributeTypeMap;
    }
}

export namespace MailDto {
    export enum TypeEnum {
        ACCOUNTREGISTRATION = <any> 'ACCOUNT_REGISTRATION',
        PASSWORDRESET = <any> 'PASSWORD_RESET',
        ORDERCONFIRMATION = <any> 'ORDER_CONFIRMATION',
        DELIVERYCONFIRMATION = <any> 'DELIVERY_CONFIRMATION',
        APPEXTENSION = <any> 'APP_EXTENSION',
        NOTIFICATION = <any> 'NOTIFICATION',
        ALERT = <any> 'ALERT',
        REACTIVATION = <any> 'REACTIVATION',
        OTHERS = <any> 'OTHERS'
    }
}
export class MailRecipientDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'emailAddress'?: string;
    'recipientAccount'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'messageId'?: string;
    'mergeVariables'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "recipientAccount",
            "baseName": "recipientAccount",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        },
        {
            "name": "mergeVariables",
            "baseName": "mergeVariables",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MailRecipientDto.attributeTypeMap;
    }
}

export class Merchant {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'owner'?: string;
    'name'?: string;
    'contactInfoName'?: string;
    'contactInfoEmail'?: string;
    'contactInfoOffice'?: string;
    'contactInfoPhone'?: string;
    'contactInfoFax'?: string;
    'facebookPixelId'?: string;
    'googleAnalyticsPixelId'?: string;
    'reportingViews'?: Array<MerchantReportingView>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "contactInfoName",
            "baseName": "contactInfoName",
            "type": "string"
        },
        {
            "name": "contactInfoEmail",
            "baseName": "contactInfoEmail",
            "type": "string"
        },
        {
            "name": "contactInfoOffice",
            "baseName": "contactInfoOffice",
            "type": "string"
        },
        {
            "name": "contactInfoPhone",
            "baseName": "contactInfoPhone",
            "type": "string"
        },
        {
            "name": "contactInfoFax",
            "baseName": "contactInfoFax",
            "type": "string"
        },
        {
            "name": "facebookPixelId",
            "baseName": "facebookPixelId",
            "type": "string"
        },
        {
            "name": "googleAnalyticsPixelId",
            "baseName": "googleAnalyticsPixelId",
            "type": "string"
        },
        {
            "name": "reportingViews",
            "baseName": "reportingViews",
            "type": "Array<MerchantReportingView>"
        }    ];

    static getAttributeTypeMap() {
        return Merchant.attributeTypeMap;
    }
}

export class MerchantDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'image'?: string;
    'contactInfoName'?: string;
    'contactInfoEmail'?: string;
    'contactInfoOffice'?: string;
    'contactInfoPhone'?: string;
    'contactInfoFax'?: string;
    'facebookPixelId'?: string;
    'googleAnalyticsPixelId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "contactInfoName",
            "baseName": "contactInfoName",
            "type": "string"
        },
        {
            "name": "contactInfoEmail",
            "baseName": "contactInfoEmail",
            "type": "string"
        },
        {
            "name": "contactInfoOffice",
            "baseName": "contactInfoOffice",
            "type": "string"
        },
        {
            "name": "contactInfoPhone",
            "baseName": "contactInfoPhone",
            "type": "string"
        },
        {
            "name": "contactInfoFax",
            "baseName": "contactInfoFax",
            "type": "string"
        },
        {
            "name": "facebookPixelId",
            "baseName": "facebookPixelId",
            "type": "string"
        },
        {
            "name": "googleAnalyticsPixelId",
            "baseName": "googleAnalyticsPixelId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MerchantDto.attributeTypeMap;
    }
}

export class MerchantReportingView {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'merchant'?: Merchant;
    'reportingView'?: ReportingView;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "merchant",
            "baseName": "merchant",
            "type": "Merchant"
        },
        {
            "name": "reportingView",
            "baseName": "reportingView",
            "type": "ReportingView"
        }    ];

    static getAttributeTypeMap() {
        return MerchantReportingView.attributeTypeMap;
    }
}

export class OnboardingCampaignDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'type'?: OnboardingCampaignDto.TypeEnum;
    'image'?: Document;
    'url'?: string;
    'defaultHeader'?: string;
    'topMessage'?: string;
    'ctaButtonMessage'?: string;
    'bottomMessage'?: string;
    'targetCategory'?: string;
    'signUpBonusValue'?: number;
    'signUpBonusCurrency'?: string;
    'publishedAt'?: Date;
    'published'?: boolean;
    'sources'?: Array<OnboardingCampaignSourceDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "OnboardingCampaignDto.TypeEnum"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Document"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "defaultHeader",
            "baseName": "defaultHeader",
            "type": "string"
        },
        {
            "name": "topMessage",
            "baseName": "topMessage",
            "type": "string"
        },
        {
            "name": "ctaButtonMessage",
            "baseName": "ctaButtonMessage",
            "type": "string"
        },
        {
            "name": "bottomMessage",
            "baseName": "bottomMessage",
            "type": "string"
        },
        {
            "name": "targetCategory",
            "baseName": "targetCategory",
            "type": "string"
        },
        {
            "name": "signUpBonusValue",
            "baseName": "signUpBonusValue",
            "type": "number"
        },
        {
            "name": "signUpBonusCurrency",
            "baseName": "signUpBonusCurrency",
            "type": "string"
        },
        {
            "name": "publishedAt",
            "baseName": "publishedAt",
            "type": "Date"
        },
        {
            "name": "published",
            "baseName": "published",
            "type": "boolean"
        },
        {
            "name": "sources",
            "baseName": "sources",
            "type": "Array<OnboardingCampaignSourceDto>"
        }    ];

    static getAttributeTypeMap() {
        return OnboardingCampaignDto.attributeTypeMap;
    }
}

export namespace OnboardingCampaignDto {
    export enum TypeEnum {
        PARTNER = <any> 'PARTNER',
        CORPORATES = <any> 'CORPORATES'
    }
}
export class OnboardingCampaignSourceDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: OnboardingCampaignSourceDto.TypeEnum;
    'externalSourceId'?: string;
    'externalSourceName'?: string;
    'emailAddressField'?: string;
    'firstNameField'?: string;
    'lastNameField'?: string;
    'nameField'?: string;
    'lastRetrievedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "OnboardingCampaignSourceDto.TypeEnum"
        },
        {
            "name": "externalSourceId",
            "baseName": "externalSourceId",
            "type": "string"
        },
        {
            "name": "externalSourceName",
            "baseName": "externalSourceName",
            "type": "string"
        },
        {
            "name": "emailAddressField",
            "baseName": "emailAddressField",
            "type": "string"
        },
        {
            "name": "firstNameField",
            "baseName": "firstNameField",
            "type": "string"
        },
        {
            "name": "lastNameField",
            "baseName": "lastNameField",
            "type": "string"
        },
        {
            "name": "nameField",
            "baseName": "nameField",
            "type": "string"
        },
        {
            "name": "lastRetrievedAt",
            "baseName": "lastRetrievedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return OnboardingCampaignSourceDto.attributeTypeMap;
    }
}

export namespace OnboardingCampaignSourceDto {
    export enum TypeEnum {
        MAILCHIMP = <any> 'MAILCHIMP',
        TYPEFORM = <any> 'TYPEFORM'
    }
}
export class OnboardingCampaignUserDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'onboardingCampaignId'?: string;
    'user'?: AccountDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "onboardingCampaignId",
            "baseName": "onboardingCampaignId",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "AccountDto"
        }    ];

    static getAttributeTypeMap() {
        return OnboardingCampaignUserDto.attributeTypeMap;
    }
}

export class Order {
    'column': number;
    'dir': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "column",
            "baseName": "column",
            "type": "number"
        },
        {
            "name": "dir",
            "baseName": "dir",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Order.attributeTypeMap;
    }
}

export class PartnerMembership {
    'type'?: PartnerMembership.TypeEnum;
    'membershipId'?: string;
    'premium'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "PartnerMembership.TypeEnum"
        },
        {
            "name": "membershipId",
            "baseName": "membershipId",
            "type": "string"
        },
        {
            "name": "premium",
            "baseName": "premium",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PartnerMembership.attributeTypeMap;
    }
}

export namespace PartnerMembership {
    export enum TypeEnum {
        SPOTIFY = <any> 'SPOTIFY',
        CORPORATES = <any> 'CORPORATES'
    }
}
export class PaymentSourceDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: PaymentSourceDto.TypeEnum;
    'customerReference'?: string;
    'paymentSourceReference'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "PaymentSourceDto.TypeEnum"
        },
        {
            "name": "customerReference",
            "baseName": "customerReference",
            "type": "string"
        },
        {
            "name": "paymentSourceReference",
            "baseName": "paymentSourceReference",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentSourceDto.attributeTypeMap;
    }
}

export namespace PaymentSourceDto {
    export enum TypeEnum {
        CARD = <any> 'CARD'
    }
}
export class PricingCardIssuerDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'cardIssuerId'?: string;
    'cardIssuerName'?: string;
    'value'?: number;
    'currency'?: string;
    'percent'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "cardIssuerId",
            "baseName": "cardIssuerId",
            "type": "string"
        },
        {
            "name": "cardIssuerName",
            "baseName": "cardIssuerName",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "percent",
            "baseName": "percent",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PricingCardIssuerDto.attributeTypeMap;
    }
}

export class PricingCategoryDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PricingCategoryDto.attributeTypeMap;
    }
}

export class PricingDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'pricingCategory'?: PricingCategoryDto;
    'entitlements'?: string;
    'ticketsIssuedPerInventory'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "pricingCategory",
            "baseName": "pricingCategory",
            "type": "PricingCategoryDto"
        },
        {
            "name": "entitlements",
            "baseName": "entitlements",
            "type": "string"
        },
        {
            "name": "ticketsIssuedPerInventory",
            "baseName": "ticketsIssuedPerInventory",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PricingDto.attributeTypeMap;
    }
}

export class PricingIntervalDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'currency'?: string;
    'price'?: number;
    'costPrice'?: number;
    'bookingFee'?: number;
    'bookingFeeInPercent'?: boolean;
    'transactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "costPrice",
            "baseName": "costPrice",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "bookingFeeInPercent",
            "baseName": "bookingFeeInPercent",
            "type": "boolean"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PricingIntervalDto.attributeTypeMap;
    }
}

export class PromoCodeDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: PromoCodeDto.TypeEnum;
    'description'?: string;
    'code'?: string;
    'value'?: number;
    'minimumSpend'?: number;
    'minimumQuantity'?: number;
    'currency'?: string;
    'percent'?: boolean;
    'perQuantity'?: boolean;
    'maxQuantityRedemption'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "PromoCodeDto.TypeEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "minimumSpend",
            "baseName": "minimumSpend",
            "type": "number"
        },
        {
            "name": "minimumQuantity",
            "baseName": "minimumQuantity",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "percent",
            "baseName": "percent",
            "type": "boolean"
        },
        {
            "name": "perQuantity",
            "baseName": "perQuantity",
            "type": "boolean"
        },
        {
            "name": "maxQuantityRedemption",
            "baseName": "maxQuantityRedemption",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PromoCodeDto.attributeTypeMap;
    }
}

export namespace PromoCodeDto {
    export enum TypeEnum {
        PARTNERCODE = <any> 'PARTNER_CODE',
        EMAILADDRESSDOMAINPARTNERPROMOTION = <any> 'EMAIL_ADDRESS_DOMAIN_PARTNER_PROMOTION',
        SPOTIFYPARTNERPROMOTION = <any> 'SPOTIFY_PARTNER_PROMOTION',
        MARKETINGCAMPAIGNPARTNERPROMOTION = <any> 'MARKETING_CAMPAIGN_PARTNER_PROMOTION',
        CORPORATESPARTNERPROMOTION = <any> 'CORPORATES_PARTNER_PROMOTION',
        ONEUSECODE = <any> 'ONE_USE_CODE'
    }
}
export class Recipient {
    'emailAddress'?: string;
    'recipientAccount'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'messageId'?: string;
    'mergeVariables'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "recipientAccount",
            "baseName": "recipientAccount",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        },
        {
            "name": "mergeVariables",
            "baseName": "mergeVariables",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Recipient.attributeTypeMap;
    }
}

export class RecipientDto {
    'emailAddress'?: string;
    'recipientAccount'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'messageId'?: string;
    'mergeVariables'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "recipientAccount",
            "baseName": "recipientAccount",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        },
        {
            "name": "mergeVariables",
            "baseName": "mergeVariables",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RecipientDto.attributeTypeMap;
    }
}

export class ReferralDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'emailAddress'?: string;
    'completed'?: boolean;
    'completedAt'?: Date;
    'accountCreatedAt'?: Date;
    'referralCreatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "completed",
            "baseName": "completed",
            "type": "boolean"
        },
        {
            "name": "completedAt",
            "baseName": "completedAt",
            "type": "Date"
        },
        {
            "name": "accountCreatedAt",
            "baseName": "accountCreatedAt",
            "type": "Date"
        },
        {
            "name": "referralCreatedAt",
            "baseName": "referralCreatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ReferralDto.attributeTypeMap;
    }
}

export class ReportingView {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'owner'?: string;
    'name'?: string;
    'campaigns'?: Array<ReportingViewCampaign>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "campaigns",
            "baseName": "campaigns",
            "type": "Array<ReportingViewCampaign>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingView.attributeTypeMap;
    }
}

export class ReportingViewCampaign {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'reportingView'?: ReportingView;
    'campaign'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "reportingView",
            "baseName": "reportingView",
            "type": "ReportingView"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingViewCampaign.attributeTypeMap;
    }
}

export class ReportingViewDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'campaigns'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "campaigns",
            "baseName": "campaigns",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingViewDto.attributeTypeMap;
    }
}

export class RoleDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: RoleDto.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "RoleDto.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return RoleDto.attributeTypeMap;
    }
}

export namespace RoleDto {
    export enum TypeEnum {
        USER = <any> 'USER',
        MERCHANT = <any> 'MERCHANT',
        ACCOUNTMANAGER = <any> 'ACCOUNT_MANAGER',
        ADMINISTRATOR = <any> 'ADMINISTRATOR',
        DATAANALYST = <any> 'DATA_ANALYST',
        CUSTOMERSERVICEOFFICER = <any> 'CUSTOMER_SERVICE_OFFICER',
        MARKETINGEXECUTIVE = <any> 'MARKETING_EXECUTIVE',
        POSTERMINAL = <any> 'POS_TERMINAL'
    }
}
export class Search {
    'value': string;
    'regex': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "regex",
            "baseName": "regex",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Search.attributeTypeMap;
    }
}

export class SendEmailRequest {
    'type'?: SendEmailRequest.TypeEnum;
    'templateId'?: string;
    'subject'?: string;
    'account'?: string;
    'recipients'?: Array<Recipient>;
    'attachments'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "SendEmailRequest.TypeEnum"
        },
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "account",
            "baseName": "account",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "Array<Recipient>"
        },
        {
            "name": "attachments",
            "baseName": "attachments",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SendEmailRequest.attributeTypeMap;
    }
}

export namespace SendEmailRequest {
    export enum TypeEnum {
        ACCOUNTREGISTRATION = <any> 'ACCOUNT_REGISTRATION',
        PASSWORDRESET = <any> 'PASSWORD_RESET',
        ORDERCONFIRMATION = <any> 'ORDER_CONFIRMATION',
        DELIVERYCONFIRMATION = <any> 'DELIVERY_CONFIRMATION',
        APPEXTENSION = <any> 'APP_EXTENSION',
        NOTIFICATION = <any> 'NOTIFICATION',
        ALERT = <any> 'ALERT',
        REACTIVATION = <any> 'REACTIVATION',
        OTHERS = <any> 'OTHERS'
    }
}
export class SingleSignOnClientDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'clientId'?: string;
    'clientSecret'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "clientSecret",
            "baseName": "clientSecret",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SingleSignOnClientDto.attributeTypeMap;
    }
}

export class ThirdPartyLoginDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'loginId'?: string;
    'thirdParty'?: ThirdPartyLoginDto.ThirdPartyEnum;
    'thirdPartySingleSignOnClient'?: string;
    'thirdPartyUserId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "loginId",
            "baseName": "loginId",
            "type": "string"
        },
        {
            "name": "thirdParty",
            "baseName": "thirdParty",
            "type": "ThirdPartyLoginDto.ThirdPartyEnum"
        },
        {
            "name": "thirdPartySingleSignOnClient",
            "baseName": "thirdPartySingleSignOnClient",
            "type": "string"
        },
        {
            "name": "thirdPartyUserId",
            "baseName": "thirdPartyUserId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ThirdPartyLoginDto.attributeTypeMap;
    }
}

export namespace ThirdPartyLoginDto {
    export enum ThirdPartyEnum {
        FACEBOOK = <any> 'FACEBOOK',
        SPOTIFY = <any> 'SPOTIFY',
        GOOGLE = <any> 'GOOGLE',
        HAPZSINGLESIGNON = <any> 'HAPZ_SINGLE_SIGN_ON'
    }
}
export class TransactionCreditsLedgerDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'creditsLedger'?: string;
    'exchangeRateFromCreditsLedgerToTransaction'?: number;
    'value'?: number;
    'valueInSGD'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "creditsLedger",
            "baseName": "creditsLedger",
            "type": "string"
        },
        {
            "name": "exchangeRateFromCreditsLedgerToTransaction",
            "baseName": "exchangeRateFromCreditsLedgerToTransaction",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionCreditsLedgerDto.attributeTypeMap;
    }
}

export class TransactionDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'currency'?: string;
    'exchangeRateFromTransactionToSGD'?: number;
    'cart'?: boolean;
    'status'?: TransactionDto.StatusEnum;
    'firstName'?: string;
    'lastName'?: string;
    'emailAddress'?: string;
    'contactNo'?: string;
    'userTrafficChannel'?: TransactionDto.UserTrafficChannelEnum;
    'marketingOrDistributionTransaction'?: boolean;
    'utmCampaign'?: string;
    'utmSource'?: string;
    'utmMedium'?: string;
    'utmContent'?: string;
    'utmTerm'?: string;
    'referrerUrl'?: string;
    'expiresAt'?: Date;
    'expired'?: boolean;
    'paymentCompletedAt'?: Date;
    'items'?: Array<TransactionItemDto>;
    'payments'?: Array<TransactionPaymentDto>;
    'promoCodes'?: Array<TransactionPromoCodeDto>;
    'creditsLedgers'?: Array<TransactionCreditsLedgerDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "exchangeRateFromTransactionToSGD",
            "baseName": "exchangeRateFromTransactionToSGD",
            "type": "number"
        },
        {
            "name": "cart",
            "baseName": "cart",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "TransactionDto.StatusEnum"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "contactNo",
            "baseName": "contactNo",
            "type": "string"
        },
        {
            "name": "userTrafficChannel",
            "baseName": "userTrafficChannel",
            "type": "TransactionDto.UserTrafficChannelEnum"
        },
        {
            "name": "marketingOrDistributionTransaction",
            "baseName": "marketingOrDistributionTransaction",
            "type": "boolean"
        },
        {
            "name": "utmCampaign",
            "baseName": "utmCampaign",
            "type": "string"
        },
        {
            "name": "utmSource",
            "baseName": "utmSource",
            "type": "string"
        },
        {
            "name": "utmMedium",
            "baseName": "utmMedium",
            "type": "string"
        },
        {
            "name": "utmContent",
            "baseName": "utmContent",
            "type": "string"
        },
        {
            "name": "utmTerm",
            "baseName": "utmTerm",
            "type": "string"
        },
        {
            "name": "referrerUrl",
            "baseName": "referrerUrl",
            "type": "string"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "expired",
            "baseName": "expired",
            "type": "boolean"
        },
        {
            "name": "paymentCompletedAt",
            "baseName": "paymentCompletedAt",
            "type": "Date"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<TransactionItemDto>"
        },
        {
            "name": "payments",
            "baseName": "payments",
            "type": "Array<TransactionPaymentDto>"
        },
        {
            "name": "promoCodes",
            "baseName": "promoCodes",
            "type": "Array<TransactionPromoCodeDto>"
        },
        {
            "name": "creditsLedgers",
            "baseName": "creditsLedgers",
            "type": "Array<TransactionCreditsLedgerDto>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionDto.attributeTypeMap;
    }
}

export namespace TransactionDto {
    export enum StatusEnum {
        PAYMENTPENDING = <any> 'PAYMENT_PENDING',
        MANUALREVIEWPENDING = <any> 'MANUAL_REVIEW_PENDING',
        APPROVED = <any> 'APPROVED',
        DECLINED = <any> 'DECLINED'
    }
    export enum UserTrafficChannelEnum {
        DIRECT = <any> 'DIRECT',
        ORGANICSEARCH = <any> 'ORGANIC_SEARCH',
        PAIDSEARCH = <any> 'PAID_SEARCH',
        EMAIL = <any> 'EMAIL',
        SOCIAL = <any> 'SOCIAL',
        REFERRAL = <any> 'REFERRAL',
        OTHERS = <any> 'OTHERS'
    }
}
export class TransactionItemDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'status'?: TransactionItemDto.StatusEnum;
    'campaign'?: CampaignDto;
    'campaignTimeslot'?: CampaignTimeslotDto;
    'pricing'?: PricingDto;
    'pricingInterval'?: PricingIntervalDto;
    'pricingCardIssuer'?: PricingCardIssuerDto;
    'pricingInventoryLedger'?: string;
    'price'?: number;
    'quantity'?: number;
    'exchangeRateFromPricingToTransaction'?: number;
    'bookingFee'?: number;
    'transactionFee'?: number;
    'pricingCardIssuerValue'?: number;
    'pricingCardIssuerValueInSGD'?: number;
    'pricingCardIssuerValueCreditedToHapz'?: boolean;
    'priceDifferenceValue'?: number;
    'priceDifferenceValueInSGD'?: number;
    'priceDifferenceValueCreditedToHapz'?: boolean;
    'forexGainOrLossValueInSGD'?: number;
    'invalidatedAt'?: Date;
    'invalidatedBy'?: string;
    'registrants'?: Array<TransactionItemRegistrantDto>;
    'eligibleRefundAmount'?: number;
    'chargeableAmount'?: number;
    'refundedAmount'?: number;
    'creditsAmount'?: number;
    'promoCodeAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "TransactionItemDto.StatusEnum"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "CampaignDto"
        },
        {
            "name": "campaignTimeslot",
            "baseName": "campaignTimeslot",
            "type": "CampaignTimeslotDto"
        },
        {
            "name": "pricing",
            "baseName": "pricing",
            "type": "PricingDto"
        },
        {
            "name": "pricingInterval",
            "baseName": "pricingInterval",
            "type": "PricingIntervalDto"
        },
        {
            "name": "pricingCardIssuer",
            "baseName": "pricingCardIssuer",
            "type": "PricingCardIssuerDto"
        },
        {
            "name": "pricingInventoryLedger",
            "baseName": "pricingInventoryLedger",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "exchangeRateFromPricingToTransaction",
            "baseName": "exchangeRateFromPricingToTransaction",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        },
        {
            "name": "pricingCardIssuerValue",
            "baseName": "pricingCardIssuerValue",
            "type": "number"
        },
        {
            "name": "pricingCardIssuerValueInSGD",
            "baseName": "pricingCardIssuerValueInSGD",
            "type": "number"
        },
        {
            "name": "pricingCardIssuerValueCreditedToHapz",
            "baseName": "pricingCardIssuerValueCreditedToHapz",
            "type": "boolean"
        },
        {
            "name": "priceDifferenceValue",
            "baseName": "priceDifferenceValue",
            "type": "number"
        },
        {
            "name": "priceDifferenceValueInSGD",
            "baseName": "priceDifferenceValueInSGD",
            "type": "number"
        },
        {
            "name": "priceDifferenceValueCreditedToHapz",
            "baseName": "priceDifferenceValueCreditedToHapz",
            "type": "boolean"
        },
        {
            "name": "forexGainOrLossValueInSGD",
            "baseName": "forexGainOrLossValueInSGD",
            "type": "number"
        },
        {
            "name": "invalidatedAt",
            "baseName": "invalidatedAt",
            "type": "Date"
        },
        {
            "name": "invalidatedBy",
            "baseName": "invalidatedBy",
            "type": "string"
        },
        {
            "name": "registrants",
            "baseName": "registrants",
            "type": "Array<TransactionItemRegistrantDto>"
        },
        {
            "name": "eligibleRefundAmount",
            "baseName": "eligibleRefundAmount",
            "type": "number"
        },
        {
            "name": "chargeableAmount",
            "baseName": "chargeableAmount",
            "type": "number"
        },
        {
            "name": "refundedAmount",
            "baseName": "refundedAmount",
            "type": "number"
        },
        {
            "name": "creditsAmount",
            "baseName": "creditsAmount",
            "type": "number"
        },
        {
            "name": "promoCodeAmount",
            "baseName": "promoCodeAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemDto.attributeTypeMap;
    }
}

export namespace TransactionItemDto {
    export enum StatusEnum {
        ADDEDTOTRANSACTION = <any> 'ADDED_TO_TRANSACTION',
        FULFILMENTPENDING = <any> 'FULFILMENT_PENDING',
        FULFILMENTCOMPLETED = <any> 'FULFILMENT_COMPLETED'
    }
}
export class TransactionItemRegistrantDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'registrationFieldValues'?: { [key: string]: any; };
    'singleRegistration'?: boolean;
    'multiRegistration'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "registrationFieldValues",
            "baseName": "registrationFieldValues",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "singleRegistration",
            "baseName": "singleRegistration",
            "type": "boolean"
        },
        {
            "name": "multiRegistration",
            "baseName": "multiRegistration",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemRegistrantDto.attributeTypeMap;
    }
}

export class TransactionPaymentDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: TransactionPaymentDto.TypeEnum;
    'status'?: TransactionPaymentDto.StatusEnum;
    'value'?: number;
    'valueInSGD'?: number;
    'feeInSGD'?: number;
    'currency'?: string;
    'ipAddress'?: string;
    'userAgent'?: string;
    'requestOriginIso3166CountryCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "TransactionPaymentDto.TypeEnum"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "TransactionPaymentDto.StatusEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        },
        {
            "name": "feeInSGD",
            "baseName": "feeInSGD",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "userAgent",
            "baseName": "userAgent",
            "type": "string"
        },
        {
            "name": "requestOriginIso3166CountryCode",
            "baseName": "requestOriginIso3166CountryCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TransactionPaymentDto.attributeTypeMap;
    }
}

export namespace TransactionPaymentDto {
    export enum TypeEnum {
        ONSITE = <any> 'ONSITE',
        PAYMENTPROCESSOR = <any> 'PAYMENT_PROCESSOR',
        CARDPAYMENTPROCESSOR = <any> 'CARD_PAYMENT_PROCESSOR'
    }
    export enum StatusEnum {
        RECEIVED = <any> 'RECEIVED',
        ERROR = <any> 'ERROR',
        DECLINED = <any> 'DECLINED',
        AUTHORISATIONPENDING = <any> 'AUTHORISATION_PENDING',
        AUTHORISED = <any> 'AUTHORISED',
        SETTLEMENTPENDING = <any> 'SETTLEMENT_PENDING',
        SETTLED = <any> 'SETTLED',
        REFUNDPENDING = <any> 'REFUND_PENDING',
        REFUNDED = <any> 'REFUNDED',
        CHARGEBACK = <any> 'CHARGEBACK'
    }
}
export class TransactionPromoCodeDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'promoCode'?: PromoCodeDto;
    'exchangeRateFromPromoCodeToTransaction'?: number;
    'value'?: number;
    'valueInSGD'?: number;
    'creditedToHapz'?: boolean;
    'expiresAt'?: Date;
    'redeemedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "promoCode",
            "baseName": "promoCode",
            "type": "PromoCodeDto"
        },
        {
            "name": "exchangeRateFromPromoCodeToTransaction",
            "baseName": "exchangeRateFromPromoCodeToTransaction",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        },
        {
            "name": "creditedToHapz",
            "baseName": "creditedToHapz",
            "type": "boolean"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "redeemedAt",
            "baseName": "redeemedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return TransactionPromoCodeDto.attributeTypeMap;
    }
}

export class UserRolePartnerMembershipDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: UserRolePartnerMembershipDto.TypeEnum;
    'membershipId'?: string;
    'premium'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "UserRolePartnerMembershipDto.TypeEnum"
        },
        {
            "name": "membershipId",
            "baseName": "membershipId",
            "type": "string"
        },
        {
            "name": "premium",
            "baseName": "premium",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UserRolePartnerMembershipDto.attributeTypeMap;
    }
}

export namespace UserRolePartnerMembershipDto {
    export enum TypeEnum {
        SPOTIFY = <any> 'SPOTIFY',
        CORPORATES = <any> 'CORPORATES'
    }
}

let enumsMap: {[index: string]: any} = {
        "AccessControlDto.AccessControlEnum": AccessControlDto.AccessControlEnum,
        "AccountBySession.RolesEnum": AccountBySession.RolesEnum,
        "AccountBySession.AccessControlsEnum": AccountBySession.AccessControlsEnum,
        "ApiKey.TypeEnum": ApiKey.TypeEnum,
        "CardDto.TypeEnum": CardDto.TypeEnum,
        "CardDto.Card3DSecureEnum": CardDto.Card3DSecureEnum,
        "Document.TypeEnum": Document.TypeEnum,
        "MailDto.TypeEnum": MailDto.TypeEnum,
        "OnboardingCampaignDto.TypeEnum": OnboardingCampaignDto.TypeEnum,
        "OnboardingCampaignSourceDto.TypeEnum": OnboardingCampaignSourceDto.TypeEnum,
        "PartnerMembership.TypeEnum": PartnerMembership.TypeEnum,
        "PaymentSourceDto.TypeEnum": PaymentSourceDto.TypeEnum,
        "PromoCodeDto.TypeEnum": PromoCodeDto.TypeEnum,
        "RoleDto.TypeEnum": RoleDto.TypeEnum,
        "SendEmailRequest.TypeEnum": SendEmailRequest.TypeEnum,
        "ThirdPartyLoginDto.ThirdPartyEnum": ThirdPartyLoginDto.ThirdPartyEnum,
        "TransactionDto.StatusEnum": TransactionDto.StatusEnum,
        "TransactionDto.UserTrafficChannelEnum": TransactionDto.UserTrafficChannelEnum,
        "TransactionItemDto.StatusEnum": TransactionItemDto.StatusEnum,
        "TransactionPaymentDto.TypeEnum": TransactionPaymentDto.TypeEnum,
        "TransactionPaymentDto.StatusEnum": TransactionPaymentDto.StatusEnum,
        "UserRolePartnerMembershipDto.TypeEnum": UserRolePartnerMembershipDto.TypeEnum,
}

let typeMap: {[index: string]: any} = {
    "AccessControlDto": AccessControlDto,
    "AccountBySession": AccountBySession,
    "AccountCreditsLedgerDto": AccountCreditsLedgerDto,
    "AccountDto": AccountDto,
    "AccountSessionDto": AccountSessionDto,
    "ApiKey": ApiKey,
    "ApiKeyDto": ApiKeyDto,
    "BaseDto": BaseDto,
    "CampaignDto": CampaignDto,
    "CampaignMerchantDto": CampaignMerchantDto,
    "CampaignTimeslotDto": CampaignTimeslotDto,
    "CardDto": CardDto,
    "Column": Column,
    "DataTablesInput": DataTablesInput,
    "DataTablesOutput": DataTablesOutput,
    "DataTablesOutputAccountDto": DataTablesOutputAccountDto,
    "DataTablesOutputMerchantDto": DataTablesOutputMerchantDto,
    "DataTablesOutputOnboardingCampaignDto": DataTablesOutputOnboardingCampaignDto,
    "DataTablesOutputReportingViewDto": DataTablesOutputReportingViewDto,
    "Document": Document,
    "ErrorResponse": ErrorResponse,
    "ItemsPageResponse": ItemsPageResponse,
    "ItemsPageResponseAccountDto": ItemsPageResponseAccountDto,
    "ItemsPageResponseMerchantDto": ItemsPageResponseMerchantDto,
    "ItemsPageResponseOnboardingCampaignDto": ItemsPageResponseOnboardingCampaignDto,
    "ItemsPageResponseReportingViewDto": ItemsPageResponseReportingViewDto,
    "ItemsPageResponseSingleSignOnClientDto": ItemsPageResponseSingleSignOnClientDto,
    "LocaleInfoDto": LocaleInfoDto,
    "LocationDto": LocationDto,
    "MailDto": MailDto,
    "MailRecipientDto": MailRecipientDto,
    "Merchant": Merchant,
    "MerchantDto": MerchantDto,
    "MerchantReportingView": MerchantReportingView,
    "OnboardingCampaignDto": OnboardingCampaignDto,
    "OnboardingCampaignSourceDto": OnboardingCampaignSourceDto,
    "OnboardingCampaignUserDto": OnboardingCampaignUserDto,
    "Order": Order,
    "PartnerMembership": PartnerMembership,
    "PaymentSourceDto": PaymentSourceDto,
    "PricingCardIssuerDto": PricingCardIssuerDto,
    "PricingCategoryDto": PricingCategoryDto,
    "PricingDto": PricingDto,
    "PricingIntervalDto": PricingIntervalDto,
    "PromoCodeDto": PromoCodeDto,
    "Recipient": Recipient,
    "RecipientDto": RecipientDto,
    "ReferralDto": ReferralDto,
    "ReportingView": ReportingView,
    "ReportingViewCampaign": ReportingViewCampaign,
    "ReportingViewDto": ReportingViewDto,
    "RoleDto": RoleDto,
    "Search": Search,
    "SendEmailRequest": SendEmailRequest,
    "SingleSignOnClientDto": SingleSignOnClientDto,
    "ThirdPartyLoginDto": ThirdPartyLoginDto,
    "TransactionCreditsLedgerDto": TransactionCreditsLedgerDto,
    "TransactionDto": TransactionDto,
    "TransactionItemDto": TransactionItemDto,
    "TransactionItemRegistrantDto": TransactionItemRegistrantDto,
    "TransactionPaymentDto": TransactionPaymentDto,
    "TransactionPromoCodeDto": TransactionPromoCodeDto,
    "UserRolePartnerMembershipDto": UserRolePartnerMembershipDto,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum LoginApiApiKeys {
    JWT,
}

export class LoginApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LoginApiApiKeys, value: string) {
        (this.authentications as any)[LoginApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Login using username / password
     * @param loginId Login Id
     * @param loginType 1 &#x3D; Email / Password, 2 &#x3D; OpenID
     * @param secret value &#x3D; password when using email / password login, value &#x3D; access token when using third party login
     * @param idToken ID Token when using third party login
     * @param refreshToken Refresh Token when using third party login
     * @param thirdParty 1 &#x3D; Facebook, 2 &#x3D; Spotify, 3 &#x3D; Google, 4 &#x3D; Hapz Single Sign-On
     * @param {*} [options] Override http request options.
     */
    public login (loginId: string, loginType: 1 | 2, secret: string, idToken?: string, refreshToken?: string, thirdParty?: 1 | 2 | 3 | 4, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AccountSessionDto;  }> {
        const localVarPath = this.basePath + '/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginId' is not null or undefined
        if (loginId === null || loginId === undefined) {
            throw new Error('Required parameter loginId was null or undefined when calling login.');
        }

        // verify required parameter 'loginType' is not null or undefined
        if (loginType === null || loginType === undefined) {
            throw new Error('Required parameter loginType was null or undefined when calling login.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling login.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (loginId !== undefined) {
            localVarFormParams['loginId'] = ObjectSerializer.serialize(loginId, "string");
        }

        if (loginType !== undefined) {
            localVarFormParams['loginType'] = ObjectSerializer.serialize(loginType, "1 | 2");
        }

        if (secret !== undefined) {
            localVarFormParams['secret'] = ObjectSerializer.serialize(secret, "string");
        }

        if (idToken !== undefined) {
            localVarFormParams['idToken'] = ObjectSerializer.serialize(idToken, "string");
        }

        if (refreshToken !== undefined) {
            localVarFormParams['refreshToken'] = ObjectSerializer.serialize(refreshToken, "string");
        }

        if (thirdParty !== undefined) {
            localVarFormParams['thirdParty'] = ObjectSerializer.serialize(thirdParty, "1 | 2 | 3 | 4");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountSessionDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountSessionDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}

// export enum AccessesApiApiKeys {
//     JWT,
// }

// export class AccessesApi {
//     protected _basePath = defaultBasePath;
//     protected defaultHeaders : any = {};
//     protected _useQuerystring : boolean = false;

//     protected authentications = {
//         'default': <Authentication>new VoidAuth(),
//         'JWT': new ApiKeyAuth('header', 'Authorization'),
//     }

//     constructor(basePath?: string);
//     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
//         if (password) {
//             if (basePath) {
//                 this.basePath = basePath;
//             }
//         } else {
//             if (basePathOrUsername) {
//                 this.basePath = basePathOrUsername
//             }
//         }
//     }

//     set useQuerystring(value: boolean) {
//         this._useQuerystring = value;
//     }

//     set basePath(basePath: string) {
//         this._basePath = basePath;
//     }

//     get basePath() {
//         return this._basePath;
//     }

//     public setDefaultAuthentication(auth: Authentication) {
// 	this.authentications.default = auth;
//     }

//     public setApiKey(key: AccessesApiApiKeys, value: string) {
//         (this.authentications as any)[AccessesApiApiKeys[key]].apiKey = value;
//     }
//     /**
//      * 
//      * @summary Adds an access control to an existing account
//      * @param accountId Account ID
//      * @param accessControl 1 &#x3D; Users (Full Control), 2 &#x3D; Campaigns (Full Control)
//      * @param {*} [options] Override http request options.
//      */
//     public addAccessControl (accountId: string, accessControl: 1 | 2, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AccessControlDto;  }> {
//         const localVarPath = this.basePath + '/{accountId}/accesses'
//             .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
//         let localVarQueryParameters: any = {};
//         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
//         let localVarFormParams: any = {};

//         // verify required parameter 'accountId' is not null or undefined
//         if (accountId === null || accountId === undefined) {
//             throw new Error('Required parameter accountId was null or undefined when calling addAccessControl.');
//         }

//         // verify required parameter 'accessControl' is not null or undefined
//         if (accessControl === null || accessControl === undefined) {
//             throw new Error('Required parameter accessControl was null or undefined when calling addAccessControl.');
//         }

//         (<any>Object).assign(localVarHeaderParams, options.headers);

//         let localVarUseFormData = false;

//         if (accessControl !== undefined) {
//             localVarFormParams['accessControl'] = ObjectSerializer.serialize(accessControl, "1 | 2");
//         }

//         let localVarRequestOptions: localVarRequest.Options = {
//             method: 'POST',
//             qs: localVarQueryParameters,
//             headers: localVarHeaderParams,
//             uri: localVarPath,
//             useQuerystring: this._useQuerystring,
//             json: true,
//         };

//         this.authentications.default.applyToRequest(localVarRequestOptions);

//         if (Object.keys(localVarFormParams).length) {
//             if (localVarUseFormData) {
//                 (<any>localVarRequestOptions).formData = localVarFormParams;
//             } else {
//                 localVarRequestOptions.form = localVarFormParams;
//             }
//         }
//         return new Promise<{ response: http.IncomingMessage; body: AccessControlDto;  }>((resolve, reject) => {
//             localVarRequest(localVarRequestOptions, (error, response, body) => {
//                 if (error) {
//                     reject(error);
//                 } else {
//                     body = ObjectSerializer.deserialize(body, "AccessControlDto");
//                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
//                         resolve({ response: response, body: body });
//                     } else {
//                         reject({ response: response, body: body });
//                     }
//                 }
//             });
//         });
//     }
//     /**
//      * 
//      * @summary Deletes an access control from an existing account
//      * @param accountId Account ID
//      * @param accessControl Access Control ID
//      * @param {*} [options] Override http request options.
//      */
//     public deleteAccessControl (accountId: string, accessControl: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
//         const localVarPath = this.basePath + '/{accountId}/accesses/{accessControl}'
//             .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
//             .replace('{' + 'accessControl' + '}', encodeURIComponent(String(accessControl)));
//         let localVarQueryParameters: any = {};
//         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
//         let localVarFormParams: any = {};

//         // verify required parameter 'accountId' is not null or undefined
//         if (accountId === null || accountId === undefined) {
//             throw new Error('Required parameter accountId was null or undefined when calling deleteAccessControl.');
//         }

//         // verify required parameter 'accessControl' is not null or undefined
//         if (accessControl === null || accessControl === undefined) {
//             throw new Error('Required parameter accessControl was null or undefined when calling deleteAccessControl.');
//         }

//         (<any>Object).assign(localVarHeaderParams, options.headers);

//         let localVarUseFormData = false;

//         let localVarRequestOptions: localVarRequest.Options = {
//             method: 'DELETE',
//             qs: localVarQueryParameters,
//             headers: localVarHeaderParams,
//             uri: localVarPath,
//             useQuerystring: this._useQuerystring,
//             json: true,
//         };

//         this.authentications.default.applyToRequest(localVarRequestOptions);

//         if (Object.keys(localVarFormParams).length) {
//             if (localVarUseFormData) {
//                 (<any>localVarRequestOptions).formData = localVarFormParams;
//             } else {
//                 localVarRequestOptions.form = localVarFormParams;
//             }
//         }
//         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
//             localVarRequest(localVarRequestOptions, (error, response, body) => {
//                 if (error) {
//                     reject(error);
//                 } else {
//                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
//                         resolve({ response: response, body: body });
//                     } else {
//                         reject({ response: response, body: body });
//                     }
//                 }
//             });
//         });
//     }
//     /**
//      * 
//      * @summary Retrieves all access controls from a given account
//      * @param accountId Account ID
//      * @param {*} [options] Override http request options.
//      */
//     public getAccessControls (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<AccessControlDto>;  }> {
//         const localVarPath = this.basePath + '/{accountId}/accesses'
//             .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
//         let localVarQueryParameters: any = {};
//         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
//         let localVarFormParams: any = {};

//         // verify required parameter 'accountId' is not null or undefined
//         if (accountId === null || accountId === undefined) {
//             throw new Error('Required parameter accountId was null or undefined when calling getAccessControls.');
//         }

//         (<any>Object).assign(localVarHeaderParams, options.headers);

//         let localVarUseFormData = false;

//         let localVarRequestOptions: localVarRequest.Options = {
//             method: 'GET',
//             qs: localVarQueryParameters,
//             headers: localVarHeaderParams,
//             uri: localVarPath,
//             useQuerystring: this._useQuerystring,
//             json: true,
//         };

//         this.authentications.default.applyToRequest(localVarRequestOptions);

//         if (Object.keys(localVarFormParams).length) {
//             if (localVarUseFormData) {
//                 (<any>localVarRequestOptions).formData = localVarFormParams;
//             } else {
//                 localVarRequestOptions.form = localVarFormParams;
//             }
//         }
//         return new Promise<{ response: http.IncomingMessage; body: Array<AccessControlDto>;  }>((resolve, reject) => {
//             localVarRequest(localVarRequestOptions, (error, response, body) => {
//                 if (error) {
//                     reject(error);
//                 } else {
//                     body = ObjectSerializer.deserialize(body, "Array<AccessControlDto>");
//                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
//                         resolve({ response: response, body: body });
//                     } else {
//                         reject({ response: response, body: body });
//                     }
//                 }
//             });
//         });
//     }
// }
export enum AccountApiApiKeys {
    JWT,
}

export class AccountApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountApiApiKeys, value: string) {
        (this.authentications as any)[AccountApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve the details of an existing account
     * @param account Account ID
     * @param {*} [options] Override http request options.
     */
    public getAccount (account: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AccountDto;  }> {
        const localVarPath = this.basePath + '/{account}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An administrator may use this API to change the Merchant assigned to a Merchant Account.
     * @summary Updates the details of an existing account
     * @param account Account ID
     * @param loginId Login ID
     * @param emailAddress Email Address
     * @param firstName First Name
     * @param lastName Last Name
     * @param oldPassword Old Password
     * @param newPassword New Password
     * @param city City
     * @param state State
     * @param iso3166CountryCode Country Code (ISO 3166)
     * @param defaultCurrencyCode Default Currency Code
     * @param defaultTimezone Default Timezone
     * @param gender Gender (1 &#x3D; Male, 2 &#x3D; Female, for Users only)
     * @param birthday Birthday (yyyy-MM-dd) Eg: 2016-01-01
     * @param contactNo Contact Number (for Users only)
     * @param permissionSendMailer Permission to send emails to the user (1 &#x3D; Allow, 2 &#x3D; Disallow, for Users only)
     * @param preferredPaymentSource Preferred Payment Source (for Users only)
     * @param merchantId Merchant ID (for Merchants only)
     * @param {*} [options] Override http request options.
     */
    public updateAccount (account: string, loginId?: string, emailAddress?: string, firstName?: string, lastName?: string, oldPassword?: string, newPassword?: string, city?: string, state?: string, iso3166CountryCode?: string, defaultCurrencyCode?: string, defaultTimezone?: string, gender?: 0 | 1 | 2, birthday?: Date, contactNo?: string, permissionSendMailer?: 1 | 2, preferredPaymentSource?: string, merchantId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AccountDto;  }> {
        const localVarPath = this.basePath + '/{account}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling updateAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (loginId !== undefined) {
            localVarFormParams['loginId'] = ObjectSerializer.serialize(loginId, "string");
        }

        if (emailAddress !== undefined) {
            localVarFormParams['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }

        if (firstName !== undefined) {
            localVarFormParams['firstName'] = ObjectSerializer.serialize(firstName, "string");
        }

        if (lastName !== undefined) {
            localVarFormParams['lastName'] = ObjectSerializer.serialize(lastName, "string");
        }

        if (oldPassword !== undefined) {
            localVarFormParams['oldPassword'] = ObjectSerializer.serialize(oldPassword, "string");
        }

        if (newPassword !== undefined) {
            localVarFormParams['newPassword'] = ObjectSerializer.serialize(newPassword, "string");
        }

        if (city !== undefined) {
            localVarFormParams['city'] = ObjectSerializer.serialize(city, "string");
        }

        if (state !== undefined) {
            localVarFormParams['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (iso3166CountryCode !== undefined) {
            localVarFormParams['iso3166CountryCode'] = ObjectSerializer.serialize(iso3166CountryCode, "string");
        }

        if (defaultCurrencyCode !== undefined) {
            localVarFormParams['defaultCurrencyCode'] = ObjectSerializer.serialize(defaultCurrencyCode, "string");
        }

        if (defaultTimezone !== undefined) {
            localVarFormParams['defaultTimezone'] = ObjectSerializer.serialize(defaultTimezone, "string");
        }

        if (gender !== undefined) {
            localVarFormParams['gender'] = ObjectSerializer.serialize(gender, "0 | 1 | 2");
        }

        if (birthday !== undefined) {
            localVarFormParams['birthday'] = ObjectSerializer.serialize(birthday, "Date");
        }

        if (contactNo !== undefined) {
            localVarFormParams['contactNo'] = ObjectSerializer.serialize(contactNo, "string");
        }

        if (permissionSendMailer !== undefined) {
            localVarFormParams['permissionSendMailer'] = ObjectSerializer.serialize(permissionSendMailer, "1 | 2");
        }

        if (preferredPaymentSource !== undefined) {
            localVarFormParams['preferredPaymentSource'] = ObjectSerializer.serialize(preferredPaymentSource, "string");
        }

        if (merchantId !== undefined) {
            localVarFormParams['merchantId'] = ObjectSerializer.serialize(merchantId, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccountsApiApiKeys {
    JWT,
}

export class AccountsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountsApiApiKeys, value: string) {
        (this.authentications as any)[AccountsApiApiKeys[key]].apiKey = value;
    }
    /**
     * This endpoint requires authentication when creating a Merchant, Account Manager, Administrator, Data Analyst, Customer Service Officer or Marketing Analyst. An Administrator can create a Merchant, Account Manager, Administrator, Data Analyst, Customer Service Officer or Marketing Analyst. An Account Manager can only create a Merchant.
     * @summary Register a new account
     * @param type 1 &#x3D; User, 2 &#x3D; Merchant, 3 &#x3D; Account Manager, 4 &#x3D; Administrator, 5 &#x3D; Data Analyst, 6 &#x3D; Customer Service Officer, 7 &#x3D; Marketing Analyst, 8 &#x3D; POS Terminal
     * @param loginId Login Id
     * @param loginType 1 &#x3D; Email / Password, 2 &#x3D; OpenID
     * @param ipAddress User&#39;s IP Address (Used to set default timezone and currency code)
     * @param emailAddress Email Address
     * @param firstName First Name
     * @param lastName Last Name
     * @param secret value &#x3D; password when using email / password login, value &#x3D; access token when using third party login
     * @param idToken ID Token when using third party login
     * @param refreshToken Refresh Token when using third party login
     * @param thirdParty 1 &#x3D; Facebook, 2 &#x3D; Spotify, 3 &#x3D; Google, 4 &#x3D; Hapz Single Sign-On
     * @param onboardedUser Is Onboarded User
     * @param onboardingCampaign Onboarding Campaign Id
     * @param onboardingCampaignUser Onboarding Campaign User Id
     * @param merchant Merchant ID (Required when registering a Merchant Account. The Merchant Account will be assigned to the specified Merchant)
     * @param referralCode Referral Code
     * @param source Source where this user is from (Eg. Marketing Campaign ID
     * @param referrerUrl Referral URL
     * @param {*} [options] Override http request options.
     */
    public addAccount (type: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8, loginId: string, loginType: 1 | 2, ipAddress: string, emailAddress?: string, firstName?: string, lastName?: string, secret?: string, idToken?: string, refreshToken?: string, thirdParty?: 1 | 2 | 3 | 4, onboardedUser?: boolean, onboardingCampaign?: string, onboardingCampaignUser?: string, merchant?: string, referralCode?: string, source?: string, referrerUrl?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AccountSessionDto;  }> {
        const localVarPath = this.basePath + '/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling addAccount.');
        }

        // verify required parameter 'loginId' is not null or undefined
        if (loginId === null || loginId === undefined) {
            throw new Error('Required parameter loginId was null or undefined when calling addAccount.');
        }

        // verify required parameter 'loginType' is not null or undefined
        if (loginType === null || loginType === undefined) {
            throw new Error('Required parameter loginType was null or undefined when calling addAccount.');
        }

        // verify required parameter 'ipAddress' is not null or undefined
        if (ipAddress === null || ipAddress === undefined) {
            throw new Error('Required parameter ipAddress was null or undefined when calling addAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "1 | 2 | 3 | 4 | 5 | 6 | 7 | 8");
        }

        if (loginId !== undefined) {
            localVarFormParams['loginId'] = ObjectSerializer.serialize(loginId, "string");
        }

        if (emailAddress !== undefined) {
            localVarFormParams['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }

        if (firstName !== undefined) {
            localVarFormParams['firstName'] = ObjectSerializer.serialize(firstName, "string");
        }

        if (lastName !== undefined) {
            localVarFormParams['lastName'] = ObjectSerializer.serialize(lastName, "string");
        }

        if (secret !== undefined) {
            localVarFormParams['secret'] = ObjectSerializer.serialize(secret, "string");
        }

        if (idToken !== undefined) {
            localVarFormParams['idToken'] = ObjectSerializer.serialize(idToken, "string");
        }

        if (refreshToken !== undefined) {
            localVarFormParams['refreshToken'] = ObjectSerializer.serialize(refreshToken, "string");
        }

        if (loginType !== undefined) {
            localVarFormParams['loginType'] = ObjectSerializer.serialize(loginType, "1 | 2");
        }

        if (thirdParty !== undefined) {
            localVarFormParams['thirdParty'] = ObjectSerializer.serialize(thirdParty, "1 | 2 | 3 | 4");
        }

        if (ipAddress !== undefined) {
            localVarFormParams['ipAddress'] = ObjectSerializer.serialize(ipAddress, "string");
        }

        if (onboardedUser !== undefined) {
            localVarFormParams['onboardedUser'] = ObjectSerializer.serialize(onboardedUser, "boolean");
        }

        if (onboardingCampaign !== undefined) {
            localVarFormParams['onboardingCampaign'] = ObjectSerializer.serialize(onboardingCampaign, "string");
        }

        if (onboardingCampaignUser !== undefined) {
            localVarFormParams['onboardingCampaignUser'] = ObjectSerializer.serialize(onboardingCampaignUser, "string");
        }

        if (merchant !== undefined) {
            localVarFormParams['merchant'] = ObjectSerializer.serialize(merchant, "string");
        }

        if (referralCode !== undefined) {
            localVarFormParams['referralCode'] = ObjectSerializer.serialize(referralCode, "string");
        }

        if (source !== undefined) {
            localVarFormParams['source'] = ObjectSerializer.serialize(source, "string");
        }

        if (referrerUrl !== undefined) {
            localVarFormParams['referrerUrl'] = ObjectSerializer.serialize(referrerUrl, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountSessionDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountSessionDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all accounts of a given type
     * @param start Start Row
     * @param rows Number of Rows
     * @param type 1 &#x3D; Users, 3 &#x3D; Account Manager, 4 &#x3D; Administrator, 5 &#x3D; Data Analyst, 6 &#x3D; Customer Service Officer, 7 &#x3D; Marketing Analyst, 8 &#x3D; POS Terminal
     * @param emailAddress Email Address
     * @param {*} [options] Override http request options.
     */
    public getAccounts (start: number, rows: number, type?: 1 | 3 | 4 | 5 | 6 | 7 | 8, emailAddress?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemsPageResponseAccountDto;  }> {
        const localVarPath = this.basePath + '/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getAccounts.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getAccounts.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "1 | 3 | 4 | 5 | 6 | 7 | 8");
        }

        if (emailAddress !== undefined) {
            localVarQueryParameters['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPageResponseAccountDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsPageResponseAccountDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Enables or Disables an existing account
     * @param accountId Account ID
     * @param status Account Status (0 &#x3D; Disabled, 1 &#x3D; Enabled)
     * @param {*} [options] Override http request options.
     */
    public updateAccountStatus (accountId: string, status?: 0 | 1, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/status'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateAccountStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (status !== undefined) {
            localVarFormParams['status'] = ObjectSerializer.serialize(status, "0 | 1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the profile picture of an existing account
     * @param accountId Account ID
     * @param image 
     * @param {*} [options] Override http request options.
     */
    public updateImage (accountId: string, image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/image'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateImage.');
        }

        // verify required parameter 'image' is not null or undefined
        if (image === null || image === undefined) {
            throw new Error('Required parameter image was null or undefined when calling updateImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (image !== undefined) {
            localVarFormParams['image'] = image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccountsCampaignApiApiKeys {
    JWT,
}

export class AccountsCampaignApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountsCampaignApiApiKeys, value: string) {
        (this.authentications as any)[AccountsCampaignApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves all campaigns owned by an account
     * @param account Account ID
     * @param {*} [options] Override http request options.
     */
    public getCampaignsOwnedByAccount (account: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/{account}/campaigns'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getCampaignsOwnedByAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccountsDatatableApiApiKeys {
    JWT,
}

export class AccountsDatatableApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountsDatatableApiApiKeys, value: string) {
        (this.authentications as any)[AccountsDatatableApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves all accounts of a given type
     * @param type 1 &#x3D; Users, 2 &#x3D; Merchant, 3 &#x3D; Account Manager, 4 &#x3D; Administrator, 5 &#x3D; Data Analyst, 6 &#x3D; Customer Service Officer, 7 &#x3D; Marketing Analyst, 8 &#x3D; POS Terminal
     * @param merchantId Merchant Id (required if type is 2)
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public getAccounts1 (type?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8, merchantId?: string, body?: DataTablesInput, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DataTablesOutputAccountDto;  }> {
        const localVarPath = this.basePath + '/datatable';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "1 | 2 | 3 | 4 | 5 | 6 | 7 | 8");
        }

        if (merchantId !== undefined) {
            localVarQueryParameters['merchantId'] = ObjectSerializer.serialize(merchantId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DataTablesInput")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataTablesOutputAccountDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataTablesOutputAccountDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ActivationApiApiKeys {
    JWT,
}

export class ActivationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ActivationApiApiKeys, value: string) {
        (this.authentications as any)[ActivationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Activates an account with the given code
     * @param accountId Account ID
     * @param code Code
     * @param password Password
     * @param {*} [options] Override http request options.
     */
    public activateAccount (accountId: string, code: string, password?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AccountDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/activation'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling activateAccount.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling activateAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (code !== undefined) {
            localVarFormParams['code'] = ObjectSerializer.serialize(code, "string");
        }

        if (password !== undefined) {
            localVarFormParams['password'] = ObjectSerializer.serialize(password, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApikeysApiApiKeys {
    JWT,
}

export class ApikeysApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApikeysApiApiKeys, value: string) {
        (this.authentications as any)[ApikeysApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new API key to this account
     * @param accountId Account ID
     * @param type API Key Type (1 &#x3D; Global)
     * @param {*} [options] Override http request options.
     */
    public addApiKey (accountId: string, type: 1, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApiKeyDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/apikeys'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling addApiKey.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling addApiKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApiKeyDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiKeyDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an API key from this account
     * @param accountId Account ID
     * @param apiKey API Key
     * @param {*} [options] Override http request options.
     */
    public deleteApiKey (accountId: string, apiKey: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/apikeys/{apiKey}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'apiKey' + '}', encodeURIComponent(String(apiKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteApiKey.');
        }

        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling deleteApiKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all API keys from this account
     * @param accountId Account ID
     * @param {*} [options] Override http request options.
     */
    public getApiKeys (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApiKeyDto>;  }> {
        const localVarPath = this.basePath + '/{accountId}/apikeys'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getApiKeys.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApiKeyDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApiKeyDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AvailabilityApiApiKeys {
    JWT,
}

export class AvailabilityApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AvailabilityApiApiKeys, value: string) {
        (this.authentications as any)[AvailabilityApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve the availability of a login id
     * @param loginId Login Id
     * @param {*} [options] Override http request options.
     */
    public getAccountAvailability (loginId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/availability';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginId' is not null or undefined
        if (loginId === null || loginId === undefined) {
            throw new Error('Required parameter loginId was null or undefined when calling getAccountAvailability.');
        }

        if (loginId !== undefined) {
            localVarQueryParameters['loginId'] = ObjectSerializer.serialize(loginId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CardsApiApiKeys {
    JWT,
}

export class CardsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CardsApiApiKeys, value: string) {
        (this.authentications as any)[CardsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new credit card to this account
     * @param accountId Account ID
     * @param token Stripe Card Token
     * @param issuerIdentificationNumber Issuer Identification Number
     * @param {*} [options] Override http request options.
     */
    public addCard (accountId: string, token: string, issuerIdentificationNumber: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/cards'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling addCard.');
        }

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling addCard.');
        }

        // verify required parameter 'issuerIdentificationNumber' is not null or undefined
        if (issuerIdentificationNumber === null || issuerIdentificationNumber === undefined) {
            throw new Error('Required parameter issuerIdentificationNumber was null or undefined when calling addCard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (token !== undefined) {
            localVarFormParams['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (issuerIdentificationNumber !== undefined) {
            localVarFormParams['issuerIdentificationNumber'] = ObjectSerializer.serialize(issuerIdentificationNumber, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId Account ID
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public addCard1 (accountId: string, body?: CardDto, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/cards'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling addCard1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CardDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a credit card from this account
     * @param accountId Account ID
     * @param paymentSource Payment Source ID
     * @param {*} [options] Override http request options.
     */
    public deleteCard (accountId: string, paymentSource: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/cards/{paymentSource}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'paymentSource' + '}', encodeURIComponent(String(paymentSource)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteCard.');
        }

        // verify required parameter 'paymentSource' is not null or undefined
        if (paymentSource === null || paymentSource === undefined) {
            throw new Error('Required parameter paymentSource was null or undefined when calling deleteCard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a credit card from this account
     * @param accountId Account ID
     * @param paymentSource Payment Source ID
     * @param {*} [options] Override http request options.
     */
    public getCard (accountId: string, paymentSource: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PaymentSourceDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/cards/{paymentSource}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'paymentSource' + '}', encodeURIComponent(String(paymentSource)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getCard.');
        }

        // verify required parameter 'paymentSource' is not null or undefined
        if (paymentSource === null || paymentSource === undefined) {
            throw new Error('Required parameter paymentSource was null or undefined when calling getCard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PaymentSourceDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PaymentSourceDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all the cards from this account
     * @param accountId Account ID
     * @param {*} [options] Override http request options.
     */
    public getCards (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PaymentSourceDto>;  }> {
        const localVarPath = this.basePath + '/{accountId}/cards'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getCards.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PaymentSourceDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PaymentSourceDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CreditsApiApiKeys {
    JWT,
}

export class CreditsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CreditsApiApiKeys, value: string) {
        (this.authentications as any)[CreditsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds or removes credits from the account
     * @param account Account ID
     * @param currency Currency
     * @param description Description
     * @param expiresAt Expiry Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param credits Credits to add to the account (Negative value will remove credits)
     * @param {*} [options] Override http request options.
     */
    public addCredits (account: string, currency: string, description: string, expiresAt: Date, credits?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AccountCreditsLedgerDto;  }> {
        const localVarPath = this.basePath + '/{account}/credits'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling addCredits.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling addCredits.');
        }

        // verify required parameter 'description' is not null or undefined
        if (description === null || description === undefined) {
            throw new Error('Required parameter description was null or undefined when calling addCredits.');
        }

        // verify required parameter 'expiresAt' is not null or undefined
        if (expiresAt === null || expiresAt === undefined) {
            throw new Error('Required parameter expiresAt was null or undefined when calling addCredits.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (credits !== undefined) {
            localVarFormParams['credits'] = ObjectSerializer.serialize(credits, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expiresAt'] = ObjectSerializer.serialize(expiresAt, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountCreditsLedgerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountCreditsLedgerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param account Account ID
     * @param creditsLedger Credits Ledger ID
     * @param {*} [options] Override http request options.
     */
    public commitCreditsLedger (account: string, creditsLedger: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{account}/credits/{creditsLedger}/commit'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'creditsLedger' + '}', encodeURIComponent(String(creditsLedger)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling commitCreditsLedger.');
        }

        // verify required parameter 'creditsLedger' is not null or undefined
        if (creditsLedger === null || creditsLedger === undefined) {
            throw new Error('Required parameter creditsLedger was null or undefined when calling commitCreditsLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the credits history from the account
     * @param account Account ID
     * @param {*} [options] Override http request options.
     */
    public getCredits (account: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<AccountCreditsLedgerDto>;  }> {
        const localVarPath = this.basePath + '/{account}/credits'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getCredits.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<AccountCreditsLedgerDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AccountCreditsLedgerDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param account Account ID
     * @param creditsLedger Credits Ledger ID
     * @param {*} [options] Override http request options.
     */
    public getCreditsLedger (account: string, creditsLedger: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AccountCreditsLedgerDto;  }> {
        const localVarPath = this.basePath + '/{account}/credits/{creditsLedger}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'creditsLedger' + '}', encodeURIComponent(String(creditsLedger)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getCreditsLedger.');
        }

        // verify required parameter 'creditsLedger' is not null or undefined
        if (creditsLedger === null || creditsLedger === undefined) {
            throw new Error('Required parameter creditsLedger was null or undefined when calling getCreditsLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountCreditsLedgerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountCreditsLedgerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param account Account ID
     * @param creditsLedger Credits Ledger ID
     * @param currency Currency
     * @param credits Credits to add to the account (Negative value will remove credits)
     * @param {*} [options] Override http request options.
     */
    public updateCreditsLedgerCreditsCurrency (account: string, creditsLedger: string, currency: string, credits?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{account}/credits/{creditsLedger}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'creditsLedger' + '}', encodeURIComponent(String(creditsLedger)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling updateCreditsLedgerCreditsCurrency.');
        }

        // verify required parameter 'creditsLedger' is not null or undefined
        if (creditsLedger === null || creditsLedger === undefined) {
            throw new Error('Required parameter creditsLedger was null or undefined when calling updateCreditsLedgerCreditsCurrency.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling updateCreditsLedgerCreditsCurrency.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (credits !== undefined) {
            localVarFormParams['credits'] = ObjectSerializer.serialize(credits, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param account Account ID
     * @param creditsLedger Credits Ledger ID
     * @param expiresAt Expiry Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param {*} [options] Override http request options.
     */
    public updateCreditsLedgerExpiry (account: string, creditsLedger: string, expiresAt: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{account}/credits/{creditsLedger}/expiry'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'creditsLedger' + '}', encodeURIComponent(String(creditsLedger)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling updateCreditsLedgerExpiry.');
        }

        // verify required parameter 'creditsLedger' is not null or undefined
        if (creditsLedger === null || creditsLedger === undefined) {
            throw new Error('Required parameter creditsLedger was null or undefined when calling updateCreditsLedgerExpiry.');
        }

        // verify required parameter 'expiresAt' is not null or undefined
        if (expiresAt === null || expiresAt === undefined) {
            throw new Error('Required parameter expiresAt was null or undefined when calling updateCreditsLedgerExpiry.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expiresAt !== undefined) {
            localVarFormParams['expiresAt'] = ObjectSerializer.serialize(expiresAt, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EngagementsApiApiKeys {
    JWT,
}

export class EngagementsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EngagementsApiApiKeys, value: string) {
        (this.authentications as any)[EngagementsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param domain 
     * @param {*} [options] Override http request options.
     */
    public getEmailDomainTransactionCount (domain: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/engagements/emaildomains/{domain}'
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling getEmailDomainTransactionCount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}

export enum LookupApiApiKeys {
    JWT,
}

export class LookupApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LookupApiApiKeys, value: string) {
        (this.authentications as any)[LookupApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public existsById (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/existsById'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling existsById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param role 
     * @param {*} [options] Override http request options.
     */
    public existsByIdAndRole (accountId: string, role: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/existsByIdAndRole/{role}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'role' + '}', encodeURIComponent(String(role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling existsByIdAndRole.');
        }

        // verify required parameter 'role' is not null or undefined
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling existsByIdAndRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param loginId 
     * @param {*} [options] Override http request options.
     */
    public getAccountId (loginId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/lookup/login/{loginId}'
            .replace('{' + 'loginId' + '}', encodeURIComponent(String(loginId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginId' is not null or undefined
        if (loginId === null || loginId === undefined) {
            throw new Error('Required parameter loginId was null or undefined when calling getAccountId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public getCampaignIdsFromAccountManagerRole (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/getCampaignIdsFromAccountManagerRole'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getCampaignIdsFromAccountManagerRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public getCampaignIdsFromMerchantRole (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/getCampaignIdsFromMerchantRole'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getCampaignIdsFromMerchantRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public getEngagedMerchantIds (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/engagedMerchantIds'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getEngagedMerchantIds.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param transactionIds 
     * @param {*} [options] Override http request options.
     */
    public getTransactionIdsAccessibleByAccountManager (accountId: string, transactionIds?: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/getTransactionIdsAccessibleByAccountManager'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getTransactionIdsAccessibleByAccountManager.');
        }

        if (transactionIds !== undefined) {
            localVarQueryParameters['transactionIds'] = ObjectSerializer.serialize(transactionIds, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param transactionIds 
     * @param {*} [options] Override http request options.
     */
    public getTransactionIdsAccessibleByMerchantAccount (accountId: string, transactionIds?: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/getTransactionIdsAccessibleByMerchantAccount'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getTransactionIdsAccessibleByMerchantAccount.');
        }

        if (transactionIds !== undefined) {
            localVarQueryParameters['transactionIds'] = ObjectSerializer.serialize(transactionIds, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param transactionIds 
     * @param {*} [options] Override http request options.
     */
    public getTransactionIdsAccessibleByPosTerminalAccount (accountId: string, transactionIds?: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/getTransactionIdsAccessibleByPosTerminalAccount'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getTransactionIdsAccessibleByPosTerminalAccount.');
        }

        if (transactionIds !== undefined) {
            localVarQueryParameters['transactionIds'] = ObjectSerializer.serialize(transactionIds, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param userId 
     * @param {*} [options] Override http request options.
     */
    public isAccountManagerCampaignBidder (accountId: string, userId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/isAccountManagerCampaignBidder/{userId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isAccountManagerCampaignBidder.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling isAccountManagerCampaignBidder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param campaignId 
     * @param {*} [options] Override http request options.
     */
    public isAccountManagerCampaignOwner (accountId: string, campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/isAccountManagerCampaignOwner/{campaignId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isAccountManagerCampaignOwner.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isAccountManagerCampaignOwner.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param merchantAccount 
     * @param {*} [options] Override http request options.
     */
    public isAccountManagerOfMerchantAccount (accountId: string, merchantAccount: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/isAccountManagerOfMerchantAccount/{merchantAccount}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'merchantAccount' + '}', encodeURIComponent(String(merchantAccount)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isAccountManagerOfMerchantAccount.');
        }

        // verify required parameter 'merchantAccount' is not null or undefined
        if (merchantAccount === null || merchantAccount === undefined) {
            throw new Error('Required parameter merchantAccount was null or undefined when calling isAccountManagerOfMerchantAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param merchantId 
     * @param {*} [options] Override http request options.
     */
    public isAccountManagerOfMerchantObject (accountId: string, merchantId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/isAccountManagerOfMerchantObject/{merchantId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'merchantId' + '}', encodeURIComponent(String(merchantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isAccountManagerOfMerchantObject.');
        }

        // verify required parameter 'merchantId' is not null or undefined
        if (merchantId === null || merchantId === undefined) {
            throw new Error('Required parameter merchantId was null or undefined when calling isAccountManagerOfMerchantObject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param campaignId 
     * @param {*} [options] Override http request options.
     */
    public isCampaignBidder (accountId: string, campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/isCampaignBidder/{campaignId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isCampaignBidder.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isCampaignBidder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param campaignId 
     * @param timeslotId 
     * @param {*} [options] Override http request options.
     */
    public isCampaignTimeslotBidder (accountId: string, campaignId: string, timeslotId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/campaigns/{campaignId}/timeslots/{timeslotId}/isBidder'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)))
            .replace('{' + 'timeslotId' + '}', encodeURIComponent(String(timeslotId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isCampaignTimeslotBidder.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isCampaignTimeslotBidder.');
        }

        // verify required parameter 'timeslotId' is not null or undefined
        if (timeslotId === null || timeslotId === undefined) {
            throw new Error('Required parameter timeslotId was null or undefined when calling isCampaignTimeslotBidder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param userId 
     * @param {*} [options] Override http request options.
     */
    public isMerchantCampaignBidder (accountId: string, userId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/isMerchantCampaignBidder/{userId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isMerchantCampaignBidder.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling isMerchantCampaignBidder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param campaignId 
     * @param {*} [options] Override http request options.
     */
    public isMerchantCampaignOwner (accountId: string, campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/isMerchantCampaignOwner/{campaignId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isMerchantCampaignOwner.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isMerchantCampaignOwner.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param merchantId 
     * @param {*} [options] Override http request options.
     */
    public isMerchantOfMerchantObject (accountId: string, merchantId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/isMerchantOfMerchantObject/{merchantId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'merchantId' + '}', encodeURIComponent(String(merchantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isMerchantOfMerchantObject.');
        }

        // verify required parameter 'merchantId' is not null or undefined
        if (merchantId === null || merchantId === undefined) {
            throw new Error('Required parameter merchantId was null or undefined when calling isMerchantOfMerchantObject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param campaignId 
     * @param {*} [options] Override http request options.
     */
    public isPosTerminalCampaignOwner (accountId: string, campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/isPosTerminalCampaignOwner/{campaignId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isPosTerminalCampaignOwner.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isPosTerminalCampaignOwner.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param transactionId 
     * @param {*} [options] Override http request options.
     */
    public isTransactionAccessibleByAccountManager (accountId: string, transactionId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/isTransactionAccessibleByAccountManager/{transactionId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'transactionId' + '}', encodeURIComponent(String(transactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isTransactionAccessibleByAccountManager.');
        }

        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling isTransactionAccessibleByAccountManager.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param transactionId 
     * @param {*} [options] Override http request options.
     */
    public isTransactionAccessibleByMerchantAccount (accountId: string, transactionId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/isTransactionAccessibleByMerchantAccount/{transactionId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'transactionId' + '}', encodeURIComponent(String(transactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isTransactionAccessibleByMerchantAccount.');
        }

        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling isTransactionAccessibleByMerchantAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId 
     * @param transactionId 
     * @param {*} [options] Override http request options.
     */
    public isTransactionAccessibleByPosTerminal (accountId: string, transactionId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{accountId}/isTransactionAccessibleByPosTerminal/{transactionId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'transactionId' + '}', encodeURIComponent(String(transactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isTransactionAccessibleByPosTerminal.');
        }

        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling isTransactionAccessibleByPosTerminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MailAttachmentsApiApiKeys {
    JWT,
}

export class MailAttachmentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MailAttachmentsApiApiKeys, value: string) {
        (this.authentications as any)[MailAttachmentsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve an email attachment sent to an account
     * @param accountId Account ID
     * @param mailId Mail ID
     * @param attachmentId Attachment ID
     * @param {*} [options] Override http request options.
     */
    public getAccountMailAttachment (accountId: string, mailId: string, attachmentId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Document;  }> {
        const localVarPath = this.basePath + '/{accountId}/mails/{mailId}/attachments/{attachmentId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'mailId' + '}', encodeURIComponent(String(mailId)))
            .replace('{' + 'attachmentId' + '}', encodeURIComponent(String(attachmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountMailAttachment.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling getAccountMailAttachment.');
        }

        // verify required parameter 'attachmentId' is not null or undefined
        if (attachmentId === null || attachmentId === undefined) {
            throw new Error('Required parameter attachmentId was null or undefined when calling getAccountMailAttachment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Document;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Document");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the content of an email attachment sent to an account
     * @param accountId Account ID
     * @param mailId Mail ID
     * @param attachmentId Attachment ID
     * @param {*} [options] Override http request options.
     */
    public getAccountMailAttachmentContent (accountId: string, mailId: string, attachmentId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/mails/{mailId}/attachments/{attachmentId}/content'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'mailId' + '}', encodeURIComponent(String(mailId)))
            .replace('{' + 'attachmentId' + '}', encodeURIComponent(String(attachmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountMailAttachmentContent.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling getAccountMailAttachmentContent.');
        }

        // verify required parameter 'attachmentId' is not null or undefined
        if (attachmentId === null || attachmentId === undefined) {
            throw new Error('Required parameter attachmentId was null or undefined when calling getAccountMailAttachmentContent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve all email attachments for an email
     * @param accountId Account ID
     * @param mailId Mail ID
     * @param {*} [options] Override http request options.
     */
    public getAccountMailAttachments (accountId: string, mailId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Document>;  }> {
        const localVarPath = this.basePath + '/{accountId}/mails/{mailId}/attachments'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'mailId' + '}', encodeURIComponent(String(mailId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountMailAttachments.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling getAccountMailAttachments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Document>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Document>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MailsApiApiKeys {
    JWT,
}

export class MailsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MailsApiApiKeys, value: string) {
        (this.authentications as any)[MailsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve an email sent to an account
     * @param accountId Account ID
     * @param mailId Mail ID
     * @param {*} [options] Override http request options.
     */
    public getAccountMail (accountId: string, mailId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MailDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/mails/{mailId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'mailId' + '}', encodeURIComponent(String(mailId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountMail.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling getAccountMail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MailDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MailDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the content of an email sent to an account
     * @param accountId Account ID
     * @param mailId Mail ID
     * @param {*} [options] Override http request options.
     */
    public getAccountMailContent (accountId: string, mailId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/{accountId}/mails/{mailId}/content'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'mailId' + '}', encodeURIComponent(String(mailId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountMailContent.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling getAccountMailContent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the emails sent to an account
     * @param accountId Account ID
     * @param {*} [options] Override http request options.
     */
    public getAccountMails (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MailDto>;  }> {
        const localVarPath = this.basePath + '/{accountId}/mails'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountMails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<MailDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MailDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Resend an email sent to an account
     * @param accountId Account ID
     * @param mailId Mail ID
     * @param emailAddress Email Address
     * @param {*} [options] Override http request options.
     */
    public resendAccountMail (accountId: string, mailId: string, emailAddress?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/mails/{mailId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'mailId' + '}', encodeURIComponent(String(mailId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling resendAccountMail.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling resendAccountMail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (emailAddress !== undefined) {
            localVarFormParams['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends an email to an account
     * @param accountId Account ID
     * @param type Mail Type (1 &#x3D; Activate Account Mail)
     * @param subject Subject
     * @param {*} [options] Override http request options.
     */
    public sendMail (accountId: string, type?: number, subject?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/mails'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling sendMail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "number");
        }

        if (subject !== undefined) {
            localVarFormParams['subject'] = ObjectSerializer.serialize(subject, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param accountId Account ID
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public sendMail1 (accountId: string, body?: SendEmailRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MailDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/mails'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling sendMail1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SendEmailRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MailDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MailDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MembershipsApiApiKeys {
    JWT,
}

export class MembershipsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MembershipsApiApiKeys, value: string) {
        (this.authentications as any)[MembershipsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve the partner memberships from an account
     * @param accountId Account ID
     * @param {*} [options] Override http request options.
     */
    public getAccountPartnerMemberships (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<UserRolePartnerMembershipDto>;  }> {
        const localVarPath = this.basePath + '/{accountId}/memberships'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountPartnerMemberships.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<UserRolePartnerMembershipDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<UserRolePartnerMembershipDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MerchantAccountApiApiKeys {
    JWT,
}

export class MerchantAccountApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MerchantAccountApiApiKeys, value: string) {
        (this.authentications as any)[MerchantAccountApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves all accounts from a given merchant
     * @param merchantId 
     * @param {*} [options] Override http request options.
     */
    public getMerchantAccounts (merchantId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<AccountDto>;  }> {
        const localVarPath = this.basePath + '/merchants/{merchantId}/accounts'
            .replace('{' + 'merchantId' + '}', encodeURIComponent(String(merchantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantId' is not null or undefined
        if (merchantId === null || merchantId === undefined) {
            throw new Error('Required parameter merchantId was null or undefined when calling getMerchantAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<AccountDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AccountDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MerchantsApiApiKeys {
    JWT,
}

export class MerchantsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MerchantsApiApiKeys, value: string) {
        (this.authentications as any)[MerchantsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new merchant to an existing Account Manager account
     * @param accountId Account ID
     * @param merchantId Merchant Id
     * @param {*} [options] Override http request options.
     */
    public addMerchant (accountId: string, merchantId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MerchantDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/merchants'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling addMerchant.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (merchantId !== undefined) {
            localVarFormParams['merchantId'] = ObjectSerializer.serialize(merchantId, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MerchantDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MerchantDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only Administrators and Account Managers are allowed to create new Merchants. Merchants created by an Account Manager are automatically assigned to that Account Manager. Merchants created by an Administrator are unassigned until otherwise.
     * @summary Adds a new merchant
     * @param name Merchant Name
     * @param contactInfoName Point of Contact&#39;s Name
     * @param contactInfoEmail Point of Contact&#39;s Email
     * @param contactInfoOffice Point of Contact&#39;s Office No
     * @param contactInfoPhone Point of Contact&#39;s Phone No
     * @param image Merchant Image
     * @param contactInfoFax Point of Contact&#39;s Fax No
     * @param facebookPixelId Facebook Pixel ID
     * @param googleAnalyticsPixelId Google Analytics Pixel ID
     * @param {*} [options] Override http request options.
     */
    public addMerchant1 (name: string, contactInfoName: string, contactInfoEmail: string, contactInfoOffice: string, contactInfoPhone: string, image?: Buffer, contactInfoFax?: string, facebookPixelId?: string, googleAnalyticsPixelId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Merchant;  }> {
        const localVarPath = this.basePath + '/merchants';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addMerchant1.');
        }

        // verify required parameter 'contactInfoName' is not null or undefined
        if (contactInfoName === null || contactInfoName === undefined) {
            throw new Error('Required parameter contactInfoName was null or undefined when calling addMerchant1.');
        }

        // verify required parameter 'contactInfoEmail' is not null or undefined
        if (contactInfoEmail === null || contactInfoEmail === undefined) {
            throw new Error('Required parameter contactInfoEmail was null or undefined when calling addMerchant1.');
        }

        // verify required parameter 'contactInfoOffice' is not null or undefined
        if (contactInfoOffice === null || contactInfoOffice === undefined) {
            throw new Error('Required parameter contactInfoOffice was null or undefined when calling addMerchant1.');
        }

        // verify required parameter 'contactInfoPhone' is not null or undefined
        if (contactInfoPhone === null || contactInfoPhone === undefined) {
            throw new Error('Required parameter contactInfoPhone was null or undefined when calling addMerchant1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (image !== undefined) {
            localVarFormParams['image'] = image;
        }
        localVarUseFormData = true;

        if (contactInfoName !== undefined) {
            localVarFormParams['contactInfoName'] = ObjectSerializer.serialize(contactInfoName, "string");
        }

        if (contactInfoEmail !== undefined) {
            localVarFormParams['contactInfoEmail'] = ObjectSerializer.serialize(contactInfoEmail, "string");
        }

        if (contactInfoOffice !== undefined) {
            localVarFormParams['contactInfoOffice'] = ObjectSerializer.serialize(contactInfoOffice, "string");
        }

        if (contactInfoPhone !== undefined) {
            localVarFormParams['contactInfoPhone'] = ObjectSerializer.serialize(contactInfoPhone, "string");
        }

        if (contactInfoFax !== undefined) {
            localVarFormParams['contactInfoFax'] = ObjectSerializer.serialize(contactInfoFax, "string");
        }

        if (facebookPixelId !== undefined) {
            localVarFormParams['facebookPixelId'] = ObjectSerializer.serialize(facebookPixelId, "string");
        }

        if (googleAnalyticsPixelId !== undefined) {
            localVarFormParams['googleAnalyticsPixelId'] = ObjectSerializer.serialize(googleAnalyticsPixelId, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Merchant;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Merchant");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a merchant from an existing Account Manager account
     * @param accountId Account ID
     * @param merchantId Merchant Id
     * @param {*} [options] Override http request options.
     */
    public deleteMerchant (accountId: string, merchantId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/merchants/{merchantId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'merchantId' + '}', encodeURIComponent(String(merchantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteMerchant.');
        }

        // verify required parameter 'merchantId' is not null or undefined
        if (merchantId === null || merchantId === undefined) {
            throw new Error('Required parameter merchantId was null or undefined when calling deleteMerchant.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a merchant
     * @param merchantId 
     * @param {*} [options] Override http request options.
     */
    public deleteMerchant1 (merchantId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/merchants/{merchantId}'
            .replace('{' + 'merchantId' + '}', encodeURIComponent(String(merchantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantId' is not null or undefined
        if (merchantId === null || merchantId === undefined) {
            throw new Error('Required parameter merchantId was null or undefined when calling deleteMerchant1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of a merchant
     * @param merchantId 
     * @param {*} [options] Override http request options.
     */
    public getMerchant (merchantId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MerchantDto;  }> {
        const localVarPath = this.basePath + '/merchants/{merchantId}'
            .replace('{' + 'merchantId' + '}', encodeURIComponent(String(merchantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantId' is not null or undefined
        if (merchantId === null || merchantId === undefined) {
            throw new Error('Required parameter merchantId was null or undefined when calling getMerchant.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MerchantDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MerchantDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the merchants of an existing Account Manager account
     * @param accountId Account ID
     * @param {*} [options] Override http request options.
     */
    public getMerchants (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MerchantDto>;  }> {
        const localVarPath = this.basePath + '/{accountId}/merchants'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getMerchants.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<MerchantDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MerchantDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all merchants
     * @param start Start Row
     * @param rows Number of Rows
     * @param {*} [options] Override http request options.
     */
    public getMerchants1 (start: number, rows: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemsPageResponseMerchantDto;  }> {
        const localVarPath = this.basePath + '/merchants';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getMerchants1.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getMerchants1.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPageResponseMerchantDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsPageResponseMerchantDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the transactions from a merchant given the redemption code or the user's personal information and/or the date range
     * @param merchantId 
     * @param redemptionCode 
     * @param emailAddress 
     * @param contactNo 
     * @param {*} [options] Override http request options.
     */
    public getTransactions (merchantId: string, redemptionCode?: string, emailAddress?: string, contactNo?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/merchants/{merchantId}/transactions'
            .replace('{' + 'merchantId' + '}', encodeURIComponent(String(merchantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantId' is not null or undefined
        if (merchantId === null || merchantId === undefined) {
            throw new Error('Required parameter merchantId was null or undefined when calling getTransactions.');
        }

        if (redemptionCode !== undefined) {
            localVarQueryParameters['redemptionCode'] = ObjectSerializer.serialize(redemptionCode, "string");
        }

        if (emailAddress !== undefined) {
            localVarQueryParameters['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }

        if (contactNo !== undefined) {
            localVarQueryParameters['contactNo'] = ObjectSerializer.serialize(contactNo, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the details of a merchant
     * @param merchantId 
     * @param name Merchant Name
     * @param contactInfoName Point of Contact&#39;s Name
     * @param contactInfoEmail Point of Contact&#39;s Email
     * @param contactInfoOffice Point of Contact&#39;s Office No
     * @param contactInfoPhone Point of Contact&#39;s Phone No
     * @param image Merchant Image
     * @param contactInfoFax Point of Contact&#39;s Fax No
     * @param facebookPixelId Facebook Pixel ID
     * @param googleAnalyticsPixelId Google Analytics Pixel ID
     * @param {*} [options] Override http request options.
     */
    public updateMerchant (merchantId: string, name: string, contactInfoName: string, contactInfoEmail: string, contactInfoOffice: string, contactInfoPhone: string, image?: Buffer, contactInfoFax?: string, facebookPixelId?: string, googleAnalyticsPixelId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/merchants/{merchantId}'
            .replace('{' + 'merchantId' + '}', encodeURIComponent(String(merchantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantId' is not null or undefined
        if (merchantId === null || merchantId === undefined) {
            throw new Error('Required parameter merchantId was null or undefined when calling updateMerchant.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateMerchant.');
        }

        // verify required parameter 'contactInfoName' is not null or undefined
        if (contactInfoName === null || contactInfoName === undefined) {
            throw new Error('Required parameter contactInfoName was null or undefined when calling updateMerchant.');
        }

        // verify required parameter 'contactInfoEmail' is not null or undefined
        if (contactInfoEmail === null || contactInfoEmail === undefined) {
            throw new Error('Required parameter contactInfoEmail was null or undefined when calling updateMerchant.');
        }

        // verify required parameter 'contactInfoOffice' is not null or undefined
        if (contactInfoOffice === null || contactInfoOffice === undefined) {
            throw new Error('Required parameter contactInfoOffice was null or undefined when calling updateMerchant.');
        }

        // verify required parameter 'contactInfoPhone' is not null or undefined
        if (contactInfoPhone === null || contactInfoPhone === undefined) {
            throw new Error('Required parameter contactInfoPhone was null or undefined when calling updateMerchant.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (image !== undefined) {
            localVarFormParams['image'] = image;
        }
        localVarUseFormData = true;

        if (contactInfoName !== undefined) {
            localVarFormParams['contactInfoName'] = ObjectSerializer.serialize(contactInfoName, "string");
        }

        if (contactInfoEmail !== undefined) {
            localVarFormParams['contactInfoEmail'] = ObjectSerializer.serialize(contactInfoEmail, "string");
        }

        if (contactInfoOffice !== undefined) {
            localVarFormParams['contactInfoOffice'] = ObjectSerializer.serialize(contactInfoOffice, "string");
        }

        if (contactInfoPhone !== undefined) {
            localVarFormParams['contactInfoPhone'] = ObjectSerializer.serialize(contactInfoPhone, "string");
        }

        if (contactInfoFax !== undefined) {
            localVarFormParams['contactInfoFax'] = ObjectSerializer.serialize(contactInfoFax, "string");
        }

        if (facebookPixelId !== undefined) {
            localVarFormParams['facebookPixelId'] = ObjectSerializer.serialize(facebookPixelId, "string");
        }

        if (googleAnalyticsPixelId !== undefined) {
            localVarFormParams['googleAnalyticsPixelId'] = ObjectSerializer.serialize(googleAnalyticsPixelId, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MerchantsDatatableApiApiKeys {
    JWT,
}

export class MerchantsDatatableApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MerchantsDatatableApiApiKeys, value: string) {
        (this.authentications as any)[MerchantsDatatableApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves all merchants
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public getMerchants2 (body?: DataTablesInput, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DataTablesOutputMerchantDto;  }> {
        const localVarPath = this.basePath + '/merchants/datatable';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DataTablesInput")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataTablesOutputMerchantDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataTablesOutputMerchantDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OnboardingApiApiKeys {
    JWT,
}

export class OnboardingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OnboardingApiApiKeys, value: string) {
        (this.authentications as any)[OnboardingApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new onboarding campaign
     * @param name Onboarding Campaign Name
     * @param type Onboarding Campaign Type (1 &#x3D; Partner, 2 &#x3D; Corporates)
     * @param url URL
     * @param defaultHeader Default Header
     * @param topMessage Top Message
     * @param ctaButtonMessage CTA Button Message
     * @param bottomMessage Bottom Message
     * @param signUpBonusValue Sign up Bonus Value
     * @param signUpBonusCurrency Sign up Bonus Currency
     * @param image Onboarding Campaign Image
     * @param targetCategory Target Category Id
     * @param {*} [options] Override http request options.
     */
    public addOnboardingCampaign (name: string, type: 1 | 2, url: string, defaultHeader: string, topMessage: string, ctaButtonMessage: string, bottomMessage: string, signUpBonusValue: number, signUpBonusCurrency: string, image?: Buffer, targetCategory?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OnboardingCampaignDto;  }> {
        const localVarPath = this.basePath + '/onboarding';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addOnboardingCampaign.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling addOnboardingCampaign.');
        }

        // verify required parameter 'url' is not null or undefined
        if (url === null || url === undefined) {
            throw new Error('Required parameter url was null or undefined when calling addOnboardingCampaign.');
        }

        // verify required parameter 'defaultHeader' is not null or undefined
        if (defaultHeader === null || defaultHeader === undefined) {
            throw new Error('Required parameter defaultHeader was null or undefined when calling addOnboardingCampaign.');
        }

        // verify required parameter 'topMessage' is not null or undefined
        if (topMessage === null || topMessage === undefined) {
            throw new Error('Required parameter topMessage was null or undefined when calling addOnboardingCampaign.');
        }

        // verify required parameter 'ctaButtonMessage' is not null or undefined
        if (ctaButtonMessage === null || ctaButtonMessage === undefined) {
            throw new Error('Required parameter ctaButtonMessage was null or undefined when calling addOnboardingCampaign.');
        }

        // verify required parameter 'bottomMessage' is not null or undefined
        if (bottomMessage === null || bottomMessage === undefined) {
            throw new Error('Required parameter bottomMessage was null or undefined when calling addOnboardingCampaign.');
        }

        // verify required parameter 'signUpBonusValue' is not null or undefined
        if (signUpBonusValue === null || signUpBonusValue === undefined) {
            throw new Error('Required parameter signUpBonusValue was null or undefined when calling addOnboardingCampaign.');
        }

        // verify required parameter 'signUpBonusCurrency' is not null or undefined
        if (signUpBonusCurrency === null || signUpBonusCurrency === undefined) {
            throw new Error('Required parameter signUpBonusCurrency was null or undefined when calling addOnboardingCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "1 | 2");
        }

        if (image !== undefined) {
            localVarFormParams['image'] = image;
        }
        localVarUseFormData = true;

        if (url !== undefined) {
            localVarFormParams['url'] = ObjectSerializer.serialize(url, "string");
        }

        if (defaultHeader !== undefined) {
            localVarFormParams['defaultHeader'] = ObjectSerializer.serialize(defaultHeader, "string");
        }

        if (topMessage !== undefined) {
            localVarFormParams['topMessage'] = ObjectSerializer.serialize(topMessage, "string");
        }

        if (ctaButtonMessage !== undefined) {
            localVarFormParams['ctaButtonMessage'] = ObjectSerializer.serialize(ctaButtonMessage, "string");
        }

        if (bottomMessage !== undefined) {
            localVarFormParams['bottomMessage'] = ObjectSerializer.serialize(bottomMessage, "string");
        }

        if (targetCategory !== undefined) {
            localVarFormParams['targetCategory'] = ObjectSerializer.serialize(targetCategory, "string");
        }

        if (signUpBonusValue !== undefined) {
            localVarFormParams['signUpBonusValue'] = ObjectSerializer.serialize(signUpBonusValue, "number");
        }

        if (signUpBonusCurrency !== undefined) {
            localVarFormParams['signUpBonusCurrency'] = ObjectSerializer.serialize(signUpBonusCurrency, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OnboardingCampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OnboardingCampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new onboarding campaign source
     * @param onboardingCampaign Onboarding Campaign Id
     * @param type 1 &#x3D; MailChimp, 2 &#x3D; Typeform
     * @param externalSourceId Onboarding Campaign External Source Id
     * @param externalSourceName Onboarding Campaign External Source Name
     * @param emailAddressField Email Address Field
     * @param firstNameField First Name Field
     * @param lastNameField Last Name Field
     * @param nameField Name Field
     * @param {*} [options] Override http request options.
     */
    public addOnboardingCampaignSource (onboardingCampaign: string, type: 1 | 2, externalSourceId?: string, externalSourceName?: string, emailAddressField?: string, firstNameField?: string, lastNameField?: string, nameField?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OnboardingCampaignSourceDto;  }> {
        const localVarPath = this.basePath + '/onboarding/{onboardingCampaign}/sources'
            .replace('{' + 'onboardingCampaign' + '}', encodeURIComponent(String(onboardingCampaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'onboardingCampaign' is not null or undefined
        if (onboardingCampaign === null || onboardingCampaign === undefined) {
            throw new Error('Required parameter onboardingCampaign was null or undefined when calling addOnboardingCampaignSource.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling addOnboardingCampaignSource.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "1 | 2");
        }

        if (externalSourceId !== undefined) {
            localVarFormParams['externalSourceId'] = ObjectSerializer.serialize(externalSourceId, "string");
        }

        if (externalSourceName !== undefined) {
            localVarFormParams['externalSourceName'] = ObjectSerializer.serialize(externalSourceName, "string");
        }

        if (emailAddressField !== undefined) {
            localVarFormParams['emailAddressField'] = ObjectSerializer.serialize(emailAddressField, "string");
        }

        if (firstNameField !== undefined) {
            localVarFormParams['firstNameField'] = ObjectSerializer.serialize(firstNameField, "string");
        }

        if (lastNameField !== undefined) {
            localVarFormParams['lastNameField'] = ObjectSerializer.serialize(lastNameField, "string");
        }

        if (nameField !== undefined) {
            localVarFormParams['nameField'] = ObjectSerializer.serialize(nameField, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OnboardingCampaignSourceDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OnboardingCampaignSourceDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an onboarding campaign
     * @param onboardingCampaign 
     * @param {*} [options] Override http request options.
     */
    public deleteOnboardingCampaign (onboardingCampaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/onboarding/{onboardingCampaign}'
            .replace('{' + 'onboardingCampaign' + '}', encodeURIComponent(String(onboardingCampaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'onboardingCampaign' is not null or undefined
        if (onboardingCampaign === null || onboardingCampaign === undefined) {
            throw new Error('Required parameter onboardingCampaign was null or undefined when calling deleteOnboardingCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an onboarding campaign
     * @param onboardingCampaign 
     * @param onboardingCampaignSource 
     * @param {*} [options] Override http request options.
     */
    public deleteOnboardingCampaignSource (onboardingCampaign: string, onboardingCampaignSource: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/onboarding/{onboardingCampaign}/sources/{onboardingCampaignSource}'
            .replace('{' + 'onboardingCampaign' + '}', encodeURIComponent(String(onboardingCampaign)))
            .replace('{' + 'onboardingCampaignSource' + '}', encodeURIComponent(String(onboardingCampaignSource)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'onboardingCampaign' is not null or undefined
        if (onboardingCampaign === null || onboardingCampaign === undefined) {
            throw new Error('Required parameter onboardingCampaign was null or undefined when calling deleteOnboardingCampaignSource.');
        }

        // verify required parameter 'onboardingCampaignSource' is not null or undefined
        if (onboardingCampaignSource === null || onboardingCampaignSource === undefined) {
            throw new Error('Required parameter onboardingCampaignSource was null or undefined when calling deleteOnboardingCampaignSource.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the onboarding status of an email address
     * @param accountId Account ID
     * @param {*} [options] Override http request options.
     */
    public getAccountOnboarding (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/{accountId}/onboarding'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountOnboarding.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of an onboarding campaign
     * @param onboardingCampaign 
     * @param {*} [options] Override http request options.
     */
    public getOnboardingCampaign (onboardingCampaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OnboardingCampaignDto;  }> {
        const localVarPath = this.basePath + '/onboarding/{onboardingCampaign}'
            .replace('{' + 'onboardingCampaign' + '}', encodeURIComponent(String(onboardingCampaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'onboardingCampaign' is not null or undefined
        if (onboardingCampaign === null || onboardingCampaign === undefined) {
            throw new Error('Required parameter onboardingCampaign was null or undefined when calling getOnboardingCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OnboardingCampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OnboardingCampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of an onboarding campaign source
     * @param onboardingCampaign 
     * @param onboardingCampaignSource 
     * @param {*} [options] Override http request options.
     */
    public getOnboardingCampaignSource (onboardingCampaign: string, onboardingCampaignSource: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OnboardingCampaignSourceDto;  }> {
        const localVarPath = this.basePath + '/onboarding/{onboardingCampaign}/sources/{onboardingCampaignSource}'
            .replace('{' + 'onboardingCampaign' + '}', encodeURIComponent(String(onboardingCampaign)))
            .replace('{' + 'onboardingCampaignSource' + '}', encodeURIComponent(String(onboardingCampaignSource)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'onboardingCampaign' is not null or undefined
        if (onboardingCampaign === null || onboardingCampaign === undefined) {
            throw new Error('Required parameter onboardingCampaign was null or undefined when calling getOnboardingCampaignSource.');
        }

        // verify required parameter 'onboardingCampaignSource' is not null or undefined
        if (onboardingCampaignSource === null || onboardingCampaignSource === undefined) {
            throw new Error('Required parameter onboardingCampaignSource was null or undefined when calling getOnboardingCampaignSource.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OnboardingCampaignSourceDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OnboardingCampaignSourceDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all onboarding campaign sources
     * @param onboardingCampaign Onboarding Campaign Id
     * @param {*} [options] Override http request options.
     */
    public getOnboardingCampaignSources (onboardingCampaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<OnboardingCampaignSourceDto>;  }> {
        const localVarPath = this.basePath + '/onboarding/{onboardingCampaign}/sources'
            .replace('{' + 'onboardingCampaign' + '}', encodeURIComponent(String(onboardingCampaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'onboardingCampaign' is not null or undefined
        if (onboardingCampaign === null || onboardingCampaign === undefined) {
            throw new Error('Required parameter onboardingCampaign was null or undefined when calling getOnboardingCampaignSources.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<OnboardingCampaignSourceDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<OnboardingCampaignSourceDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of an onboarding campaign user
     * @param onboardingCampaign 
     * @param onboardingCampaignUser 
     * @param {*} [options] Override http request options.
     */
    public getOnboardingCampaignUser (onboardingCampaign: string, onboardingCampaignUser: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OnboardingCampaignUserDto;  }> {
        const localVarPath = this.basePath + '/onboarding/{onboardingCampaign}/users/{onboardingCampaignUser}'
            .replace('{' + 'onboardingCampaign' + '}', encodeURIComponent(String(onboardingCampaign)))
            .replace('{' + 'onboardingCampaignUser' + '}', encodeURIComponent(String(onboardingCampaignUser)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'onboardingCampaign' is not null or undefined
        if (onboardingCampaign === null || onboardingCampaign === undefined) {
            throw new Error('Required parameter onboardingCampaign was null or undefined when calling getOnboardingCampaignUser.');
        }

        // verify required parameter 'onboardingCampaignUser' is not null or undefined
        if (onboardingCampaignUser === null || onboardingCampaignUser === undefined) {
            throw new Error('Required parameter onboardingCampaignUser was null or undefined when calling getOnboardingCampaignUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OnboardingCampaignUserDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OnboardingCampaignUserDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all onboarding campaigns
     * @param start Start Row
     * @param rows Number of Rows
     * @param url URL of onboarding campaign
     * @param {*} [options] Override http request options.
     */
    public getOnboardingCampaigns (start: number, rows: number, url?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemsPageResponseOnboardingCampaignDto;  }> {
        const localVarPath = this.basePath + '/onboarding';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getOnboardingCampaigns.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getOnboardingCampaigns.');
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPageResponseOnboardingCampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsPageResponseOnboardingCampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve all onboarding campaigns
     * @param body Datatable Request
     * @param {*} [options] Override http request options.
     */
    public getOnboardingCampaigns1 (body?: DataTablesInput, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DataTablesOutputOnboardingCampaignDto;  }> {
        const localVarPath = this.basePath + '/onboarding/datatable';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DataTablesInput")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataTablesOutputOnboardingCampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataTablesOutputOnboardingCampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Publish / Unpublish an onboarding campaign
     * @param onboardingCampaign Onboarding Campaign ID
     * @param published 0 &#x3D; Unpublish, 1 &#x3D; Publish
     * @param {*} [options] Override http request options.
     */
    public publishEvent (onboardingCampaign: string, published: 0 | 1, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/onboarding/{onboardingCampaign}/publish'
            .replace('{' + 'onboardingCampaign' + '}', encodeURIComponent(String(onboardingCampaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'onboardingCampaign' is not null or undefined
        if (onboardingCampaign === null || onboardingCampaign === undefined) {
            throw new Error('Required parameter onboardingCampaign was null or undefined when calling publishEvent.');
        }

        // verify required parameter 'published' is not null or undefined
        if (published === null || published === undefined) {
            throw new Error('Required parameter published was null or undefined when calling publishEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (published !== undefined) {
            localVarFormParams['published'] = ObjectSerializer.serialize(published, "0 | 1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the details of an onboarding campaign
     * @param onboardingCampaign 
     * @param name Onboarding Campaign Name
     * @param type Onboarding Campaign Type (1 &#x3D; Partner, 2 &#x3D; Corporates)
     * @param url URL
     * @param defaultHeader Default Header
     * @param topMessage Top Message
     * @param ctaButtonMessage CTA Button Message
     * @param bottomMessage Bottom Message
     * @param signUpBonusValue Sign up Bonus Value
     * @param signUpBonusCurrency Sign up Bonus Currency
     * @param image Onboarding Campaign Image
     * @param targetCategory Target Category Id
     * @param {*} [options] Override http request options.
     */
    public updateOnboardingCampaign (onboardingCampaign: string, name: string, type: 1 | 2, url: string, defaultHeader: string, topMessage: string, ctaButtonMessage: string, bottomMessage: string, signUpBonusValue: number, signUpBonusCurrency: string, image?: Buffer, targetCategory?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/onboarding/{onboardingCampaign}'
            .replace('{' + 'onboardingCampaign' + '}', encodeURIComponent(String(onboardingCampaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'onboardingCampaign' is not null or undefined
        if (onboardingCampaign === null || onboardingCampaign === undefined) {
            throw new Error('Required parameter onboardingCampaign was null or undefined when calling updateOnboardingCampaign.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateOnboardingCampaign.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling updateOnboardingCampaign.');
        }

        // verify required parameter 'url' is not null or undefined
        if (url === null || url === undefined) {
            throw new Error('Required parameter url was null or undefined when calling updateOnboardingCampaign.');
        }

        // verify required parameter 'defaultHeader' is not null or undefined
        if (defaultHeader === null || defaultHeader === undefined) {
            throw new Error('Required parameter defaultHeader was null or undefined when calling updateOnboardingCampaign.');
        }

        // verify required parameter 'topMessage' is not null or undefined
        if (topMessage === null || topMessage === undefined) {
            throw new Error('Required parameter topMessage was null or undefined when calling updateOnboardingCampaign.');
        }

        // verify required parameter 'ctaButtonMessage' is not null or undefined
        if (ctaButtonMessage === null || ctaButtonMessage === undefined) {
            throw new Error('Required parameter ctaButtonMessage was null or undefined when calling updateOnboardingCampaign.');
        }

        // verify required parameter 'bottomMessage' is not null or undefined
        if (bottomMessage === null || bottomMessage === undefined) {
            throw new Error('Required parameter bottomMessage was null or undefined when calling updateOnboardingCampaign.');
        }

        // verify required parameter 'signUpBonusValue' is not null or undefined
        if (signUpBonusValue === null || signUpBonusValue === undefined) {
            throw new Error('Required parameter signUpBonusValue was null or undefined when calling updateOnboardingCampaign.');
        }

        // verify required parameter 'signUpBonusCurrency' is not null or undefined
        if (signUpBonusCurrency === null || signUpBonusCurrency === undefined) {
            throw new Error('Required parameter signUpBonusCurrency was null or undefined when calling updateOnboardingCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "1 | 2");
        }

        if (image !== undefined) {
            localVarFormParams['image'] = image;
        }
        localVarUseFormData = true;

        if (url !== undefined) {
            localVarFormParams['url'] = ObjectSerializer.serialize(url, "string");
        }

        if (defaultHeader !== undefined) {
            localVarFormParams['defaultHeader'] = ObjectSerializer.serialize(defaultHeader, "string");
        }

        if (topMessage !== undefined) {
            localVarFormParams['topMessage'] = ObjectSerializer.serialize(topMessage, "string");
        }

        if (ctaButtonMessage !== undefined) {
            localVarFormParams['ctaButtonMessage'] = ObjectSerializer.serialize(ctaButtonMessage, "string");
        }

        if (bottomMessage !== undefined) {
            localVarFormParams['bottomMessage'] = ObjectSerializer.serialize(bottomMessage, "string");
        }

        if (targetCategory !== undefined) {
            localVarFormParams['targetCategory'] = ObjectSerializer.serialize(targetCategory, "string");
        }

        if (signUpBonusValue !== undefined) {
            localVarFormParams['signUpBonusValue'] = ObjectSerializer.serialize(signUpBonusValue, "number");
        }

        if (signUpBonusCurrency !== undefined) {
            localVarFormParams['signUpBonusCurrency'] = ObjectSerializer.serialize(signUpBonusCurrency, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the details of an onboarding campaign source
     * @param onboardingCampaign 
     * @param onboardingCampaignSource 
     * @param type 1 &#x3D; MailChimp, 2 &#x3D; Typeform
     * @param externalSourceId Onboarding Campaign External Source Id
     * @param externalSourceName Onboarding Campaign External Source Name
     * @param emailAddressField Email Address Field
     * @param firstNameField First Name Field
     * @param lastNameField Last Name Field
     * @param nameField Name Field
     * @param {*} [options] Override http request options.
     */
    public updateOnboardingCampaignSource (onboardingCampaign: string, onboardingCampaignSource: string, type: 1 | 2, externalSourceId?: string, externalSourceName?: string, emailAddressField?: string, firstNameField?: string, lastNameField?: string, nameField?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/onboarding/{onboardingCampaign}/sources/{onboardingCampaignSource}'
            .replace('{' + 'onboardingCampaign' + '}', encodeURIComponent(String(onboardingCampaign)))
            .replace('{' + 'onboardingCampaignSource' + '}', encodeURIComponent(String(onboardingCampaignSource)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'onboardingCampaign' is not null or undefined
        if (onboardingCampaign === null || onboardingCampaign === undefined) {
            throw new Error('Required parameter onboardingCampaign was null or undefined when calling updateOnboardingCampaignSource.');
        }

        // verify required parameter 'onboardingCampaignSource' is not null or undefined
        if (onboardingCampaignSource === null || onboardingCampaignSource === undefined) {
            throw new Error('Required parameter onboardingCampaignSource was null or undefined when calling updateOnboardingCampaignSource.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling updateOnboardingCampaignSource.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "1 | 2");
        }

        if (externalSourceId !== undefined) {
            localVarFormParams['externalSourceId'] = ObjectSerializer.serialize(externalSourceId, "string");
        }

        if (externalSourceName !== undefined) {
            localVarFormParams['externalSourceName'] = ObjectSerializer.serialize(externalSourceName, "string");
        }

        if (emailAddressField !== undefined) {
            localVarFormParams['emailAddressField'] = ObjectSerializer.serialize(emailAddressField, "string");
        }

        if (firstNameField !== undefined) {
            localVarFormParams['firstNameField'] = ObjectSerializer.serialize(firstNameField, "string");
        }

        if (lastNameField !== undefined) {
            localVarFormParams['lastNameField'] = ObjectSerializer.serialize(lastNameField, "string");
        }

        if (nameField !== undefined) {
            localVarFormParams['nameField'] = ObjectSerializer.serialize(nameField, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OnboardingMigrationApiApiKeys {
    JWT,
}

export class OnboardingMigrationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OnboardingMigrationApiApiKeys, value: string) {
        (this.authentications as any)[OnboardingMigrationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Migrates solr documents to new the new environment
     * @param {*} [options] Override http request options.
     */
    public migrateOnboardingCampaignDocuments (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/onboardingMigration/search/migration';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PosCampaignApiApiKeys {
    JWT,
}

export class PosCampaignApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PosCampaignApiApiKeys, value: string) {
        (this.authentications as any)[PosCampaignApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add a campaign to the list of campaigns that this POS Terminal role is allowed to access
     * @param account Account ID
     * @param campaign Campaign Id
     * @param {*} [options] Override http request options.
     */
    public addCampaign (account: string, campaign?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{account}/pos/campaigns'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling addCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (campaign !== undefined) {
            localVarFormParams['campaign'] = ObjectSerializer.serialize(campaign, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a campaign from the list of campaigns that this POS Terminal role is allowed to access
     * @param account Account ID
     * @param campaign Campaign Id
     * @param {*} [options] Override http request options.
     */
    public deleteCampaign (account: string, campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{account}/pos/campaigns/{campaign}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling deleteCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the list of campaigns that this POS Terminal role is allowed to access
     * @param account Account ID
     * @param {*} [options] Override http request options.
     */
    public getCampaigns (account: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/{account}/pos/campaigns'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getCampaigns.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PosMerchantApiApiKeys {
    JWT,
}

export class PosMerchantApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PosMerchantApiApiKeys, value: string) {
        (this.authentications as any)[PosMerchantApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add a merchant to the list of merchants that this POS Terminal role is allowed to access
     * @param account Account ID
     * @param merchant Merchant Id
     * @param {*} [options] Override http request options.
     */
    public addMerchant2 (account: string, merchant?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MerchantDto;  }> {
        const localVarPath = this.basePath + '/{account}/pos/merchants'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling addMerchant2.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (merchant !== undefined) {
            localVarFormParams['merchant'] = ObjectSerializer.serialize(merchant, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MerchantDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MerchantDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a merchant from the list of merchants that this POS Terminal role is allowed to access
     * @param account Account ID
     * @param merchant Merchant Id
     * @param {*} [options] Override http request options.
     */
    public deleteMerchant2 (account: string, merchant: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{account}/pos/merchants/{merchant}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'merchant' + '}', encodeURIComponent(String(merchant)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling deleteMerchant2.');
        }

        // verify required parameter 'merchant' is not null or undefined
        if (merchant === null || merchant === undefined) {
            throw new Error('Required parameter merchant was null or undefined when calling deleteMerchant2.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the list of merchants that this POS Terminal role is allowed to access
     * @param account Account ID
     * @param {*} [options] Override http request options.
     */
    public getMerchants3 (account: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MerchantDto>;  }> {
        const localVarPath = this.basePath + '/{account}/pos/merchants'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getMerchants3.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<MerchantDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MerchantDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RecoveriesApiApiKeys {
    JWT,
}

export class RecoveriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RecoveriesApiApiKeys, value: string) {
        (this.authentications as any)[RecoveriesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get the Account Recovery for an existing account
     * @param loginId Login Id
     * @param {*} [options] Override http request options.
     */
    public getAccountRecovery (loginId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/recovery';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (loginId !== undefined) {
            localVarQueryParameters['loginId'] = ObjectSerializer.serialize(loginId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RecoveryApiApiKeys {
    JWT,
}

export class RecoveryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RecoveryApiApiKeys, value: string) {
        (this.authentications as any)[RecoveryApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Recover an existing account
     * @param accountId Account ID
     * @param code Code
     * @param password New Password
     * @param {*} [options] Override http request options.
     */
    public recoverAccount (accountId: string, code: string, password: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/recovery'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling recoverAccount.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling recoverAccount.');
        }

        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling recoverAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (code !== undefined) {
            localVarFormParams['code'] = ObjectSerializer.serialize(code, "string");
        }

        if (password !== undefined) {
            localVarFormParams['password'] = ObjectSerializer.serialize(password, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReferralsApiApiKeys {
    JWT,
}

export class ReferralsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReferralsApiApiKeys, value: string) {
        (this.authentications as any)[ReferralsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Sends a referral to the list of email addresses
     * @param accountId Account ID
     * @param referredUsers List of Referred Users, delimited by commas
     * @param {*} [options] Override http request options.
     */
    public addReferrals (accountId: string, referredUsers: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/referrals'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling addReferrals.');
        }

        // verify required parameter 'referredUsers' is not null or undefined
        if (referredUsers === null || referredUsers === undefined) {
            throw new Error('Required parameter referredUsers was null or undefined when calling addReferrals.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (referredUsers !== undefined) {
            localVarFormParams['referredUsers'] = ObjectSerializer.serialize(referredUsers, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the list of user referrals from this account
     * @param accountId Account ID
     * @param {*} [options] Override http request options.
     */
    public getReferrals (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ReferralDto>;  }> {
        const localVarPath = this.basePath + '/{accountId}/referrals'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getReferrals.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ReferralDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ReferralDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingViewsApiApiKeys {
    JWT,
}

export class ReportingViewsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportingViewsApiApiKeys, value: string) {
        (this.authentications as any)[ReportingViewsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new reporting view
     * @param accountId Account ID
     * @param name Reporting View Name
     * @param {*} [options] Override http request options.
     */
    public addReportingView (accountId: string, name: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ReportingViewDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/reportingViews'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling addReportingView.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addReportingView.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ReportingViewDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingViewDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new reporting view campaign
     * @param accountId Account ID
     * @param reportingView Reporting View ID
     * @param campaign Campaign Id
     * @param {*} [options] Override http request options.
     */
    public addReportingViewCampaign (accountId: string, reportingView: string, campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/reportingViews/{reportingView}/campaigns'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'reportingView' + '}', encodeURIComponent(String(reportingView)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling addReportingViewCampaign.');
        }

        // verify required parameter 'reportingView' is not null or undefined
        if (reportingView === null || reportingView === undefined) {
            throw new Error('Required parameter reportingView was null or undefined when calling addReportingViewCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addReportingViewCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (campaign !== undefined) {
            localVarFormParams['campaign'] = ObjectSerializer.serialize(campaign, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a reporting view
     * @param accountId Account ID
     * @param reportingView Reporting View ID
     * @param {*} [options] Override http request options.
     */
    public deleteReportingView (accountId: string, reportingView: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/reportingViews/{reportingView}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'reportingView' + '}', encodeURIComponent(String(reportingView)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteReportingView.');
        }

        // verify required parameter 'reportingView' is not null or undefined
        if (reportingView === null || reportingView === undefined) {
            throw new Error('Required parameter reportingView was null or undefined when calling deleteReportingView.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a reporting view campaign
     * @param accountId Account ID
     * @param reportingView Reporting View ID
     * @param campaign Campaign Id
     * @param {*} [options] Override http request options.
     */
    public deleteReportingViewCampaign (accountId: string, reportingView: string, campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/reportingViews/{reportingView}/campaigns/{campaign}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'reportingView' + '}', encodeURIComponent(String(reportingView)))
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteReportingViewCampaign.');
        }

        // verify required parameter 'reportingView' is not null or undefined
        if (reportingView === null || reportingView === undefined) {
            throw new Error('Required parameter reportingView was null or undefined when calling deleteReportingViewCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteReportingViewCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a reporting view from a given account
     * @param accountId Account ID
     * @param reportingView Reporting View ID
     * @param {*} [options] Override http request options.
     */
    public getReportingView (accountId: string, reportingView: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ReportingViewDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/reportingViews/{reportingView}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'reportingView' + '}', encodeURIComponent(String(reportingView)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getReportingView.');
        }

        // verify required parameter 'reportingView' is not null or undefined
        if (reportingView === null || reportingView === undefined) {
            throw new Error('Required parameter reportingView was null or undefined when calling getReportingView.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ReportingViewDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingViewDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all reporting views from a given account
     * @param accountId Account ID
     * @param start Start Row
     * @param rows Number of Rows
     * @param {*} [options] Override http request options.
     */
    public getReportingViews (accountId: string, start: number, rows: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemsPageResponseReportingViewDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/reportingViews'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getReportingViews.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getReportingViews.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getReportingViews.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPageResponseReportingViewDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsPageResponseReportingViewDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a reporting view
     * @param accountId Account ID
     * @param reportingView Reporting View ID
     * @param name Reporting View Name
     * @param {*} [options] Override http request options.
     */
    public updateReportingView (accountId: string, reportingView: string, name: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ReportingViewDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/reportingViews/{reportingView}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'reportingView' + '}', encodeURIComponent(String(reportingView)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateReportingView.');
        }

        // verify required parameter 'reportingView' is not null or undefined
        if (reportingView === null || reportingView === undefined) {
            throw new Error('Required parameter reportingView was null or undefined when calling updateReportingView.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateReportingView.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ReportingViewDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingViewDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingViewsDatatableApiApiKeys {
    JWT,
}

export class ReportingViewsDatatableApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportingViewsDatatableApiApiKeys, value: string) {
        (this.authentications as any)[ReportingViewsDatatableApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves all reporting views for a given account
     * @param accountId Account ID
     * @param body Datatable Request
     * @param {*} [options] Override http request options.
     */
    public getReportingViews1 (accountId: string, body?: DataTablesInput, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DataTablesOutputReportingViewDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/reportingViews/datatable'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getReportingViews1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DataTablesInput")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataTablesOutputReportingViewDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataTablesOutputReportingViewDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RolesApiApiKeys {
    JWT,
}

export class RolesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RolesApiApiKeys, value: string) {
        (this.authentications as any)[RolesApiApiKeys[key]].apiKey = value;
    }
    /**
     * An Administrator can add a User, Merchant, Account Manager, Administrator, Data Analyst, Customer Service Officer or Marketing Analyst. An Account Manager can only add a User or Merchant.
     * @summary Adds a new role to the given account
     * @param account Account ID
     * @param type 1 &#x3D; User, 2 &#x3D; Merchant, 3 &#x3D; Account Manager, 4 &#x3D; Administrator, 5 &#x3D; Data Analyst, 6 &#x3D; Customer Service Officer, 7 &#x3D; Marketing Executive
     * @param merchant Merchant ID (Required when adding a Merchant Role. The Merchant Role will be assigned to the specified Merchant)
     * @param {*} [options] Override http request options.
     */
    public addAccountRole (account: string, type: 1 | 2 | 3 | 4 | 5 | 6 | 7, merchant?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RoleDto;  }> {
        const localVarPath = this.basePath + '/{account}/roles'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling addAccountRole.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling addAccountRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "1 | 2 | 3 | 4 | 5 | 6 | 7");
        }

        if (merchant !== undefined) {
            localVarFormParams['merchant'] = ObjectSerializer.serialize(merchant, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RoleDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RoleDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a role from a given account
     * @param account Account ID
     * @param role Role ID
     * @param {*} [options] Override http request options.
     */
    public deleteAccountRole (account: string, role: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{account}/roles/{role}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'role' + '}', encodeURIComponent(String(role)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling deleteAccountRole.');
        }

        // verify required parameter 'role' is not null or undefined
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling deleteAccountRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SessionApiApiKeys {
    JWT,
}

export class SessionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SessionApiApiKeys, value: string) {
        (this.authentications as any)[SessionApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param apiKey 
     * @param {*} [options] Override http request options.
     */
    public getApiKeySession (apiKey: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AccountBySession;  }> {
        const localVarPath = this.basePath + '/session/apiKey/{apiKey}'
            .replace('{' + 'apiKey' + '}', encodeURIComponent(String(apiKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling getApiKeySession.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountBySession;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountBySession");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param bearerToken 
     * @param {*} [options] Override http request options.
     */
    public getBearerTokenSession (bearerToken: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AccountBySession;  }> {
        const localVarPath = this.basePath + '/session/bearerToken/{bearerToken}'
            .replace('{' + 'bearerToken' + '}', encodeURIComponent(String(bearerToken)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'bearerToken' is not null or undefined
        if (bearerToken === null || bearerToken === undefined) {
            throw new Error('Required parameter bearerToken was null or undefined when calling getBearerTokenSession.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountBySession;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountBySession");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param refreshToken Refresh Token
     * @param {*} [options] Override http request options.
     */
    public refresh (refreshToken: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AccountSessionDto;  }> {
        const localVarPath = this.basePath + '/session';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'refreshToken' is not null or undefined
        if (refreshToken === null || refreshToken === undefined) {
            throw new Error('Required parameter refreshToken was null or undefined when calling refresh.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (refreshToken !== undefined) {
            localVarFormParams['refreshToken'] = ObjectSerializer.serialize(refreshToken, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountSessionDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountSessionDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SsoApiApiKeys {
    JWT,
}

export class SsoApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SsoApiApiKeys, value: string) {
        (this.authentications as any)[SsoApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new single sign-on client
     * @param name Client Name
     * @param {*} [options] Override http request options.
     */
    public addSingleSignOnClient (name: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SingleSignOnClientDto;  }> {
        const localVarPath = this.basePath + '/sso/clients';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addSingleSignOnClient.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SingleSignOnClientDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleSignOnClientDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the single sign-on client with the given id
     * @param client Client Id
     * @param {*} [options] Override http request options.
     */
    public deleteSingleSignOnClient (client: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/sso/clients/{client}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling deleteSingleSignOnClient.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the single sign-on client with the given id
     * @param client Client Id
     * @param {*} [options] Override http request options.
     */
    public getSingleSignOnClient (client: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SingleSignOnClientDto;  }> {
        const localVarPath = this.basePath + '/sso/clients/{client}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling getSingleSignOnClient.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SingleSignOnClientDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleSignOnClientDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the single sign-on clients from an account
     * @param start Start Row
     * @param rows Number of Rows
     * @param {*} [options] Override http request options.
     */
    public getSingleSignOnClients (start: number, rows: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemsPageResponseSingleSignOnClientDto;  }> {
        const localVarPath = this.basePath + '/sso/clients';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getSingleSignOnClients.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getSingleSignOnClients.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPageResponseSingleSignOnClientDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsPageResponseSingleSignOnClientDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a single sign-on client
     * @param client Client Id
     * @param name Client Name
     * @param refreshClientSecret Refresh Client Secret
     * @param {*} [options] Override http request options.
     */
    public updateSingleSignOnClient (client: string, name: string, refreshClientSecret?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SingleSignOnClientDto;  }> {
        const localVarPath = this.basePath + '/sso/clients/{client}'
            .replace('{' + 'client' + '}', encodeURIComponent(String(client)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'client' is not null or undefined
        if (client === null || client === undefined) {
            throw new Error('Required parameter client was null or undefined when calling updateSingleSignOnClient.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateSingleSignOnClient.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (refreshClientSecret !== undefined) {
            localVarFormParams['refreshClientSecret'] = ObjectSerializer.serialize(refreshClientSecret, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SingleSignOnClientDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleSignOnClientDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ThirdpartyloginsApiApiKeys {
    JWT,
}

export class ThirdpartyloginsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ThirdpartyloginsApiApiKeys, value: string) {
        (this.authentications as any)[ThirdpartyloginsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new third party login to an account
     * @param accountId Account ID
     * @param thirdPartyId 1 &#x3D; Facebook, 2 &#x3D; Spotify, 3 &#x3D; Google, 4 &#x3D; Hapz Single Sign-On
     * @param accessToken Access Token when using third party login
     * @param idToken ID Token when using third party login
     * @param refreshToken Refresh Token when using third party login
     * @param {*} [options] Override http request options.
     */
    public addThirdPartyLogin (accountId: string, thirdPartyId: 1 | 2 | 3 | 4, accessToken?: string, idToken?: string, refreshToken?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ThirdPartyLoginDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/thirdpartylogins'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling addThirdPartyLogin.');
        }

        // verify required parameter 'thirdPartyId' is not null or undefined
        if (thirdPartyId === null || thirdPartyId === undefined) {
            throw new Error('Required parameter thirdPartyId was null or undefined when calling addThirdPartyLogin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (thirdPartyId !== undefined) {
            localVarFormParams['thirdPartyId'] = ObjectSerializer.serialize(thirdPartyId, "1 | 2 | 3 | 4");
        }

        if (accessToken !== undefined) {
            localVarFormParams['accessToken'] = ObjectSerializer.serialize(accessToken, "string");
        }

        if (idToken !== undefined) {
            localVarFormParams['idToken'] = ObjectSerializer.serialize(idToken, "string");
        }

        if (refreshToken !== undefined) {
            localVarFormParams['refreshToken'] = ObjectSerializer.serialize(refreshToken, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ThirdPartyLoginDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ThirdPartyLoginDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a third party login from an account
     * @param accountId Account ID
     * @param thirdParty 1 &#x3D; Facebook, 2 &#x3D; Spotify, 3 &#x3D; Google
     * @param {*} [options] Override http request options.
     */
    public deleteThirdPartyLogin (accountId: string, thirdParty: 1 | 2 | 3, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{accountId}/thirdpartylogins/{thirdParty}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'thirdParty' + '}', encodeURIComponent(String(thirdParty)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteThirdPartyLogin.');
        }

        // verify required parameter 'thirdParty' is not null or undefined
        if (thirdParty === null || thirdParty === undefined) {
            throw new Error('Required parameter thirdParty was null or undefined when calling deleteThirdPartyLogin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all the third party logins from an account
     * @param accountId Account ID
     * @param {*} [options] Override http request options.
     */
    public getThirdPartyLogins (accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ThirdPartyLoginDto>;  }> {
        const localVarPath = this.basePath + '/{accountId}/thirdpartylogins'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getThirdPartyLogins.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ThirdPartyLoginDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ThirdPartyLoginDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all third party logins using the given filters
     * @param thirdParty 1 &#x3D; Facebook, 2 &#x3D; Spotify, 3 &#x3D; Google
     * @param thirdPartyUserId Third Party User Id
     * @param {*} [options] Override http request options.
     */
    public search (thirdParty: 1 | 2 | 3, thirdPartyUserId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ThirdPartyLoginDto>;  }> {
        const localVarPath = this.basePath + '/thirdpartylogins';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thirdParty' is not null or undefined
        if (thirdParty === null || thirdParty === undefined) {
            throw new Error('Required parameter thirdParty was null or undefined when calling search.');
        }

        // verify required parameter 'thirdPartyUserId' is not null or undefined
        if (thirdPartyUserId === null || thirdPartyUserId === undefined) {
            throw new Error('Required parameter thirdPartyUserId was null or undefined when calling search.');
        }

        if (thirdParty !== undefined) {
            localVarQueryParameters['thirdParty'] = ObjectSerializer.serialize(thirdParty, "1 | 2 | 3");
        }

        if (thirdPartyUserId !== undefined) {
            localVarQueryParameters['thirdPartyUserId'] = ObjectSerializer.serialize(thirdPartyUserId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ThirdPartyLoginDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ThirdPartyLoginDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionsApiApiKeys {
    JWT,
}

export class TransactionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionsApiApiKeys, value: string) {
        (this.authentications as any)[TransactionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add an empty transaction to an account
     * @param accountId Account ID
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     * @param utmContent 
     * @param utmTerm 
     * @param referrerUrl 
     * @param cart 
     * @param {*} [options] Override http request options.
     */
    public addAccountTransaction (accountId: string, utmCampaign?: string, utmSource?: string, utmMedium?: string, utmContent?: string, utmTerm?: string, referrerUrl?: string, cart?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionDto;  }> {
        const localVarPath = this.basePath + '/{accountId}/transactions'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling addAccountTransaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (utmCampaign !== undefined) {
            localVarFormParams['utmCampaign'] = ObjectSerializer.serialize(utmCampaign, "string");
        }

        if (utmSource !== undefined) {
            localVarFormParams['utmSource'] = ObjectSerializer.serialize(utmSource, "string");
        }

        if (utmMedium !== undefined) {
            localVarFormParams['utmMedium'] = ObjectSerializer.serialize(utmMedium, "string");
        }

        if (utmContent !== undefined) {
            localVarFormParams['utmContent'] = ObjectSerializer.serialize(utmContent, "string");
        }

        if (utmTerm !== undefined) {
            localVarFormParams['utmTerm'] = ObjectSerializer.serialize(utmTerm, "string");
        }

        if (referrerUrl !== undefined) {
            localVarFormParams['referrerUrl'] = ObjectSerializer.serialize(referrerUrl, "string");
        }

        if (cart !== undefined) {
            localVarFormParams['cart'] = ObjectSerializer.serialize(cart, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the transactions from an account
     * @param accountId Account ID
     * @param start Start Row
     * @param rows Number of Rows
     * @param type (Optional) 1 &#x3D; Retrieve all transactions, 2 &#x3D; Retrieve successful transactions, 3 &#x3D; Retrieve active transactions
     * @param {*} [options] Override http request options.
     */
    public getAccountTransactions (accountId: string, start: number, rows: number, type?: 1 | 2 | 3, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TransactionDto>;  }> {
        const localVarPath = this.basePath + '/{accountId}/transactions'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountTransactions.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getAccountTransactions.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getAccountTransactions.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "1 | 2 | 3");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TransactionDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
