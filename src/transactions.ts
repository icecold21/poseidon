/**
 * Hapz Transaction API
 * This is the Transaction API for Hapz.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest from 'request'
import http from 'http'
import Promise from 'bluebird';

let defaultBasePath = process.env.TRANSACTION_MANAGEMENT_SERVICE_API!

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AddOn {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddOn.attributeTypeMap;
    }
}

export class AddOnOption {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'name'?: string;
    'image'?: string;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddOnOption.attributeTypeMap;
    }
}

export class AddTransactionRequest {
    'currency'?: string;
    'cart'?: boolean;
    'firstName'?: string;
    'lastName'?: string;
    'emailAddress'?: string;
    'contactNo'?: string;
    'owner'?: string;
    'utmCampaign'?: string;
    'utmSource'?: string;
    'utmMedium'?: string;
    'utmContent'?: string;
    'utmTerm'?: string;
    'referrerUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "cart",
            "baseName": "cart",
            "type": "boolean"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "contactNo",
            "baseName": "contactNo",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "utmCampaign",
            "baseName": "utmCampaign",
            "type": "string"
        },
        {
            "name": "utmSource",
            "baseName": "utmSource",
            "type": "string"
        },
        {
            "name": "utmMedium",
            "baseName": "utmMedium",
            "type": "string"
        },
        {
            "name": "utmContent",
            "baseName": "utmContent",
            "type": "string"
        },
        {
            "name": "utmTerm",
            "baseName": "utmTerm",
            "type": "string"
        },
        {
            "name": "referrerUrl",
            "baseName": "referrerUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddTransactionRequest.attributeTypeMap;
    }
}

export class Campaign {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'aliasId'?: string;
    'name'?: string;
    'description'?: string;
    'category'?: CampaignCategory;
    'subcategory'?: CampaignSubcategory;
    'bannerImage1800x562'?: string;
    'bannerImage800x533'?: string;
    'currency'?: string;
    'merchant'?: CampaignMerchant;
    'termsAndConditions'?: string;
    'creditsPercentage'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "aliasId",
            "baseName": "aliasId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "CampaignCategory"
        },
        {
            "name": "subcategory",
            "baseName": "subcategory",
            "type": "CampaignSubcategory"
        },
        {
            "name": "bannerImage1800x562",
            "baseName": "bannerImage1800x562",
            "type": "string"
        },
        {
            "name": "bannerImage800x533",
            "baseName": "bannerImage800x533",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "merchant",
            "baseName": "merchant",
            "type": "CampaignMerchant"
        },
        {
            "name": "termsAndConditions",
            "baseName": "termsAndConditions",
            "type": "string"
        },
        {
            "name": "creditsPercentage",
            "baseName": "creditsPercentage",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Campaign.attributeTypeMap;
    }
}

export class CampaignCategory {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'name'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignCategory.attributeTypeMap;
    }
}

export class CampaignDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'aliasId'?: string;
    'name'?: string;
    'description'?: string;
    'categoryId'?: string;
    'categoryName'?: string;
    'categoryUrl'?: string;
    'subcategoryId'?: string;
    'subcategoryName'?: string;
    'bannerImage1800x562'?: string;
    'bannerImage800x533'?: string;
    'currency'?: string;
    'termsAndConditions'?: string;
    'creditsPercentage'?: number;
    'merchant'?: CampaignMerchantDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "aliasId",
            "baseName": "aliasId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "string"
        },
        {
            "name": "categoryName",
            "baseName": "categoryName",
            "type": "string"
        },
        {
            "name": "categoryUrl",
            "baseName": "categoryUrl",
            "type": "string"
        },
        {
            "name": "subcategoryId",
            "baseName": "subcategoryId",
            "type": "string"
        },
        {
            "name": "subcategoryName",
            "baseName": "subcategoryName",
            "type": "string"
        },
        {
            "name": "bannerImage1800x562",
            "baseName": "bannerImage1800x562",
            "type": "string"
        },
        {
            "name": "bannerImage800x533",
            "baseName": "bannerImage800x533",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "termsAndConditions",
            "baseName": "termsAndConditions",
            "type": "string"
        },
        {
            "name": "creditsPercentage",
            "baseName": "creditsPercentage",
            "type": "number"
        },
        {
            "name": "merchant",
            "baseName": "merchant",
            "type": "CampaignMerchantDto"
        }    ];

    static getAttributeTypeMap() {
        return CampaignDto.attributeTypeMap;
    }
}

export class CampaignMerchant {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'name'?: string;
    'facebookPixelId'?: string;
    'googleAnalyticsPixelId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "facebookPixelId",
            "baseName": "facebookPixelId",
            "type": "string"
        },
        {
            "name": "googleAnalyticsPixelId",
            "baseName": "googleAnalyticsPixelId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignMerchant.attributeTypeMap;
    }
}

export class CampaignMerchantDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'facebookPixelId'?: string;
    'googleAnalyticsPixelId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "facebookPixelId",
            "baseName": "facebookPixelId",
            "type": "string"
        },
        {
            "name": "googleAnalyticsPixelId",
            "baseName": "googleAnalyticsPixelId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignMerchantDto.attributeTypeMap;
    }
}

export class CampaignSubcategory {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignSubcategory.attributeTypeMap;
    }
}

export class CampaignTimeslot {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'pricingPackage'?: PricingPackage;
    'startDateTime'?: Date;
    'startDateTimeOffset'?: string;
    'endDateTime'?: Date;
    'endDateTimeOffset'?: string;
    'location'?: Location;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "pricingPackage",
            "baseName": "pricingPackage",
            "type": "PricingPackage"
        },
        {
            "name": "startDateTime",
            "baseName": "startDateTime",
            "type": "Date"
        },
        {
            "name": "startDateTimeOffset",
            "baseName": "startDateTimeOffset",
            "type": "string"
        },
        {
            "name": "endDateTime",
            "baseName": "endDateTime",
            "type": "Date"
        },
        {
            "name": "endDateTimeOffset",
            "baseName": "endDateTimeOffset",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "Location"
        }    ];

    static getAttributeTypeMap() {
        return CampaignTimeslot.attributeTypeMap;
    }
}

export class CampaignTimeslotDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'pricingPackageId'?: string;
    'pricingPackageName'?: string;
    'startDateTime'?: Date;
    'startDateTimeOffset'?: string;
    'endDateTime'?: Date;
    'endDateTimeOffset'?: string;
    'location'?: LocationDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "pricingPackageId",
            "baseName": "pricingPackageId",
            "type": "string"
        },
        {
            "name": "pricingPackageName",
            "baseName": "pricingPackageName",
            "type": "string"
        },
        {
            "name": "startDateTime",
            "baseName": "startDateTime",
            "type": "Date"
        },
        {
            "name": "startDateTimeOffset",
            "baseName": "startDateTimeOffset",
            "type": "string"
        },
        {
            "name": "endDateTime",
            "baseName": "endDateTime",
            "type": "Date"
        },
        {
            "name": "endDateTimeOffset",
            "baseName": "endDateTimeOffset",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "LocationDto"
        }    ];

    static getAttributeTypeMap() {
        return CampaignTimeslotDto.attributeTypeMap;
    }
}

export class CardIssuer {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CardIssuer.attributeTypeMap;
    }
}

export class GrabNotification {
    'txType'?: string;
    'partnerTxID'?: string;
    'txID'?: string;
    'origTxID'?: string;
    'amount'?: number;
    'currency'?: string;
    'status'?: string;
    'createdAt'?: Date;
    'completedAt'?: Date;
    'payload'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "txType",
            "baseName": "txType",
            "type": "string"
        },
        {
            "name": "partnerTxID",
            "baseName": "partnerTxID",
            "type": "string"
        },
        {
            "name": "txID",
            "baseName": "txID",
            "type": "string"
        },
        {
            "name": "origTxID",
            "baseName": "origTxID",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "completedAt",
            "baseName": "completedAt",
            "type": "Date"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GrabNotification.attributeTypeMap;
    }
}

export class Item {
    'campaign'?: string;
    'timeslot'?: string;
    'pricing'?: string;
    'price'?: number;
    'quantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "string"
        },
        {
            "name": "timeslot",
            "baseName": "timeslot",
            "type": "string"
        },
        {
            "name": "pricing",
            "baseName": "pricing",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Item.attributeTypeMap;
    }
}

export class Location {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'name'?: string;
    'postalAddress'?: string;
    'postalCode'?: string;
    'city'?: string;
    'state'?: string;
    'iso3166CountryCode'?: string;
    'latitude'?: number;
    'longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "postalAddress",
            "baseName": "postalAddress",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "iso3166CountryCode",
            "baseName": "iso3166CountryCode",
            "type": "string"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Location.attributeTypeMap;
    }
}

export class LocationDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'postalAddress'?: string;
    'postalCode'?: string;
    'city'?: string;
    'state'?: string;
    'iso3166CountryCode'?: string;
    'latitude'?: number;
    'longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "postalAddress",
            "baseName": "postalAddress",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "iso3166CountryCode",
            "baseName": "iso3166CountryCode",
            "type": "string"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LocationDto.attributeTypeMap;
    }
}

export class MerchantDistributionTransaction {
    'currency'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'emailAddress'?: string;
    'contactNumber'?: string;
    'expiredAt'?: Date;
    'items'?: Array<Item>;
    'owner'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "contactNumber",
            "baseName": "contactNumber",
            "type": "string"
        },
        {
            "name": "expiredAt",
            "baseName": "expiredAt",
            "type": "Date"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Item>"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MerchantDistributionTransaction.attributeTypeMap;
    }
}

export class PaymentRefund {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'payment'?: TransactionPayment;
    'transactionReference'?: string;
    'type'?: PaymentRefund.TypeEnum;
    'value'?: number;
    'valueInSGD'?: number;
    'feeInSGD'?: number;
    'currency'?: string;
    'refundedAt'?: Date;
    'itemRefunds'?: Array<TransactionItemPaymentRefund>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "payment",
            "baseName": "payment",
            "type": "TransactionPayment"
        },
        {
            "name": "transactionReference",
            "baseName": "transactionReference",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "PaymentRefund.TypeEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        },
        {
            "name": "feeInSGD",
            "baseName": "feeInSGD",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "refundedAt",
            "baseName": "refundedAt",
            "type": "Date"
        },
        {
            "name": "itemRefunds",
            "baseName": "itemRefunds",
            "type": "Array<TransactionItemPaymentRefund>"
        }    ];

    static getAttributeTypeMap() {
        return PaymentRefund.attributeTypeMap;
    }
}

export namespace PaymentRefund {
    export enum TypeEnum {
        REFUND = <any> 'REFUND',
        CHARGEBACK = <any> 'CHARGEBACK',
        CHARGEBACKDISPUTEWIN = <any> 'CHARGEBACK_DISPUTE_WIN',
        CHARGEADJUSTMENT = <any> 'CHARGE_ADJUSTMENT'
    }
}
export class PaymentRefundDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'transactionReference'?: string;
    'type'?: PaymentRefundDto.TypeEnum;
    'value'?: number;
    'valueInSGD'?: number;
    'feeInSGD'?: number;
    'currency'?: string;
    'refundedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "transactionReference",
            "baseName": "transactionReference",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "PaymentRefundDto.TypeEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        },
        {
            "name": "feeInSGD",
            "baseName": "feeInSGD",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "refundedAt",
            "baseName": "refundedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PaymentRefundDto.attributeTypeMap;
    }
}

export namespace PaymentRefundDto {
    export enum TypeEnum {
        REFUND = <any> 'REFUND',
        CHARGEBACK = <any> 'CHARGEBACK',
        CHARGEBACKDISPUTEWIN = <any> 'CHARGEBACK_DISPUTE_WIN',
        CHARGEADJUSTMENT = <any> 'CHARGE_ADJUSTMENT'
    }
}
export class Pricing {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'pricingCategory'?: PricingCategory;
    'entitlements'?: string;
    'ticketsIssuedPerInventory'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "pricingCategory",
            "baseName": "pricingCategory",
            "type": "PricingCategory"
        },
        {
            "name": "entitlements",
            "baseName": "entitlements",
            "type": "string"
        },
        {
            "name": "ticketsIssuedPerInventory",
            "baseName": "ticketsIssuedPerInventory",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Pricing.attributeTypeMap;
    }
}

export class PricingAddOn {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'addOn'?: AddOn;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "addOn",
            "baseName": "addOn",
            "type": "AddOn"
        }    ];

    static getAttributeTypeMap() {
        return PricingAddOn.attributeTypeMap;
    }
}

export class PricingAddOnOption {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'addOnOption'?: AddOnOption;
    'price'?: number;
    'currency'?: string;
    'bookingFee'?: number;
    'bookingFeeInPercent'?: boolean;
    'transactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "addOnOption",
            "baseName": "addOnOption",
            "type": "AddOnOption"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "bookingFeeInPercent",
            "baseName": "bookingFeeInPercent",
            "type": "boolean"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PricingAddOnOption.attributeTypeMap;
    }
}

export class PricingCardIssuer {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'cardIssuer'?: CardIssuer;
    'value'?: number;
    'currency'?: string;
    'percent'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "cardIssuer",
            "baseName": "cardIssuer",
            "type": "CardIssuer"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "percent",
            "baseName": "percent",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PricingCardIssuer.attributeTypeMap;
    }
}

export class PricingCardIssuerDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'cardIssuerId'?: string;
    'cardIssuerName'?: string;
    'value'?: number;
    'currency'?: string;
    'percent'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "cardIssuerId",
            "baseName": "cardIssuerId",
            "type": "string"
        },
        {
            "name": "cardIssuerName",
            "baseName": "cardIssuerName",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "percent",
            "baseName": "percent",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PricingCardIssuerDto.attributeTypeMap;
    }
}

export class PricingCategory {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PricingCategory.attributeTypeMap;
    }
}

export class PricingCategoryDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PricingCategoryDto.attributeTypeMap;
    }
}

export class PricingDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'pricingCategory'?: PricingCategoryDto;
    'entitlements'?: string;
    'ticketsIssuedPerInventory'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "pricingCategory",
            "baseName": "pricingCategory",
            "type": "PricingCategoryDto"
        },
        {
            "name": "entitlements",
            "baseName": "entitlements",
            "type": "string"
        },
        {
            "name": "ticketsIssuedPerInventory",
            "baseName": "ticketsIssuedPerInventory",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PricingDto.attributeTypeMap;
    }
}

export class PricingInterval {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'currency'?: string;
    'price'?: number;
    'costPrice'?: number;
    'bookingFee'?: number;
    'bookingFeeInPercent'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "costPrice",
            "baseName": "costPrice",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "bookingFeeInPercent",
            "baseName": "bookingFeeInPercent",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PricingInterval.attributeTypeMap;
    }
}

export class PricingIntervalDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'currency'?: string;
    'price'?: number;
    'costPrice'?: number;
    'bookingFee'?: number;
    'bookingFeeInPercent'?: boolean;
    'transactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "costPrice",
            "baseName": "costPrice",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "bookingFeeInPercent",
            "baseName": "bookingFeeInPercent",
            "type": "boolean"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PricingIntervalDto.attributeTypeMap;
    }
}

export class PricingPackage {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PricingPackage.attributeTypeMap;
    }
}

export class PromoCode {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'type'?: PromoCode.TypeEnum;
    'description'?: string;
    'code'?: string;
    'value'?: number;
    'minimumSpend'?: number;
    'minimumQuantity'?: number;
    'currency'?: string;
    'percent'?: boolean;
    'perQuantity'?: boolean;
    'maxQuantityRedemption'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "PromoCode.TypeEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "minimumSpend",
            "baseName": "minimumSpend",
            "type": "number"
        },
        {
            "name": "minimumQuantity",
            "baseName": "minimumQuantity",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "percent",
            "baseName": "percent",
            "type": "boolean"
        },
        {
            "name": "perQuantity",
            "baseName": "perQuantity",
            "type": "boolean"
        },
        {
            "name": "maxQuantityRedemption",
            "baseName": "maxQuantityRedemption",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PromoCode.attributeTypeMap;
    }
}

export namespace PromoCode {
    export enum TypeEnum {
        PARTNERCODE = <any> 'PARTNER_CODE',
        EMAILADDRESSDOMAINPARTNERPROMOTION = <any> 'EMAIL_ADDRESS_DOMAIN_PARTNER_PROMOTION',
        SPOTIFYPARTNERPROMOTION = <any> 'SPOTIFY_PARTNER_PROMOTION',
        MARKETINGCAMPAIGNPARTNERPROMOTION = <any> 'MARKETING_CAMPAIGN_PARTNER_PROMOTION',
        CORPORATESPARTNERPROMOTION = <any> 'CORPORATES_PARTNER_PROMOTION',
        ONEUSECODE = <any> 'ONE_USE_CODE'
    }
}
export class PromoCodeDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: PromoCodeDto.TypeEnum;
    'description'?: string;
    'code'?: string;
    'value'?: number;
    'minimumSpend'?: number;
    'minimumQuantity'?: number;
    'currency'?: string;
    'percent'?: boolean;
    'perQuantity'?: boolean;
    'maxQuantityRedemption'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "PromoCodeDto.TypeEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "minimumSpend",
            "baseName": "minimumSpend",
            "type": "number"
        },
        {
            "name": "minimumQuantity",
            "baseName": "minimumQuantity",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "percent",
            "baseName": "percent",
            "type": "boolean"
        },
        {
            "name": "perQuantity",
            "baseName": "perQuantity",
            "type": "boolean"
        },
        {
            "name": "maxQuantityRedemption",
            "baseName": "maxQuantityRedemption",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PromoCodeDto.attributeTypeMap;
    }
}

export namespace PromoCodeDto {
    export enum TypeEnum {
        PARTNERCODE = <any> 'PARTNER_CODE',
        EMAILADDRESSDOMAINPARTNERPROMOTION = <any> 'EMAIL_ADDRESS_DOMAIN_PARTNER_PROMOTION',
        SPOTIFYPARTNERPROMOTION = <any> 'SPOTIFY_PARTNER_PROMOTION',
        MARKETINGCAMPAIGNPARTNERPROMOTION = <any> 'MARKETING_CAMPAIGN_PARTNER_PROMOTION',
        CORPORATESPARTNERPROMOTION = <any> 'CORPORATES_PARTNER_PROMOTION',
        ONEUSECODE = <any> 'ONE_USE_CODE'
    }
}
export class Transaction {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'owner'?: string;
    'currency'?: string;
    'exchangeRateFromTransactionToSGD'?: number;
    'cart'?: boolean;
    'status'?: Transaction.StatusEnum;
    'firstName'?: string;
    'lastName'?: string;
    'emailAddress'?: string;
    'contactNo'?: string;
    'userTrafficChannel'?: Transaction.UserTrafficChannelEnum;
    'marketingOrDistributionTransaction'?: boolean;
    'utmCampaign'?: string;
    'utmSource'?: string;
    'utmMedium'?: string;
    'utmContent'?: string;
    'utmTerm'?: string;
    'referrerUrl'?: string;
    'expiresAt'?: Date;
    'approvedAt'?: Date;
    'manualReviewRequestedAt'?: Date;
    'manualReviewCompletedAt'?: Date;
    'manualReviewCompletedBy'?: string;
    'items'?: Array<TransactionItem>;
    'payments'?: Array<TransactionPayment>;
    'promoCodes'?: Array<TransactionPromoCode>;
    'creditsLedgers'?: Array<TransactionCreditsLedger>;
    'expired'?: boolean;
    'amount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "exchangeRateFromTransactionToSGD",
            "baseName": "exchangeRateFromTransactionToSGD",
            "type": "number"
        },
        {
            "name": "cart",
            "baseName": "cart",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Transaction.StatusEnum"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "contactNo",
            "baseName": "contactNo",
            "type": "string"
        },
        {
            "name": "userTrafficChannel",
            "baseName": "userTrafficChannel",
            "type": "Transaction.UserTrafficChannelEnum"
        },
        {
            "name": "marketingOrDistributionTransaction",
            "baseName": "marketingOrDistributionTransaction",
            "type": "boolean"
        },
        {
            "name": "utmCampaign",
            "baseName": "utmCampaign",
            "type": "string"
        },
        {
            "name": "utmSource",
            "baseName": "utmSource",
            "type": "string"
        },
        {
            "name": "utmMedium",
            "baseName": "utmMedium",
            "type": "string"
        },
        {
            "name": "utmContent",
            "baseName": "utmContent",
            "type": "string"
        },
        {
            "name": "utmTerm",
            "baseName": "utmTerm",
            "type": "string"
        },
        {
            "name": "referrerUrl",
            "baseName": "referrerUrl",
            "type": "string"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "approvedAt",
            "baseName": "approvedAt",
            "type": "Date"
        },
        {
            "name": "manualReviewRequestedAt",
            "baseName": "manualReviewRequestedAt",
            "type": "Date"
        },
        {
            "name": "manualReviewCompletedAt",
            "baseName": "manualReviewCompletedAt",
            "type": "Date"
        },
        {
            "name": "manualReviewCompletedBy",
            "baseName": "manualReviewCompletedBy",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<TransactionItem>"
        },
        {
            "name": "payments",
            "baseName": "payments",
            "type": "Array<TransactionPayment>"
        },
        {
            "name": "promoCodes",
            "baseName": "promoCodes",
            "type": "Array<TransactionPromoCode>"
        },
        {
            "name": "creditsLedgers",
            "baseName": "creditsLedgers",
            "type": "Array<TransactionCreditsLedger>"
        },
        {
            "name": "expired",
            "baseName": "expired",
            "type": "boolean"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Transaction.attributeTypeMap;
    }
}

export namespace Transaction {
    export enum StatusEnum {
        PAYMENTPENDING = <any> 'PAYMENT_PENDING',
        MANUALREVIEWPENDING = <any> 'MANUAL_REVIEW_PENDING',
        APPROVED = <any> 'APPROVED',
        DECLINED = <any> 'DECLINED'
    }
    export enum UserTrafficChannelEnum {
        DIRECT = <any> 'DIRECT',
        ORGANICSEARCH = <any> 'ORGANIC_SEARCH',
        PAIDSEARCH = <any> 'PAID_SEARCH',
        EMAIL = <any> 'EMAIL',
        SOCIAL = <any> 'SOCIAL',
        REFERRAL = <any> 'REFERRAL',
        OTHERS = <any> 'OTHERS'
    }
}
export class TransactionCreditsLedger {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'transaction'?: Transaction;
    'creditsLedger'?: string;
    'exchangeRateFromCreditsLedgerToTransaction'?: number;
    'value'?: number;
    'valueInSGD'?: number;
    'itemCreditsLedgers'?: Array<TransactionItemCreditsLedger>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "transaction",
            "baseName": "transaction",
            "type": "Transaction"
        },
        {
            "name": "creditsLedger",
            "baseName": "creditsLedger",
            "type": "string"
        },
        {
            "name": "exchangeRateFromCreditsLedgerToTransaction",
            "baseName": "exchangeRateFromCreditsLedgerToTransaction",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        },
        {
            "name": "itemCreditsLedgers",
            "baseName": "itemCreditsLedgers",
            "type": "Array<TransactionItemCreditsLedger>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionCreditsLedger.attributeTypeMap;
    }
}

export class TransactionCreditsLedgerDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'creditsLedger'?: string;
    'exchangeRateFromCreditsLedgerToTransaction'?: number;
    'value'?: number;
    'valueInSGD'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "creditsLedger",
            "baseName": "creditsLedger",
            "type": "string"
        },
        {
            "name": "exchangeRateFromCreditsLedgerToTransaction",
            "baseName": "exchangeRateFromCreditsLedgerToTransaction",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionCreditsLedgerDto.attributeTypeMap;
    }
}

export class TransactionDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'currency'?: string;
    'exchangeRateFromTransactionToSGD'?: number;
    'cart'?: boolean;
    'status'?: TransactionDto.StatusEnum;
    'firstName'?: string;
    'lastName'?: string;
    'emailAddress'?: string;
    'contactNo'?: string;
    'userTrafficChannel'?: TransactionDto.UserTrafficChannelEnum;
    'marketingOrDistributionTransaction'?: boolean;
    'utmCampaign'?: string;
    'utmSource'?: string;
    'utmMedium'?: string;
    'utmContent'?: string;
    'utmTerm'?: string;
    'referrerUrl'?: string;
    'expiresAt'?: Date;
    'expired'?: boolean;
    'paymentCompletedAt'?: Date;
    'items'?: Array<TransactionItemDto>;
    'payments'?: Array<TransactionPaymentDto>;
    'promoCodes'?: Array<TransactionPromoCodeDto>;
    'creditsLedgers'?: Array<TransactionCreditsLedgerDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "exchangeRateFromTransactionToSGD",
            "baseName": "exchangeRateFromTransactionToSGD",
            "type": "number"
        },
        {
            "name": "cart",
            "baseName": "cart",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "TransactionDto.StatusEnum"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "contactNo",
            "baseName": "contactNo",
            "type": "string"
        },
        {
            "name": "userTrafficChannel",
            "baseName": "userTrafficChannel",
            "type": "TransactionDto.UserTrafficChannelEnum"
        },
        {
            "name": "marketingOrDistributionTransaction",
            "baseName": "marketingOrDistributionTransaction",
            "type": "boolean"
        },
        {
            "name": "utmCampaign",
            "baseName": "utmCampaign",
            "type": "string"
        },
        {
            "name": "utmSource",
            "baseName": "utmSource",
            "type": "string"
        },
        {
            "name": "utmMedium",
            "baseName": "utmMedium",
            "type": "string"
        },
        {
            "name": "utmContent",
            "baseName": "utmContent",
            "type": "string"
        },
        {
            "name": "utmTerm",
            "baseName": "utmTerm",
            "type": "string"
        },
        {
            "name": "referrerUrl",
            "baseName": "referrerUrl",
            "type": "string"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "expired",
            "baseName": "expired",
            "type": "boolean"
        },
        {
            "name": "paymentCompletedAt",
            "baseName": "paymentCompletedAt",
            "type": "Date"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<TransactionItemDto>"
        },
        {
            "name": "payments",
            "baseName": "payments",
            "type": "Array<TransactionPaymentDto>"
        },
        {
            "name": "promoCodes",
            "baseName": "promoCodes",
            "type": "Array<TransactionPromoCodeDto>"
        },
        {
            "name": "creditsLedgers",
            "baseName": "creditsLedgers",
            "type": "Array<TransactionCreditsLedgerDto>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionDto.attributeTypeMap;
    }
}

export namespace TransactionDto {
    export enum StatusEnum {
        PAYMENTPENDING = <any> 'PAYMENT_PENDING',
        MANUALREVIEWPENDING = <any> 'MANUAL_REVIEW_PENDING',
        APPROVED = <any> 'APPROVED',
        DECLINED = <any> 'DECLINED'
    }
    export enum UserTrafficChannelEnum {
        DIRECT = <any> 'DIRECT',
        ORGANICSEARCH = <any> 'ORGANIC_SEARCH',
        PAIDSEARCH = <any> 'PAID_SEARCH',
        EMAIL = <any> 'EMAIL',
        SOCIAL = <any> 'SOCIAL',
        REFERRAL = <any> 'REFERRAL',
        OTHERS = <any> 'OTHERS'
    }
}
export class TransactionItem {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'transaction'?: Transaction;
    'status'?: TransactionItem.StatusEnum;
    'campaign'?: Campaign;
    'campaignTimeslot'?: CampaignTimeslot;
    'pricing'?: Pricing;
    'pricingInterval'?: PricingInterval;
    'pricingCardIssuer'?: PricingCardIssuer;
    'pricingInventoryLedger'?: string;
    'exchangeRateFromPricingToTransaction'?: number;
    'exchangeRateFromPricingToSGD'?: number;
    'exchangeRateFromPricingCardIssuerToTransaction'?: number;
    'exchangeRateFromTransactionFeeToTransaction'?: number;
    'price'?: number;
    'quantity'?: number;
    'bookingFee'?: number;
    'transactionFee'?: number;
    'fixedTransactionFee'?: number;
    'variableTransactionFee'?: number;
    'transactionFeeChargedToUser'?: boolean;
    'pricingCardIssuerValue'?: number;
    'pricingCardIssuerValueInSGD'?: number;
    'pricingCardIssuerValueCreditedToHapz'?: boolean;
    'priceDifferenceValue'?: number;
    'priceDifferenceValueInSGD'?: number;
    'priceDifferenceValueCreditedToHapz'?: boolean;
    'forexGainOrLossValueInSGD'?: number;
    'invalidatedAt'?: Date;
    'invalidatedBy'?: string;
    'registrants'?: Array<TransactionItemRegistrant>;
    'addOns'?: Array<TransactionItemAddOn>;
    'creditsLedgers'?: Array<TransactionItemCreditsLedger>;
    'promoCodes'?: Array<TransactionItemPromoCode>;
    'payments'?: Array<TransactionItemPayment>;
    'refunds'?: Array<TransactionItemPaymentRefund>;
    'eligibleRefundAmount'?: number;
    'chargeableAmount'?: number;
    'refundedAmount'?: number;
    'creditsAmount'?: number;
    'promoCodeAmount'?: number;
    'eligibleRefundAmountInSGD'?: number;
    'applicableCreditsAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "transaction",
            "baseName": "transaction",
            "type": "Transaction"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "TransactionItem.StatusEnum"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "Campaign"
        },
        {
            "name": "campaignTimeslot",
            "baseName": "campaignTimeslot",
            "type": "CampaignTimeslot"
        },
        {
            "name": "pricing",
            "baseName": "pricing",
            "type": "Pricing"
        },
        {
            "name": "pricingInterval",
            "baseName": "pricingInterval",
            "type": "PricingInterval"
        },
        {
            "name": "pricingCardIssuer",
            "baseName": "pricingCardIssuer",
            "type": "PricingCardIssuer"
        },
        {
            "name": "pricingInventoryLedger",
            "baseName": "pricingInventoryLedger",
            "type": "string"
        },
        {
            "name": "exchangeRateFromPricingToTransaction",
            "baseName": "exchangeRateFromPricingToTransaction",
            "type": "number"
        },
        {
            "name": "exchangeRateFromPricingToSGD",
            "baseName": "exchangeRateFromPricingToSGD",
            "type": "number"
        },
        {
            "name": "exchangeRateFromPricingCardIssuerToTransaction",
            "baseName": "exchangeRateFromPricingCardIssuerToTransaction",
            "type": "number"
        },
        {
            "name": "exchangeRateFromTransactionFeeToTransaction",
            "baseName": "exchangeRateFromTransactionFeeToTransaction",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        },
        {
            "name": "fixedTransactionFee",
            "baseName": "fixedTransactionFee",
            "type": "number"
        },
        {
            "name": "variableTransactionFee",
            "baseName": "variableTransactionFee",
            "type": "number"
        },
        {
            "name": "transactionFeeChargedToUser",
            "baseName": "transactionFeeChargedToUser",
            "type": "boolean"
        },
        {
            "name": "pricingCardIssuerValue",
            "baseName": "pricingCardIssuerValue",
            "type": "number"
        },
        {
            "name": "pricingCardIssuerValueInSGD",
            "baseName": "pricingCardIssuerValueInSGD",
            "type": "number"
        },
        {
            "name": "pricingCardIssuerValueCreditedToHapz",
            "baseName": "pricingCardIssuerValueCreditedToHapz",
            "type": "boolean"
        },
        {
            "name": "priceDifferenceValue",
            "baseName": "priceDifferenceValue",
            "type": "number"
        },
        {
            "name": "priceDifferenceValueInSGD",
            "baseName": "priceDifferenceValueInSGD",
            "type": "number"
        },
        {
            "name": "priceDifferenceValueCreditedToHapz",
            "baseName": "priceDifferenceValueCreditedToHapz",
            "type": "boolean"
        },
        {
            "name": "forexGainOrLossValueInSGD",
            "baseName": "forexGainOrLossValueInSGD",
            "type": "number"
        },
        {
            "name": "invalidatedAt",
            "baseName": "invalidatedAt",
            "type": "Date"
        },
        {
            "name": "invalidatedBy",
            "baseName": "invalidatedBy",
            "type": "string"
        },
        {
            "name": "registrants",
            "baseName": "registrants",
            "type": "Array<TransactionItemRegistrant>"
        },
        {
            "name": "addOns",
            "baseName": "addOns",
            "type": "Array<TransactionItemAddOn>"
        },
        {
            "name": "creditsLedgers",
            "baseName": "creditsLedgers",
            "type": "Array<TransactionItemCreditsLedger>"
        },
        {
            "name": "promoCodes",
            "baseName": "promoCodes",
            "type": "Array<TransactionItemPromoCode>"
        },
        {
            "name": "payments",
            "baseName": "payments",
            "type": "Array<TransactionItemPayment>"
        },
        {
            "name": "refunds",
            "baseName": "refunds",
            "type": "Array<TransactionItemPaymentRefund>"
        },
        {
            "name": "eligibleRefundAmount",
            "baseName": "eligibleRefundAmount",
            "type": "number"
        },
        {
            "name": "chargeableAmount",
            "baseName": "chargeableAmount",
            "type": "number"
        },
        {
            "name": "refundedAmount",
            "baseName": "refundedAmount",
            "type": "number"
        },
        {
            "name": "creditsAmount",
            "baseName": "creditsAmount",
            "type": "number"
        },
        {
            "name": "promoCodeAmount",
            "baseName": "promoCodeAmount",
            "type": "number"
        },
        {
            "name": "eligibleRefundAmountInSGD",
            "baseName": "eligibleRefundAmountInSGD",
            "type": "number"
        },
        {
            "name": "applicableCreditsAmount",
            "baseName": "applicableCreditsAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItem.attributeTypeMap;
    }
}

export namespace TransactionItem {
    export enum StatusEnum {
        ADDEDTOTRANSACTION = <any> 'ADDED_TO_TRANSACTION',
        FULFILMENTPENDING = <any> 'FULFILMENT_PENDING',
        FULFILMENTCOMPLETED = <any> 'FULFILMENT_COMPLETED'
    }
}
export class TransactionItemAddOn {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'transactionItem'?: TransactionItem;
    'pricingAddOn'?: PricingAddOn;
    'pricingAddOnOption'?: PricingAddOnOption;
    'pricingAddOnOptionInventoryLedger'?: string;
    'exchangeRateFromPricingAddOnToTransaction'?: number;
    'price'?: number;
    'quantity'?: number;
    'bookingFee'?: number;
    'transactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "transactionItem",
            "baseName": "transactionItem",
            "type": "TransactionItem"
        },
        {
            "name": "pricingAddOn",
            "baseName": "pricingAddOn",
            "type": "PricingAddOn"
        },
        {
            "name": "pricingAddOnOption",
            "baseName": "pricingAddOnOption",
            "type": "PricingAddOnOption"
        },
        {
            "name": "pricingAddOnOptionInventoryLedger",
            "baseName": "pricingAddOnOptionInventoryLedger",
            "type": "string"
        },
        {
            "name": "exchangeRateFromPricingAddOnToTransaction",
            "baseName": "exchangeRateFromPricingAddOnToTransaction",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemAddOn.attributeTypeMap;
    }
}

export class TransactionItemAddOnDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'pricingAddOn'?: string;
    'pricingAddOnOption'?: string;
    'pricingAddOnOptionInventoryLedger'?: string;
    'exchangeRateFromPricingAddOnToTransaction'?: number;
    'price'?: number;
    'quantity'?: number;
    'bookingFee'?: number;
    'transactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "pricingAddOn",
            "baseName": "pricingAddOn",
            "type": "string"
        },
        {
            "name": "pricingAddOnOption",
            "baseName": "pricingAddOnOption",
            "type": "string"
        },
        {
            "name": "pricingAddOnOptionInventoryLedger",
            "baseName": "pricingAddOnOptionInventoryLedger",
            "type": "string"
        },
        {
            "name": "exchangeRateFromPricingAddOnToTransaction",
            "baseName": "exchangeRateFromPricingAddOnToTransaction",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemAddOnDto.attributeTypeMap;
    }
}

export class TransactionItemCreditsLedger {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'transactionItem'?: TransactionItem;
    'transactionCreditsLedger'?: TransactionCreditsLedger;
    'value'?: number;
    'valueInSGD'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "transactionItem",
            "baseName": "transactionItem",
            "type": "TransactionItem"
        },
        {
            "name": "transactionCreditsLedger",
            "baseName": "transactionCreditsLedger",
            "type": "TransactionCreditsLedger"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemCreditsLedger.attributeTypeMap;
    }
}

export class TransactionItemDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'status'?: TransactionItemDto.StatusEnum;
    'campaign'?: CampaignDto;
    'campaignTimeslot'?: CampaignTimeslotDto;
    'pricing'?: PricingDto;
    'pricingInterval'?: PricingIntervalDto;
    'pricingCardIssuer'?: PricingCardIssuerDto;
    'pricingInventoryLedger'?: string;
    'price'?: number;
    'quantity'?: number;
    'exchangeRateFromPricingToTransaction'?: number;
    'bookingFee'?: number;
    'transactionFee'?: number;
    'fixedTransactionFee'?: number;
    'variableTransactionFee'?: number;
    'transactionFeeChargedToUser'?: boolean;
    'pricingCardIssuerValue'?: number;
    'pricingCardIssuerValueInSGD'?: number;
    'pricingCardIssuerValueCreditedToHapz'?: boolean;
    'priceDifferenceValue'?: number;
    'priceDifferenceValueInSGD'?: number;
    'priceDifferenceValueCreditedToHapz'?: boolean;
    'forexGainOrLossValueInSGD'?: number;
    'invalidatedAt'?: Date;
    'invalidatedBy'?: string;
    'registrants'?: Array<TransactionItemRegistrantDto>;
    'addOns'?: Array<TransactionItemAddOnDto>;
    'eligibleRefundAmount'?: number;
    'chargeableAmount'?: number;
    'refundedAmount'?: number;
    'creditsAmount'?: number;
    'promoCodeAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "TransactionItemDto.StatusEnum"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "CampaignDto"
        },
        {
            "name": "campaignTimeslot",
            "baseName": "campaignTimeslot",
            "type": "CampaignTimeslotDto"
        },
        {
            "name": "pricing",
            "baseName": "pricing",
            "type": "PricingDto"
        },
        {
            "name": "pricingInterval",
            "baseName": "pricingInterval",
            "type": "PricingIntervalDto"
        },
        {
            "name": "pricingCardIssuer",
            "baseName": "pricingCardIssuer",
            "type": "PricingCardIssuerDto"
        },
        {
            "name": "pricingInventoryLedger",
            "baseName": "pricingInventoryLedger",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "exchangeRateFromPricingToTransaction",
            "baseName": "exchangeRateFromPricingToTransaction",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        },
        {
            "name": "fixedTransactionFee",
            "baseName": "fixedTransactionFee",
            "type": "number"
        },
        {
            "name": "variableTransactionFee",
            "baseName": "variableTransactionFee",
            "type": "number"
        },
        {
            "name": "transactionFeeChargedToUser",
            "baseName": "transactionFeeChargedToUser",
            "type": "boolean"
        },
        {
            "name": "pricingCardIssuerValue",
            "baseName": "pricingCardIssuerValue",
            "type": "number"
        },
        {
            "name": "pricingCardIssuerValueInSGD",
            "baseName": "pricingCardIssuerValueInSGD",
            "type": "number"
        },
        {
            "name": "pricingCardIssuerValueCreditedToHapz",
            "baseName": "pricingCardIssuerValueCreditedToHapz",
            "type": "boolean"
        },
        {
            "name": "priceDifferenceValue",
            "baseName": "priceDifferenceValue",
            "type": "number"
        },
        {
            "name": "priceDifferenceValueInSGD",
            "baseName": "priceDifferenceValueInSGD",
            "type": "number"
        },
        {
            "name": "priceDifferenceValueCreditedToHapz",
            "baseName": "priceDifferenceValueCreditedToHapz",
            "type": "boolean"
        },
        {
            "name": "forexGainOrLossValueInSGD",
            "baseName": "forexGainOrLossValueInSGD",
            "type": "number"
        },
        {
            "name": "invalidatedAt",
            "baseName": "invalidatedAt",
            "type": "Date"
        },
        {
            "name": "invalidatedBy",
            "baseName": "invalidatedBy",
            "type": "string"
        },
        {
            "name": "registrants",
            "baseName": "registrants",
            "type": "Array<TransactionItemRegistrantDto>"
        },
        {
            "name": "addOns",
            "baseName": "addOns",
            "type": "Array<TransactionItemAddOnDto>"
        },
        {
            "name": "eligibleRefundAmount",
            "baseName": "eligibleRefundAmount",
            "type": "number"
        },
        {
            "name": "chargeableAmount",
            "baseName": "chargeableAmount",
            "type": "number"
        },
        {
            "name": "refundedAmount",
            "baseName": "refundedAmount",
            "type": "number"
        },
        {
            "name": "creditsAmount",
            "baseName": "creditsAmount",
            "type": "number"
        },
        {
            "name": "promoCodeAmount",
            "baseName": "promoCodeAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemDto.attributeTypeMap;
    }
}

export namespace TransactionItemDto {
    export enum StatusEnum {
        ADDEDTOTRANSACTION = <any> 'ADDED_TO_TRANSACTION',
        FULFILMENTPENDING = <any> 'FULFILMENT_PENDING',
        FULFILMENTCOMPLETED = <any> 'FULFILMENT_COMPLETED'
    }
}
export class TransactionItemPayment {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'transactionItem'?: TransactionItem;
    'payment'?: TransactionPayment;
    'value'?: number;
    'valueInSGD'?: number;
    'feeInSGD'?: number;
    'eligibleRefundAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "transactionItem",
            "baseName": "transactionItem",
            "type": "TransactionItem"
        },
        {
            "name": "payment",
            "baseName": "payment",
            "type": "TransactionPayment"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        },
        {
            "name": "feeInSGD",
            "baseName": "feeInSGD",
            "type": "number"
        },
        {
            "name": "eligibleRefundAmount",
            "baseName": "eligibleRefundAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemPayment.attributeTypeMap;
    }
}

export class TransactionItemPaymentRefund {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'transactionItem'?: TransactionItem;
    'paymentRefund'?: PaymentRefund;
    'value'?: number;
    'valueInSGD'?: number;
    'feeInSGD'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "transactionItem",
            "baseName": "transactionItem",
            "type": "TransactionItem"
        },
        {
            "name": "paymentRefund",
            "baseName": "paymentRefund",
            "type": "PaymentRefund"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        },
        {
            "name": "feeInSGD",
            "baseName": "feeInSGD",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemPaymentRefund.attributeTypeMap;
    }
}

export class TransactionItemPromoCode {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'transactionItem'?: TransactionItem;
    'transactionPromoCode'?: TransactionPromoCode;
    'value'?: number;
    'valueInEventCurrency'?: number;
    'valueInSGD'?: number;
    'creditedToHapz'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "transactionItem",
            "baseName": "transactionItem",
            "type": "TransactionItem"
        },
        {
            "name": "transactionPromoCode",
            "baseName": "transactionPromoCode",
            "type": "TransactionPromoCode"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInEventCurrency",
            "baseName": "valueInEventCurrency",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        },
        {
            "name": "creditedToHapz",
            "baseName": "creditedToHapz",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemPromoCode.attributeTypeMap;
    }
}

export class TransactionItemRegistrant {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'transactionItem'?: TransactionItem;
    'registrationFieldValues'?: { [key: string]: any; };
    'singleRegistration'?: boolean;
    'multiRegistration'?: boolean;
    'itemRegistrantAddOns'?: Array<TransactionItemRegistrantAddOn>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "transactionItem",
            "baseName": "transactionItem",
            "type": "TransactionItem"
        },
        {
            "name": "registrationFieldValues",
            "baseName": "registrationFieldValues",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "singleRegistration",
            "baseName": "singleRegistration",
            "type": "boolean"
        },
        {
            "name": "multiRegistration",
            "baseName": "multiRegistration",
            "type": "boolean"
        },
        {
            "name": "itemRegistrantAddOns",
            "baseName": "itemRegistrantAddOns",
            "type": "Array<TransactionItemRegistrantAddOn>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemRegistrant.attributeTypeMap;
    }
}

export class TransactionItemRegistrantAddOn {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'transactionItemRegistrant'?: TransactionItemRegistrant;
    'pricingAddOn'?: PricingAddOn;
    'pricingAddOnOption'?: PricingAddOnOption;
    'pricingAddOnOptionInventoryLedger'?: string;
    'exchangeRateFromPricingAddOnToTransaction'?: number;
    'price'?: number;
    'quantity'?: number;
    'bookingFee'?: number;
    'transactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "transactionItemRegistrant",
            "baseName": "transactionItemRegistrant",
            "type": "TransactionItemRegistrant"
        },
        {
            "name": "pricingAddOn",
            "baseName": "pricingAddOn",
            "type": "PricingAddOn"
        },
        {
            "name": "pricingAddOnOption",
            "baseName": "pricingAddOnOption",
            "type": "PricingAddOnOption"
        },
        {
            "name": "pricingAddOnOptionInventoryLedger",
            "baseName": "pricingAddOnOptionInventoryLedger",
            "type": "string"
        },
        {
            "name": "exchangeRateFromPricingAddOnToTransaction",
            "baseName": "exchangeRateFromPricingAddOnToTransaction",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemRegistrantAddOn.attributeTypeMap;
    }
}

export class TransactionItemRegistrantAddOnDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'pricingAddOn'?: string;
    'pricingAddOnOption'?: string;
    'pricingAddOnOptionInventoryLedger'?: string;
    'exchangeRateFromPricingAddOnToTransaction'?: number;
    'price'?: number;
    'quantity'?: number;
    'bookingFee'?: number;
    'transactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "pricingAddOn",
            "baseName": "pricingAddOn",
            "type": "string"
        },
        {
            "name": "pricingAddOnOption",
            "baseName": "pricingAddOnOption",
            "type": "string"
        },
        {
            "name": "pricingAddOnOptionInventoryLedger",
            "baseName": "pricingAddOnOptionInventoryLedger",
            "type": "string"
        },
        {
            "name": "exchangeRateFromPricingAddOnToTransaction",
            "baseName": "exchangeRateFromPricingAddOnToTransaction",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemRegistrantAddOnDto.attributeTypeMap;
    }
}

export class TransactionItemRegistrantDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'registrationFieldValues'?: { [key: string]: any; };
    'singleRegistration'?: boolean;
    'multiRegistration'?: boolean;
    'itemRegistrantAddOns'?: Array<TransactionItemRegistrantAddOnDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "registrationFieldValues",
            "baseName": "registrationFieldValues",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "singleRegistration",
            "baseName": "singleRegistration",
            "type": "boolean"
        },
        {
            "name": "multiRegistration",
            "baseName": "multiRegistration",
            "type": "boolean"
        },
        {
            "name": "itemRegistrantAddOns",
            "baseName": "itemRegistrantAddOns",
            "type": "Array<TransactionItemRegistrantAddOnDto>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemRegistrantDto.attributeTypeMap;
    }
}

export class TransactionItemRequest {
    'campaign': string;
    'timeslot': string;
    'pricing': string;
    'cardIssuer'?: string;
    'price': number;
    'quantity': number;
    'registrationFields'?: { [key: string]: any; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "string"
        },
        {
            "name": "timeslot",
            "baseName": "timeslot",
            "type": "string"
        },
        {
            "name": "pricing",
            "baseName": "pricing",
            "type": "string"
        },
        {
            "name": "cardIssuer",
            "baseName": "cardIssuer",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "registrationFields",
            "baseName": "registrationFields",
            "type": "{ [key: string]: any; }"
        }    ];

    static getAttributeTypeMap() {
        return TransactionItemRequest.attributeTypeMap;
    }
}

export class TransactionPayment {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'transaction'?: Transaction;
    'type'?: TransactionPayment.TypeEnum;
    'status'?: TransactionPayment.StatusEnum;
    'value'?: number;
    'valueInSGD'?: number;
    'feeInSGD'?: number;
    'currency'?: string;
    'ipAddress'?: string;
    'userAgent'?: string;
    'requestOriginIso3166CountryCode'?: string;
    'refunds'?: Array<PaymentRefund>;
    'itemPayments'?: Array<TransactionItemPayment>;
    'fullyRefunded'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "transaction",
            "baseName": "transaction",
            "type": "Transaction"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "TransactionPayment.TypeEnum"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "TransactionPayment.StatusEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        },
        {
            "name": "feeInSGD",
            "baseName": "feeInSGD",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "userAgent",
            "baseName": "userAgent",
            "type": "string"
        },
        {
            "name": "requestOriginIso3166CountryCode",
            "baseName": "requestOriginIso3166CountryCode",
            "type": "string"
        },
        {
            "name": "refunds",
            "baseName": "refunds",
            "type": "Array<PaymentRefund>"
        },
        {
            "name": "itemPayments",
            "baseName": "itemPayments",
            "type": "Array<TransactionItemPayment>"
        },
        {
            "name": "fullyRefunded",
            "baseName": "fullyRefunded",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TransactionPayment.attributeTypeMap;
    }
}

export namespace TransactionPayment {
    export enum TypeEnum {
        ONSITE = <any> 'ONSITE',
        PAYMENTPROCESSOR = <any> 'PAYMENT_PROCESSOR',
        CARDPAYMENTPROCESSOR = <any> 'CARD_PAYMENT_PROCESSOR'
    }
    export enum StatusEnum {
        RECEIVED = <any> 'RECEIVED',
        ERROR = <any> 'ERROR',
        DECLINED = <any> 'DECLINED',
        AUTHORISATIONPENDING = <any> 'AUTHORISATION_PENDING',
        AUTHORISED = <any> 'AUTHORISED',
        SETTLEMENTPENDING = <any> 'SETTLEMENT_PENDING',
        SETTLED = <any> 'SETTLED',
        REFUNDPENDING = <any> 'REFUND_PENDING',
        REFUNDED = <any> 'REFUNDED',
        CHARGEBACK = <any> 'CHARGEBACK'
    }
}
export class TransactionPaymentDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: TransactionPaymentDto.TypeEnum;
    'status'?: TransactionPaymentDto.StatusEnum;
    'value'?: number;
    'valueInSGD'?: number;
    'feeInSGD'?: number;
    'currency'?: string;
    'ipAddress'?: string;
    'userAgent'?: string;
    'requestOriginIso3166CountryCode'?: string;
    'refunds'?: Array<PaymentRefundDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "TransactionPaymentDto.TypeEnum"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "TransactionPaymentDto.StatusEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        },
        {
            "name": "feeInSGD",
            "baseName": "feeInSGD",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "userAgent",
            "baseName": "userAgent",
            "type": "string"
        },
        {
            "name": "requestOriginIso3166CountryCode",
            "baseName": "requestOriginIso3166CountryCode",
            "type": "string"
        },
        {
            "name": "refunds",
            "baseName": "refunds",
            "type": "Array<PaymentRefundDto>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionPaymentDto.attributeTypeMap;
    }
}

export namespace TransactionPaymentDto {
    export enum TypeEnum {
        ONSITE = <any> 'ONSITE',
        PAYMENTPROCESSOR = <any> 'PAYMENT_PROCESSOR',
        CARDPAYMENTPROCESSOR = <any> 'CARD_PAYMENT_PROCESSOR'
    }
    export enum StatusEnum {
        RECEIVED = <any> 'RECEIVED',
        ERROR = <any> 'ERROR',
        DECLINED = <any> 'DECLINED',
        AUTHORISATIONPENDING = <any> 'AUTHORISATION_PENDING',
        AUTHORISED = <any> 'AUTHORISED',
        SETTLEMENTPENDING = <any> 'SETTLEMENT_PENDING',
        SETTLED = <any> 'SETTLED',
        REFUNDPENDING = <any> 'REFUND_PENDING',
        REFUNDED = <any> 'REFUNDED',
        CHARGEBACK = <any> 'CHARGEBACK'
    }
}
export class TransactionPromoCode {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'transaction'?: Transaction;
    'promoCode'?: PromoCode;
    'promoCodeRedemptionLedger'?: string;
    'exchangeRateFromPromoCodeToTransaction'?: number;
    'value'?: number;
    'valueInEventCurrency'?: number;
    'valueInSGD'?: number;
    'creditedToHapz'?: boolean;
    'expiresAt'?: Date;
    'redeemedAt'?: Date;
    'itemPromoCodes'?: Array<TransactionItemPromoCode>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "transaction",
            "baseName": "transaction",
            "type": "Transaction"
        },
        {
            "name": "promoCode",
            "baseName": "promoCode",
            "type": "PromoCode"
        },
        {
            "name": "promoCodeRedemptionLedger",
            "baseName": "promoCodeRedemptionLedger",
            "type": "string"
        },
        {
            "name": "exchangeRateFromPromoCodeToTransaction",
            "baseName": "exchangeRateFromPromoCodeToTransaction",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInEventCurrency",
            "baseName": "valueInEventCurrency",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        },
        {
            "name": "creditedToHapz",
            "baseName": "creditedToHapz",
            "type": "boolean"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "redeemedAt",
            "baseName": "redeemedAt",
            "type": "Date"
        },
        {
            "name": "itemPromoCodes",
            "baseName": "itemPromoCodes",
            "type": "Array<TransactionItemPromoCode>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionPromoCode.attributeTypeMap;
    }
}

export class TransactionPromoCodeDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'promoCode'?: PromoCodeDto;
    'exchangeRateFromPromoCodeToTransaction'?: number;
    'value'?: number;
    'valueInSGD'?: number;
    'creditedToHapz'?: boolean;
    'expiresAt'?: Date;
    'redeemedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "promoCode",
            "baseName": "promoCode",
            "type": "PromoCodeDto"
        },
        {
            "name": "exchangeRateFromPromoCodeToTransaction",
            "baseName": "exchangeRateFromPromoCodeToTransaction",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "valueInSGD",
            "baseName": "valueInSGD",
            "type": "number"
        },
        {
            "name": "creditedToHapz",
            "baseName": "creditedToHapz",
            "type": "boolean"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "redeemedAt",
            "baseName": "redeemedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return TransactionPromoCodeDto.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "PaymentRefund.TypeEnum": PaymentRefund.TypeEnum,
        "PaymentRefundDto.TypeEnum": PaymentRefundDto.TypeEnum,
        "PromoCode.TypeEnum": PromoCode.TypeEnum,
        "PromoCodeDto.TypeEnum": PromoCodeDto.TypeEnum,
        "Transaction.StatusEnum": Transaction.StatusEnum,
        "Transaction.UserTrafficChannelEnum": Transaction.UserTrafficChannelEnum,
        "TransactionDto.StatusEnum": TransactionDto.StatusEnum,
        "TransactionDto.UserTrafficChannelEnum": TransactionDto.UserTrafficChannelEnum,
        "TransactionItem.StatusEnum": TransactionItem.StatusEnum,
        "TransactionItemDto.StatusEnum": TransactionItemDto.StatusEnum,
        "TransactionPayment.TypeEnum": TransactionPayment.TypeEnum,
        "TransactionPayment.StatusEnum": TransactionPayment.StatusEnum,
        "TransactionPaymentDto.TypeEnum": TransactionPaymentDto.TypeEnum,
        "TransactionPaymentDto.StatusEnum": TransactionPaymentDto.StatusEnum,
}

let typeMap: {[index: string]: any} = {
    "AddOn": AddOn,
    "AddOnOption": AddOnOption,
    "AddTransactionRequest": AddTransactionRequest,
    "Campaign": Campaign,
    "CampaignCategory": CampaignCategory,
    "CampaignDto": CampaignDto,
    "CampaignMerchant": CampaignMerchant,
    "CampaignMerchantDto": CampaignMerchantDto,
    "CampaignSubcategory": CampaignSubcategory,
    "CampaignTimeslot": CampaignTimeslot,
    "CampaignTimeslotDto": CampaignTimeslotDto,
    "CardIssuer": CardIssuer,
    "GrabNotification": GrabNotification,
    "Item": Item,
    "Location": Location,
    "LocationDto": LocationDto,
    "MerchantDistributionTransaction": MerchantDistributionTransaction,
    "PaymentRefund": PaymentRefund,
    "PaymentRefundDto": PaymentRefundDto,
    "Pricing": Pricing,
    "PricingAddOn": PricingAddOn,
    "PricingAddOnOption": PricingAddOnOption,
    "PricingCardIssuer": PricingCardIssuer,
    "PricingCardIssuerDto": PricingCardIssuerDto,
    "PricingCategory": PricingCategory,
    "PricingCategoryDto": PricingCategoryDto,
    "PricingDto": PricingDto,
    "PricingInterval": PricingInterval,
    "PricingIntervalDto": PricingIntervalDto,
    "PricingPackage": PricingPackage,
    "PromoCode": PromoCode,
    "PromoCodeDto": PromoCodeDto,
    "Transaction": Transaction,
    "TransactionCreditsLedger": TransactionCreditsLedger,
    "TransactionCreditsLedgerDto": TransactionCreditsLedgerDto,
    "TransactionDto": TransactionDto,
    "TransactionItem": TransactionItem,
    "TransactionItemAddOn": TransactionItemAddOn,
    "TransactionItemAddOnDto": TransactionItemAddOnDto,
    "TransactionItemCreditsLedger": TransactionItemCreditsLedger,
    "TransactionItemDto": TransactionItemDto,
    "TransactionItemPayment": TransactionItemPayment,
    "TransactionItemPaymentRefund": TransactionItemPaymentRefund,
    "TransactionItemPromoCode": TransactionItemPromoCode,
    "TransactionItemRegistrant": TransactionItemRegistrant,
    "TransactionItemRegistrantAddOn": TransactionItemRegistrantAddOn,
    "TransactionItemRegistrantAddOnDto": TransactionItemRegistrantAddOnDto,
    "TransactionItemRegistrantDto": TransactionItemRegistrantDto,
    "TransactionItemRequest": TransactionItemRequest,
    "TransactionPayment": TransactionPayment,
    "TransactionPaymentDto": TransactionPaymentDto,
    "TransactionPromoCode": TransactionPromoCode,
    "TransactionPromoCodeDto": TransactionPromoCodeDto,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AnalyticApiApiKeys {
    JWT,
}

export class AnalyticApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AnalyticApiApiKeys, value: string) {
        (this.authentications as any)[AnalyticApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve the number of tickets sold by campaign ids
     * @param campaignIds 
     * @param {*} [options] Override http request options.
     */
    public getTicketSold (campaignIds?: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: { [key: string]: number; };  }> {
        const localVarPath = this.basePath + '/analytic/ticketSold';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (campaignIds !== undefined) {
            localVarQueryParameters['campaignIds'] = ObjectSerializer.serialize(campaignIds, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: { [key: string]: number; };  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "{ [key: string]: number; }");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CreditsApiApiKeys {
    JWT,
}

export class CreditsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CreditsApiApiKeys, value: string) {
        (this.authentications as any)[CreditsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add credits ledger to transaction
     * @param transaction Transaction ID
     * @param credits 
     * @param {*} [options] Override http request options.
     */
    public addCreditsLedger (transaction: string, credits?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionCreditsLedgerDto;  }> {
        const localVarPath = this.basePath + '/{transaction}/credits'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling addCreditsLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (credits !== undefined) {
            localVarFormParams['credits'] = ObjectSerializer.serialize(credits, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionCreditsLedgerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionCreditsLedgerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GrabpayApiApiKeys {
    JWT,
}

export class GrabpayApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GrabpayApiApiKeys, value: string) {
        (this.authentications as any)[GrabpayApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Webhook for receiving GrabPay events
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public receiveNotification (body?: GrabNotification, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/grabpay/webhook';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "GrabNotification")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LookupApiApiKeys {
    JWT,
}

export class LookupApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LookupApiApiKeys, value: string) {
        (this.authentications as any)[LookupApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param campaignId 
     * @param timeslotId 
     * @param pricingId 
     * @param {*} [options] Override http request options.
     */
    public isPricingLocked (campaignId: string, timeslotId: string, pricingId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/campaigns/{campaignId}/timeslots/{timeslotId}/pricings/{pricingId}/isLocked'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)))
            .replace('{' + 'timeslotId' + '}', encodeURIComponent(String(timeslotId)))
            .replace('{' + 'pricingId' + '}', encodeURIComponent(String(pricingId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isPricingLocked.');
        }

        // verify required parameter 'timeslotId' is not null or undefined
        if (timeslotId === null || timeslotId === undefined) {
            throw new Error('Required parameter timeslotId was null or undefined when calling isPricingLocked.');
        }

        // verify required parameter 'pricingId' is not null or undefined
        if (pricingId === null || pricingId === undefined) {
            throw new Error('Required parameter pricingId was null or undefined when calling isPricingLocked.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaignId 
     * @param {*} [options] Override http request options.
     */
    public isPricingLocked1 (campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/campaigns/{campaignId}/isLocked'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isPricingLocked1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaignId 
     * @param timeslotId 
     * @param {*} [options] Override http request options.
     */
    public isTimeslotLocked (campaignId: string, timeslotId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/campaigns/{campaignId}/timeslots/{timeslotId}/isLocked'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)))
            .replace('{' + 'timeslotId' + '}', encodeURIComponent(String(timeslotId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isTimeslotLocked.');
        }

        // verify required parameter 'timeslotId' is not null or undefined
        if (timeslotId === null || timeslotId === undefined) {
            throw new Error('Required parameter timeslotId was null or undefined when calling isTimeslotLocked.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param transactionId 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public isTransactionOwnedBy (transactionId: string, accountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/{transactionId}/isOwnedBy/{accountId}'
            .replace('{' + 'transactionId' + '}', encodeURIComponent(String(transactionId)))
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling isTransactionOwnedBy.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling isTransactionOwnedBy.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MigrateApiApiKeys {
    JWT,
}

export class MigrateApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MigrateApiApiKeys, value: string) {
        (this.authentications as any)[MigrateApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param step 
     * @param {*} [options] Override http request options.
     */
    public migrate (step: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/migrate/{step}'
            .replace('{' + 'step' + '}', encodeURIComponent(String(step)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'step' is not null or undefined
        if (step === null || step === undefined) {
            throw new Error('Required parameter step was null or undefined when calling migrate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsApiApiKeys {
    JWT,
}

export class PaymentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsApiApiKeys, value: string) {
        (this.authentications as any)[PaymentsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a payment to an existing transaction
     * @param transaction Transaction ID
     * @param firstName First Name
     * @param lastName Last Name
     * @param emailAddress Email Address
     * @param contactNo Contact Number
     * @param ipAddress IP Address where the request originated from
     * @param userAgent User-Agent of the device where the request originated from
     * @param paymentSource Either a Stripe Card ID or a Stripe Card Token
     * @param paymentMethod Onsite Payment Method
     * @param storeInformation Indicate whether payment information should be stored
     * @param sendEmail Send Confirmation Email
     * @param enableProcurement Enable Ticket Procurement
     * @param {*} [options] Override http request options.
     */
    public addPayment (transaction: string, firstName: string, lastName: string, emailAddress: string, contactNo: string, ipAddress: string, userAgent: string, paymentSource?: string, paymentMethod?: 'STRIPE' | 'ONSITE_CASH' | 'ONSITE_CREDIT_CARD' | 'ONSITE_GRABPAY', storeInformation?: boolean, sendEmail?: boolean, enableProcurement?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionDto;  }> {
        const localVarPath = this.basePath + '/{transaction}/payments'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling addPayment.');
        }

        // verify required parameter 'firstName' is not null or undefined
        if (firstName === null || firstName === undefined) {
            throw new Error('Required parameter firstName was null or undefined when calling addPayment.');
        }

        // verify required parameter 'lastName' is not null or undefined
        if (lastName === null || lastName === undefined) {
            throw new Error('Required parameter lastName was null or undefined when calling addPayment.');
        }

        // verify required parameter 'emailAddress' is not null or undefined
        if (emailAddress === null || emailAddress === undefined) {
            throw new Error('Required parameter emailAddress was null or undefined when calling addPayment.');
        }

        // verify required parameter 'contactNo' is not null or undefined
        if (contactNo === null || contactNo === undefined) {
            throw new Error('Required parameter contactNo was null or undefined when calling addPayment.');
        }

        // verify required parameter 'ipAddress' is not null or undefined
        if (ipAddress === null || ipAddress === undefined) {
            throw new Error('Required parameter ipAddress was null or undefined when calling addPayment.');
        }

        // verify required parameter 'userAgent' is not null or undefined
        if (userAgent === null || userAgent === undefined) {
            throw new Error('Required parameter userAgent was null or undefined when calling addPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (firstName !== undefined) {
            localVarFormParams['firstName'] = ObjectSerializer.serialize(firstName, "string");
        }

        if (lastName !== undefined) {
            localVarFormParams['lastName'] = ObjectSerializer.serialize(lastName, "string");
        }

        if (emailAddress !== undefined) {
            localVarFormParams['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }

        if (contactNo !== undefined) {
            localVarFormParams['contactNo'] = ObjectSerializer.serialize(contactNo, "string");
        }

        if (paymentSource !== undefined) {
            localVarFormParams['paymentSource'] = ObjectSerializer.serialize(paymentSource, "string");
        }

        if (paymentMethod !== undefined) {
            localVarFormParams['paymentMethod'] = ObjectSerializer.serialize(paymentMethod, "'STRIPE' | 'ONSITE_CASH' | 'ONSITE_CREDIT_CARD' | 'ONSITE_GRABPAY'");
        }

        if (storeInformation !== undefined) {
            localVarFormParams['storeInformation'] = ObjectSerializer.serialize(storeInformation, "boolean");
        }

        if (ipAddress !== undefined) {
            localVarFormParams['ipAddress'] = ObjectSerializer.serialize(ipAddress, "string");
        }

        if (userAgent !== undefined) {
            localVarFormParams['userAgent'] = ObjectSerializer.serialize(userAgent, "string");
        }

        if (sendEmail !== undefined) {
            localVarFormParams['sendEmail'] = ObjectSerializer.serialize(sendEmail, "boolean");
        }

        if (enableProcurement !== undefined) {
            localVarFormParams['enableProcurement'] = ObjectSerializer.serialize(enableProcurement, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of a payment
     * @param transaction Transaction ID
     * @param payment Payment ID
     * @param {*} [options] Override http request options.
     */
    public getPayment (transaction: string, payment: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionPayment;  }> {
        const localVarPath = this.basePath + '/{transaction}/payments/{payment}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'payment' + '}', encodeURIComponent(String(payment)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getPayment.');
        }

        // verify required parameter 'payment' is not null or undefined
        if (payment === null || payment === undefined) {
            throw new Error('Required parameter payment was null or undefined when calling getPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionPayment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionPayment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all the payments from this transaction
     * @param transaction Transaction ID
     * @param {*} [options] Override http request options.
     */
    public getPayments (transaction: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TransactionPaymentDto>;  }> {
        const localVarPath = this.basePath + '/{transaction}/payments'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getPayments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TransactionPaymentDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionPaymentDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param redirectType 
     * @param state 
     * @param redirectToken 
     * @param {*} [options] Override http request options.
     */
    public redirect (redirectType: 1 | 2, state: string, redirectToken: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/payments/redirect';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'redirectType' is not null or undefined
        if (redirectType === null || redirectType === undefined) {
            throw new Error('Required parameter redirectType was null or undefined when calling redirect.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling redirect.');
        }

        // verify required parameter 'redirectToken' is not null or undefined
        if (redirectToken === null || redirectToken === undefined) {
            throw new Error('Required parameter redirectToken was null or undefined when calling redirect.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (redirectType !== undefined) {
            localVarFormParams['redirectType'] = ObjectSerializer.serialize(redirectType, "1 | 2");
        }

        if (state !== undefined) {
            localVarFormParams['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (redirectToken !== undefined) {
            localVarFormParams['redirectToken'] = ObjectSerializer.serialize(redirectToken, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This API is only for captured payments
     * @summary Refunds a payment
     * @param transaction Transaction ID
     * @param payment Payment ID
     * @param invalidate Is Invalid
     * @param fradulent Is Fradulent
     * @param transactionItem Transaction Item ID
     * @param amount Refund amount
     * @param {*} [options] Override http request options.
     */
    public refundPayment (transaction: string, payment: string, invalidate: boolean, fradulent: boolean, transactionItem?: string, amount?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/payments/{payment}/refunds'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'payment' + '}', encodeURIComponent(String(payment)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling refundPayment.');
        }

        // verify required parameter 'payment' is not null or undefined
        if (payment === null || payment === undefined) {
            throw new Error('Required parameter payment was null or undefined when calling refundPayment.');
        }

        // verify required parameter 'invalidate' is not null or undefined
        if (invalidate === null || invalidate === undefined) {
            throw new Error('Required parameter invalidate was null or undefined when calling refundPayment.');
        }

        // verify required parameter 'fradulent' is not null or undefined
        if (fradulent === null || fradulent === undefined) {
            throw new Error('Required parameter fradulent was null or undefined when calling refundPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (transactionItem !== undefined) {
            localVarFormParams['transactionItem'] = ObjectSerializer.serialize(transactionItem, "string");
        }

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (invalidate !== undefined) {
            localVarFormParams['invalidate'] = ObjectSerializer.serialize(invalidate, "boolean");
        }

        if (fradulent !== undefined) {
            localVarFormParams['fradulent'] = ObjectSerializer.serialize(fradulent, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This API is only for captured payments
     * @summary Refunds a payment
     * @param transaction Transaction ID
     * @param invalidate Is Invalid
     * @param amount Refund amount
     * @param {*} [options] Override http request options.
     */
    public refundPayments (transaction: string, invalidate: boolean, amount?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/payments/refunds'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling refundPayments.');
        }

        // verify required parameter 'invalidate' is not null or undefined
        if (invalidate === null || invalidate === undefined) {
            throw new Error('Required parameter invalidate was null or undefined when calling refundPayments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (invalidate !== undefined) {
            localVarFormParams['invalidate'] = ObjectSerializer.serialize(invalidate, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PromocodesApiApiKeys {
    JWT,
}

export class PromocodesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PromocodesApiApiKeys, value: string) {
        (this.authentications as any)[PromocodesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a promo code to this transaction
     * @param transaction Transaction ID
     * @param code Promo Code
     * @param {*} [options] Override http request options.
     */
    public addPromoCode (transaction: string, code?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionPromoCodeDto;  }> {
        const localVarPath = this.basePath + '/{transaction}/promoCodes'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling addPromoCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (code !== undefined) {
            localVarFormParams['code'] = ObjectSerializer.serialize(code, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionPromoCodeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionPromoCodeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a promo code from a given transaction
     * @param transaction Transaction ID
     * @param promoCode Promo Code ID
     * @param {*} [options] Override http request options.
     */
    public deletePromoCode (transaction: string, promoCode: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/promoCodes/{promoCode}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling deletePromoCode.');
        }

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling deletePromoCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a promo code from a given transaction
     * @param transaction Transaction ID
     * @param promoCode Promo Code ID
     * @param {*} [options] Override http request options.
     */
    public getPromoCode (transaction: string, promoCode: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionPromoCodeDto;  }> {
        const localVarPath = this.basePath + '/{transaction}/promoCodes/{promoCode}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getPromoCode.');
        }

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling getPromoCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionPromoCodeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionPromoCodeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all the promo codes from this transaction
     * @param transaction Transaction ID
     * @param {*} [options] Override http request options.
     */
    public getPromoCodes (transaction: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TransactionPromoCodeDto>;  }> {
        const localVarPath = this.basePath + '/{transaction}/promoCodes'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getPromoCodes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TransactionPromoCodeDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionPromoCodeDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StripeApiApiKeys {
    JWT,
}

export class StripeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StripeApiApiKeys, value: string) {
        (this.authentications as any)[StripeApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Webhook for receiving Stripe events
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public receiveEvent (body?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/stripe/webhook';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionItemAddOnsApiApiKeys {
    JWT,
}

export class TransactionItemAddOnsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionItemAddOnsApiApiKeys, value: string) {
        (this.authentications as any)[TransactionItemAddOnsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds an add on to this transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param addon Add On ID
     * @param option Option ID
     * @param quantity Quantity
     * @param {*} [options] Override http request options.
     */
    public addAddOn (transaction: string, transactionItem: string, addon?: string, option?: string, quantity?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionItemAddOnDto;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/addons'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling addAddOn.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling addAddOn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (addon !== undefined) {
            localVarFormParams['addon'] = ObjectSerializer.serialize(addon, "string");
        }

        if (option !== undefined) {
            localVarFormParams['option'] = ObjectSerializer.serialize(option, "string");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionItemAddOnDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionItemAddOnDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an add on from this transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param transactionItemAddOn Transaction Item Add On ID
     * @param {*} [options] Override http request options.
     */
    public deleteAddOn (transaction: string, transactionItem: string, transactionItemAddOn: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/addons/{transactionItemAddOn}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)))
            .replace('{' + 'transactionItemAddOn' + '}', encodeURIComponent(String(transactionItemAddOn)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling deleteAddOn.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling deleteAddOn.');
        }

        // verify required parameter 'transactionItemAddOn' is not null or undefined
        if (transactionItemAddOn === null || transactionItemAddOn === undefined) {
            throw new Error('Required parameter transactionItemAddOn was null or undefined when calling deleteAddOn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves an add on from this transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param transactionItemAddOn Transaction Item Add On ID
     * @param {*} [options] Override http request options.
     */
    public getAddOn (transaction: string, transactionItem: string, transactionItemAddOn: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionItemAddOnDto;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/addons/{transactionItemAddOn}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)))
            .replace('{' + 'transactionItemAddOn' + '}', encodeURIComponent(String(transactionItemAddOn)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getAddOn.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling getAddOn.');
        }

        // verify required parameter 'transactionItemAddOn' is not null or undefined
        if (transactionItemAddOn === null || transactionItemAddOn === undefined) {
            throw new Error('Required parameter transactionItemAddOn was null or undefined when calling getAddOn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionItemAddOnDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionItemAddOnDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all the add ons from this transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param {*} [options] Override http request options.
     */
    public getAddOns (transaction: string, transactionItem: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TransactionItemAddOnDto>;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/addons'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getAddOns.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling getAddOns.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TransactionItemAddOnDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionItemAddOnDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates an add on from this transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param transactionItemAddOn Transaction Item Add On ID
     * @param quantity Quantity
     * @param {*} [options] Override http request options.
     */
    public updateAddOn (transaction: string, transactionItem: string, transactionItemAddOn: string, quantity?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/addons/{transactionItemAddOn}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)))
            .replace('{' + 'transactionItemAddOn' + '}', encodeURIComponent(String(transactionItemAddOn)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling updateAddOn.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling updateAddOn.');
        }

        // verify required parameter 'transactionItemAddOn' is not null or undefined
        if (transactionItemAddOn === null || transactionItemAddOn === undefined) {
            throw new Error('Required parameter transactionItemAddOn was null or undefined when calling updateAddOn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionItemRegistrantAddOnApiApiKeys {
    JWT,
}

export class TransactionItemRegistrantAddOnApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionItemRegistrantAddOnApiApiKeys, value: string) {
        (this.authentications as any)[TransactionItemRegistrantAddOnApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds an add on to this transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param registrant Transaction Item Registrant ID
     * @param addon Add On ID
     * @param option Option ID
     * @param quantity Quantity
     * @param {*} [options] Override http request options.
     */
    public addAddOn1 (transaction: string, transactionItem: string, registrant: string, addon?: string, option?: string, quantity?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionItemRegistrantAddOnDto;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/registrants/{registrant}/addons'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)))
            .replace('{' + 'registrant' + '}', encodeURIComponent(String(registrant)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling addAddOn1.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling addAddOn1.');
        }

        // verify required parameter 'registrant' is not null or undefined
        if (registrant === null || registrant === undefined) {
            throw new Error('Required parameter registrant was null or undefined when calling addAddOn1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (addon !== undefined) {
            localVarFormParams['addon'] = ObjectSerializer.serialize(addon, "string");
        }

        if (option !== undefined) {
            localVarFormParams['option'] = ObjectSerializer.serialize(option, "string");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionItemRegistrantAddOnDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionItemRegistrantAddOnDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an add on from this transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param registrant Transaction Item Registrant ID
     * @param transactionItemRegistrantAddOn Transaction Item Registrant Add On Id
     * @param {*} [options] Override http request options.
     */
    public deleteAddOn1 (transaction: string, transactionItem: string, registrant: string, transactionItemRegistrantAddOn: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/registrants/{registrant}/addons/{transactionItemRegistrantAddOn}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)))
            .replace('{' + 'registrant' + '}', encodeURIComponent(String(registrant)))
            .replace('{' + 'transactionItemRegistrantAddOn' + '}', encodeURIComponent(String(transactionItemRegistrantAddOn)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling deleteAddOn1.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling deleteAddOn1.');
        }

        // verify required parameter 'registrant' is not null or undefined
        if (registrant === null || registrant === undefined) {
            throw new Error('Required parameter registrant was null or undefined when calling deleteAddOn1.');
        }

        // verify required parameter 'transactionItemRegistrantAddOn' is not null or undefined
        if (transactionItemRegistrantAddOn === null || transactionItemRegistrantAddOn === undefined) {
            throw new Error('Required parameter transactionItemRegistrantAddOn was null or undefined when calling deleteAddOn1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves an add on from this transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param registrant Transaction Item Registrant ID
     * @param transactionItemRegistrantAddOn Transaction Item Registrant Add On Id
     * @param {*} [options] Override http request options.
     */
    public getAddOn1 (transaction: string, transactionItem: string, registrant: string, transactionItemRegistrantAddOn: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionItemRegistrantAddOnDto;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/registrants/{registrant}/addons/{transactionItemRegistrantAddOn}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)))
            .replace('{' + 'registrant' + '}', encodeURIComponent(String(registrant)))
            .replace('{' + 'transactionItemRegistrantAddOn' + '}', encodeURIComponent(String(transactionItemRegistrantAddOn)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getAddOn1.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling getAddOn1.');
        }

        // verify required parameter 'registrant' is not null or undefined
        if (registrant === null || registrant === undefined) {
            throw new Error('Required parameter registrant was null or undefined when calling getAddOn1.');
        }

        // verify required parameter 'transactionItemRegistrantAddOn' is not null or undefined
        if (transactionItemRegistrantAddOn === null || transactionItemRegistrantAddOn === undefined) {
            throw new Error('Required parameter transactionItemRegistrantAddOn was null or undefined when calling getAddOn1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionItemRegistrantAddOnDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionItemRegistrantAddOnDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all the add ons from this transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param registrant Transaction Item Registrant ID
     * @param {*} [options] Override http request options.
     */
    public getAddOns1 (transaction: string, transactionItem: string, registrant: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TransactionItemRegistrantAddOnDto>;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/registrants/{registrant}/addons'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)))
            .replace('{' + 'registrant' + '}', encodeURIComponent(String(registrant)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getAddOns1.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling getAddOns1.');
        }

        // verify required parameter 'registrant' is not null or undefined
        if (registrant === null || registrant === undefined) {
            throw new Error('Required parameter registrant was null or undefined when calling getAddOns1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TransactionItemRegistrantAddOnDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionItemRegistrantAddOnDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates an add on from this transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param registrant Transaction Item Registrant ID
     * @param transactionItemRegistrantAddOn Transaction Item Registrant Add On Id
     * @param quantity Quantity
     * @param {*} [options] Override http request options.
     */
    public updateAddOn1 (transaction: string, transactionItem: string, registrant: string, transactionItemRegistrantAddOn: string, quantity?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/registrants/{registrant}/addons/{transactionItemRegistrantAddOn}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)))
            .replace('{' + 'registrant' + '}', encodeURIComponent(String(registrant)))
            .replace('{' + 'transactionItemRegistrantAddOn' + '}', encodeURIComponent(String(transactionItemRegistrantAddOn)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling updateAddOn1.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling updateAddOn1.');
        }

        // verify required parameter 'registrant' is not null or undefined
        if (registrant === null || registrant === undefined) {
            throw new Error('Required parameter registrant was null or undefined when calling updateAddOn1.');
        }

        // verify required parameter 'transactionItemRegistrantAddOn' is not null or undefined
        if (transactionItemRegistrantAddOn === null || transactionItemRegistrantAddOn === undefined) {
            throw new Error('Required parameter transactionItemRegistrantAddOn was null or undefined when calling updateAddOn1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionItemRegistrantsApiApiKeys {
    JWT,
}

export class TransactionItemRegistrantsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionItemRegistrantsApiApiKeys, value: string) {
        (this.authentications as any)[TransactionItemRegistrantsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add transaction item registrant
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param body Registrant Info Map (registrationFieldId -&gt; value)
     * @param {*} [options] Override http request options.
     */
    public addRegistrant (transaction: string, transactionItem: string, body?: any, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionItemRegistrantDto;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/registrants'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling addRegistrant.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling addRegistrant.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "any")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionItemRegistrantDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionItemRegistrantDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add transaction item registrant
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param registrant Transaction Item Registrant ID
     * @param body Registrant Info Map (registrationFieldId -&gt; value)
     * @param {*} [options] Override http request options.
     */
    public updateRegistrant (transaction: string, transactionItem: string, registrant: string, body?: any, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/registrants/{registrant}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)))
            .replace('{' + 'registrant' + '}', encodeURIComponent(String(registrant)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling updateRegistrant.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling updateRegistrant.');
        }

        // verify required parameter 'registrant' is not null or undefined
        if (registrant === null || registrant === undefined) {
            throw new Error('Required parameter registrant was null or undefined when calling updateRegistrant.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "any")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionItemsApiApiKeys {
    JWT,
}

export class TransactionItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionItemsApiApiKeys, value: string) {
        (this.authentications as any)[TransactionItemsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a transaction item
     * @param transaction Transaction ID
     * @param campaign Campaign ID
     * @param timeslot Event Timeslot ID
     * @param pricing Pricing ID
     * @param price Price
     * @param quantity Quantity
     * @param cardIssuer Card Issuer ID
     * @param registrant Registrant Fields Map (registrationFieldId -&gt; value)
     * @param {*} [options] Override http request options.
     */
    public addTransactionItem (transaction: string, campaign: string, timeslot: string, pricing: string, price: number, quantity: number, cardIssuer?: string, registrant?: { [key: string]: string; }, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionItemDto;  }> {
        const localVarPath = this.basePath + '/{transaction}/items'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling addTransactionItem.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addTransactionItem.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling addTransactionItem.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling addTransactionItem.');
        }

        // verify required parameter 'price' is not null or undefined
        if (price === null || price === undefined) {
            throw new Error('Required parameter price was null or undefined when calling addTransactionItem.');
        }

        // verify required parameter 'quantity' is not null or undefined
        if (quantity === null || quantity === undefined) {
            throw new Error('Required parameter quantity was null or undefined when calling addTransactionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (campaign !== undefined) {
            localVarFormParams['campaign'] = ObjectSerializer.serialize(campaign, "string");
        }

        if (timeslot !== undefined) {
            localVarFormParams['timeslot'] = ObjectSerializer.serialize(timeslot, "string");
        }

        if (pricing !== undefined) {
            localVarFormParams['pricing'] = ObjectSerializer.serialize(pricing, "string");
        }

        if (cardIssuer !== undefined) {
            localVarFormParams['cardIssuer'] = ObjectSerializer.serialize(cardIssuer, "string");
        }

        if (price !== undefined) {
            localVarFormParams['price'] = ObjectSerializer.serialize(price, "number");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        if (registrant !== undefined) {
            localVarFormParams['registrant'] = ObjectSerializer.serialize(registrant, "{ [key: string]: string; }");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionItemDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionItemDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds transaction with transaction item
     * @param transaction Transaction ID
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public addTransactionItems (transaction: string, body?: Array<TransactionItemRequest>, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/items'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling addTransactionItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<TransactionItemRequest>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param {*} [options] Override http request options.
     */
    public deleteTransactionItem (transaction: string, transactionItem: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling deleteTransactionItem.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling deleteTransactionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param {*} [options] Override http request options.
     */
    public getTransactionItem (transaction: string, transactionItem: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionItemDto;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getTransactionItem.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling getTransactionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionItemDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionItemDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Refund all payment for a transactionItem
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param amount Refund amount
     * @param invalidate Invalidate transaction item
     * @param {*} [options] Override http request options.
     */
    public refundTransactionItem (transaction: string, transactionItem: string, amount?: number, invalidate?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/refunds'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling refundTransactionItem.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling refundTransactionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (invalidate !== undefined) {
            localVarFormParams['invalidate'] = ObjectSerializer.serialize(invalidate, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a transaction item
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param campaign Campaign ID
     * @param timeslot Event Timeslot ID
     * @param pricing Pricing ID
     * @param price Price
     * @param quantity Quantity
     * @param cardIssuer Card Issuer ID
     * @param registrant Registrant Fields Map (registrationFieldId -&gt; value)
     * @param updateCharge Update Charge if transaction is already charged
     * @param {*} [options] Override http request options.
     */
    public updateTransactionItem (transaction: string, transactionItem: string, campaign: string, timeslot: string, pricing: string, price: number, quantity: number, cardIssuer?: string, registrant?: { [key: string]: string; }, updateCharge?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling updateTransactionItem.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling updateTransactionItem.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateTransactionItem.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling updateTransactionItem.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling updateTransactionItem.');
        }

        // verify required parameter 'price' is not null or undefined
        if (price === null || price === undefined) {
            throw new Error('Required parameter price was null or undefined when calling updateTransactionItem.');
        }

        // verify required parameter 'quantity' is not null or undefined
        if (quantity === null || quantity === undefined) {
            throw new Error('Required parameter quantity was null or undefined when calling updateTransactionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (campaign !== undefined) {
            localVarFormParams['campaign'] = ObjectSerializer.serialize(campaign, "string");
        }

        if (timeslot !== undefined) {
            localVarFormParams['timeslot'] = ObjectSerializer.serialize(timeslot, "string");
        }

        if (pricing !== undefined) {
            localVarFormParams['pricing'] = ObjectSerializer.serialize(pricing, "string");
        }

        if (cardIssuer !== undefined) {
            localVarFormParams['cardIssuer'] = ObjectSerializer.serialize(cardIssuer, "string");
        }

        if (price !== undefined) {
            localVarFormParams['price'] = ObjectSerializer.serialize(price, "number");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        if (registrant !== undefined) {
            localVarFormParams['registrant'] = ObjectSerializer.serialize(registrant, "{ [key: string]: string; }");
        }

        if (updateCharge !== undefined) {
            localVarFormParams['updateCharge'] = ObjectSerializer.serialize(updateCharge, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionItemsExpiryApiApiKeys {
    JWT,
}

export class TransactionItemsExpiryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionItemsExpiryApiApiKeys, value: string) {
        (this.authentications as any)[TransactionItemsExpiryApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve a transaction item expiry
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param {*} [options] Override http request options.
     */
    public getTransactionItemExpiry (transaction: string, transactionItem: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Date;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/expiry'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getTransactionItemExpiry.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling getTransactionItemExpiry.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Date;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Date");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a transaction item expiry
     * @param transaction Transaction ID
     * @param transactionItem Transaction Item ID
     * @param expiresAt Expires Date/Time of inventory ledger with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param {*} [options] Override http request options.
     */
    public updateTransactionItemExpiry (transaction: string, transactionItem: string, expiresAt?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/items/{transactionItem}/expiry'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)))
            .replace('{' + 'transactionItem' + '}', encodeURIComponent(String(transactionItem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling updateTransactionItemExpiry.');
        }

        // verify required parameter 'transactionItem' is not null or undefined
        if (transactionItem === null || transactionItem === undefined) {
            throw new Error('Required parameter transactionItem was null or undefined when calling updateTransactionItemExpiry.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expiresAt !== undefined) {
            localVarFormParams['expiresAt'] = ObjectSerializer.serialize(expiresAt, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionsApiApiKeys {
    JWT,
}

export class TransactionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionsApiApiKeys, value: string) {
        (this.authentications as any)[TransactionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public addTransaction (body?: MerchantDistributionTransaction, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/merchantDistribution';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MerchantDistributionTransaction")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public addTransaction1 (body?: AddTransactionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionDto;  }> {
        const localVarPath = this.basePath + '/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AddTransactionRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Approval of a transaction for manual review
     * @param transaction Transaction ID
     * @param {*} [options] Override http request options.
     */
    public approveTransaction (transaction: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/approve'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling approveTransaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the transactions from an account
     * @param account Account ID
     * @param start Start Row
     * @param rows Number of Rows
     * @param campaign Campaign ID
     * @param type (Optional) 1 &#x3D; Retrieve all transactions, 2 &#x3D; Retrieve successful transactions, 3 &#x3D; Retrieve active transactions
     * @param {*} [options] Override http request options.
     */
    public getAccountTransactions (account: string, start: number, rows: number, campaign?: Array<string>, type?: 1 | 2 | 3, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TransactionDto>;  }> {
        const localVarPath = this.basePath + '/lookup';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getAccountTransactions.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getAccountTransactions.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getAccountTransactions.');
        }

        if (account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(account, "string");
        }

        if (campaign !== undefined) {
            localVarQueryParameters['campaign'] = ObjectSerializer.serialize(campaign, "Array<string>");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "1 | 2 | 3");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TransactionDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of a transaction
     * @param transaction Transaction ID
     * @param {*} [options] Override http request options.
     */
    public getTransaction (transaction: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TransactionDto;  }> {
        const localVarPath = this.basePath + '/{transaction}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getTransaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the transactions matching the provided list of transaction IDs
     * @param id List of ids
     * @param {*} [options] Override http request options.
     */
    public getTransactions (id?: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TransactionDto>;  }> {
        const localVarPath = this.basePath + '/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TransactionDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Rejection of a transaction for manual review
     * @param transaction Transaction ID
     * @param {*} [options] Override http request options.
     */
    public rejectTransaction (transaction: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{transaction}/reject'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling rejectTransaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the details for a transaction
     * @param transaction Transaction ID
     * @param currency Currency
     * @param firstName First Name
     * @param lastName Last Name
     * @param emailAddress Email Address
     * @param contactNo Contact Number
     * @param expiredAt Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param cart Is Active Cart
     * @param {*} [options] Override http request options.
     */
    public updateTransaction (transaction: string, currency?: string, firstName?: string, lastName?: string, emailAddress?: string, contactNo?: string, expiredAt?: Date, cart?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Transaction;  }> {
        const localVarPath = this.basePath + '/{transaction}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling updateTransaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (firstName !== undefined) {
            localVarFormParams['firstName'] = ObjectSerializer.serialize(firstName, "string");
        }

        if (lastName !== undefined) {
            localVarFormParams['lastName'] = ObjectSerializer.serialize(lastName, "string");
        }

        if (emailAddress !== undefined) {
            localVarFormParams['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }

        if (contactNo !== undefined) {
            localVarFormParams['contactNo'] = ObjectSerializer.serialize(contactNo, "string");
        }

        if (expiredAt !== undefined) {
            localVarFormParams['expiredAt'] = ObjectSerializer.serialize(expiredAt, "Date");
        }

        if (cart !== undefined) {
            localVarFormParams['cart'] = ObjectSerializer.serialize(cart, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Transaction;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Transaction");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
