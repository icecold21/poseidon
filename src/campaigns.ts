/**
 * Hapz Campaign API
 * This is the Campaign API for Hapz.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest from 'request'
import http from 'http'
import Promise from 'bluebird';

let defaultBasePath = process.env.CAMPAIGN_MANAGEMENT_SERVICE_API!;

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AddOn {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'campaign'?: Campaign;
    'name'?: string;
    'allowMultipleSelection'?: boolean;
    'allowMultipleQuantity'?: boolean;
    'sortKey'?: number;
    'addOnOptions'?: Array<AddOnOption>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "Campaign"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "allowMultipleSelection",
            "baseName": "allowMultipleSelection",
            "type": "boolean"
        },
        {
            "name": "allowMultipleQuantity",
            "baseName": "allowMultipleQuantity",
            "type": "boolean"
        },
        {
            "name": "sortKey",
            "baseName": "sortKey",
            "type": "number"
        },
        {
            "name": "addOnOptions",
            "baseName": "addOnOptions",
            "type": "Array<AddOnOption>"
        }    ];

    static getAttributeTypeMap() {
        return AddOn.attributeTypeMap;
    }
}

export class AddOnDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'allowMultipleSelection'?: boolean;
    'allowMultipleQuantity'?: boolean;
    'sortKey'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "allowMultipleSelection",
            "baseName": "allowMultipleSelection",
            "type": "boolean"
        },
        {
            "name": "allowMultipleQuantity",
            "baseName": "allowMultipleQuantity",
            "type": "boolean"
        },
        {
            "name": "sortKey",
            "baseName": "sortKey",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AddOnDto.attributeTypeMap;
    }
}

export class AddOnOption {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'addOn'?: AddOn;
    'name'?: string;
    'image'?: string;
    'description'?: string;
    'sortKey'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "addOn",
            "baseName": "addOn",
            "type": "AddOn"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "sortKey",
            "baseName": "sortKey",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AddOnOption.attributeTypeMap;
    }
}

export class AddOnOptionDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'image'?: string;
    'description'?: string;
    'sortKey'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "sortKey",
            "baseName": "sortKey",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AddOnOptionDto.attributeTypeMap;
    }
}

export class BaseDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return BaseDto.attributeTypeMap;
    }
}

export class Campaign {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'owner'?: string;
    'aliasId'?: string;
    'name'?: string;
    'description'?: string;
    'category'?: CampaignCategory;
    'subcategory'?: CampaignSubCategory;
    'bannerImage1800x562'?: string;
    'bannerImage800x533'?: string;
    'images'?: Array<CampaignImage>;
    'startDateTime'?: Date;
    'startDateTimeOffset'?: string;
    'endDateTime'?: Date;
    'endDateTimeOffset'?: string;
    'currency'?: string;
    'campaignFinancial'?: CampaignFinancial;
    'publishedAt'?: Date;
    'publishedBy'?: string;
    'featuredAt'?: Date;
    'featuredBy'?: string;
    'merchant'?: CampaignMerchant;
    'eventInsurance'?: boolean;
    'itinerary'?: string;
    'additionalInformation'?: string;
    'termsAndConditions'?: string;
    'ambassadorContent'?: string;
    'creditsPercentage'?: number;
    'publicListing'?: boolean;
    'redemptionDatabaseEnabled'?: boolean;
    'redemptionDatabaseSynchronisedAt'?: Date;
    'timeslots'?: Array<CampaignTimeslot>;
    'pricingCategories'?: Array<PricingCategory>;
    'pricingPackages'?: Array<PricingPackage>;
    'tags'?: Array<CampaignTag>;
    'registrationFields'?: Array<RegistrationField>;
    'addOns'?: Array<AddOn>;
    'ticketDistributionSpreadsheets'?: Array<TicketDistributionSpreadsheet>;
    'campaignInventoryLedgerSummary'?: CampaignInventoryLedgerSummary;
    'campaignSummaries'?: Array<CampaignSummary>;
    'featured'?: boolean;
    'published'?: boolean;
    'eticketTemplates'?: Array<ETicketTemplate>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "aliasId",
            "baseName": "aliasId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "CampaignCategory"
        },
        {
            "name": "subcategory",
            "baseName": "subcategory",
            "type": "CampaignSubCategory"
        },
        {
            "name": "bannerImage1800x562",
            "baseName": "bannerImage1800x562",
            "type": "string"
        },
        {
            "name": "bannerImage800x533",
            "baseName": "bannerImage800x533",
            "type": "string"
        },
        {
            "name": "images",
            "baseName": "images",
            "type": "Array<CampaignImage>"
        },
        {
            "name": "startDateTime",
            "baseName": "startDateTime",
            "type": "Date"
        },
        {
            "name": "startDateTimeOffset",
            "baseName": "startDateTimeOffset",
            "type": "string"
        },
        {
            "name": "endDateTime",
            "baseName": "endDateTime",
            "type": "Date"
        },
        {
            "name": "endDateTimeOffset",
            "baseName": "endDateTimeOffset",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "campaignFinancial",
            "baseName": "campaignFinancial",
            "type": "CampaignFinancial"
        },
        {
            "name": "publishedAt",
            "baseName": "publishedAt",
            "type": "Date"
        },
        {
            "name": "publishedBy",
            "baseName": "publishedBy",
            "type": "string"
        },
        {
            "name": "featuredAt",
            "baseName": "featuredAt",
            "type": "Date"
        },
        {
            "name": "featuredBy",
            "baseName": "featuredBy",
            "type": "string"
        },
        {
            "name": "merchant",
            "baseName": "merchant",
            "type": "CampaignMerchant"
        },
        {
            "name": "eventInsurance",
            "baseName": "eventInsurance",
            "type": "boolean"
        },
        {
            "name": "itinerary",
            "baseName": "itinerary",
            "type": "string"
        },
        {
            "name": "additionalInformation",
            "baseName": "additionalInformation",
            "type": "string"
        },
        {
            "name": "termsAndConditions",
            "baseName": "termsAndConditions",
            "type": "string"
        },
        {
            "name": "ambassadorContent",
            "baseName": "ambassadorContent",
            "type": "string"
        },
        {
            "name": "creditsPercentage",
            "baseName": "creditsPercentage",
            "type": "number"
        },
        {
            "name": "publicListing",
            "baseName": "publicListing",
            "type": "boolean"
        },
        {
            "name": "redemptionDatabaseEnabled",
            "baseName": "redemptionDatabaseEnabled",
            "type": "boolean"
        },
        {
            "name": "redemptionDatabaseSynchronisedAt",
            "baseName": "redemptionDatabaseSynchronisedAt",
            "type": "Date"
        },
        {
            "name": "timeslots",
            "baseName": "timeslots",
            "type": "Array<CampaignTimeslot>"
        },
        {
            "name": "pricingCategories",
            "baseName": "pricingCategories",
            "type": "Array<PricingCategory>"
        },
        {
            "name": "pricingPackages",
            "baseName": "pricingPackages",
            "type": "Array<PricingPackage>"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<CampaignTag>"
        },
        {
            "name": "registrationFields",
            "baseName": "registrationFields",
            "type": "Array<RegistrationField>"
        },
        {
            "name": "addOns",
            "baseName": "addOns",
            "type": "Array<AddOn>"
        },
        {
            "name": "ticketDistributionSpreadsheets",
            "baseName": "ticketDistributionSpreadsheets",
            "type": "Array<TicketDistributionSpreadsheet>"
        },
        {
            "name": "campaignInventoryLedgerSummary",
            "baseName": "campaignInventoryLedgerSummary",
            "type": "CampaignInventoryLedgerSummary"
        },
        {
            "name": "campaignSummaries",
            "baseName": "campaignSummaries",
            "type": "Array<CampaignSummary>"
        },
        {
            "name": "featured",
            "baseName": "featured",
            "type": "boolean"
        },
        {
            "name": "published",
            "baseName": "published",
            "type": "boolean"
        },
        {
            "name": "eticketTemplates",
            "baseName": "eticketTemplates",
            "type": "Array<ETicketTemplate>"
        }    ];

    static getAttributeTypeMap() {
        return Campaign.attributeTypeMap;
    }
}

export class CampaignCategory {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'owner'?: string;
    'campaigns'?: Array<Campaign>;
    'name'?: string;
    'url'?: string;
    'subcategories'?: Array<CampaignSubCategory>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "campaigns",
            "baseName": "campaigns",
            "type": "Array<Campaign>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "subcategories",
            "baseName": "subcategories",
            "type": "Array<CampaignSubCategory>"
        }    ];

    static getAttributeTypeMap() {
        return CampaignCategory.attributeTypeMap;
    }
}

export class CampaignCategoryCount {
    'category'?: CampaignCategoryDto;
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "CampaignCategoryDto"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CampaignCategoryCount.attributeTypeMap;
    }
}

export class CampaignCategoryDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'url'?: string;
    'subcategories'?: Array<CampaignSubCategoryDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "subcategories",
            "baseName": "subcategories",
            "type": "Array<CampaignSubCategoryDto>"
        }    ];

    static getAttributeTypeMap() {
        return CampaignCategoryDto.attributeTypeMap;
    }
}

export class CampaignDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'aliasId'?: string;
    'name'?: string;
    'description'?: string;
    'category'?: CampaignCategoryDto;
    'subcategory'?: CampaignSubCategoryDto;
    'bannerImage1800x562'?: Document;
    'bannerImage800x533'?: Document;
    'images'?: Array<Document>;
    'startDateTime'?: Date;
    'startDateTimeOffset'?: string;
    'endDateTime'?: Date;
    'endDateTimeOffset'?: string;
    'currency'?: string;
    'featured'?: boolean;
    'published'?: boolean;
    'publishedAt'?: Date;
    'commissionRate'?: number;
    'eventInsurance'?: boolean;
    'itinerary'?: string;
    'additionalInformation'?: string;
    'termsAndConditions'?: string;
    'ambassadorContent'?: string;
    'merchant'?: CampaignMerchantDto;
    'creditsPercentage'?: number;
    'publicListing'?: boolean;
    'redemptionDatabaseEnabled'?: boolean;
    'redemptionDatabaseSynchronisedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "aliasId",
            "baseName": "aliasId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "CampaignCategoryDto"
        },
        {
            "name": "subcategory",
            "baseName": "subcategory",
            "type": "CampaignSubCategoryDto"
        },
        {
            "name": "bannerImage1800x562",
            "baseName": "bannerImage1800x562",
            "type": "Document"
        },
        {
            "name": "bannerImage800x533",
            "baseName": "bannerImage800x533",
            "type": "Document"
        },
        {
            "name": "images",
            "baseName": "images",
            "type": "Array<Document>"
        },
        {
            "name": "startDateTime",
            "baseName": "startDateTime",
            "type": "Date"
        },
        {
            "name": "startDateTimeOffset",
            "baseName": "startDateTimeOffset",
            "type": "string"
        },
        {
            "name": "endDateTime",
            "baseName": "endDateTime",
            "type": "Date"
        },
        {
            "name": "endDateTimeOffset",
            "baseName": "endDateTimeOffset",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "featured",
            "baseName": "featured",
            "type": "boolean"
        },
        {
            "name": "published",
            "baseName": "published",
            "type": "boolean"
        },
        {
            "name": "publishedAt",
            "baseName": "publishedAt",
            "type": "Date"
        },
        {
            "name": "commissionRate",
            "baseName": "commissionRate",
            "type": "number"
        },
        {
            "name": "eventInsurance",
            "baseName": "eventInsurance",
            "type": "boolean"
        },
        {
            "name": "itinerary",
            "baseName": "itinerary",
            "type": "string"
        },
        {
            "name": "additionalInformation",
            "baseName": "additionalInformation",
            "type": "string"
        },
        {
            "name": "termsAndConditions",
            "baseName": "termsAndConditions",
            "type": "string"
        },
        {
            "name": "ambassadorContent",
            "baseName": "ambassadorContent",
            "type": "string"
        },
        {
            "name": "merchant",
            "baseName": "merchant",
            "type": "CampaignMerchantDto"
        },
        {
            "name": "creditsPercentage",
            "baseName": "creditsPercentage",
            "type": "number"
        },
        {
            "name": "publicListing",
            "baseName": "publicListing",
            "type": "boolean"
        },
        {
            "name": "redemptionDatabaseEnabled",
            "baseName": "redemptionDatabaseEnabled",
            "type": "boolean"
        },
        {
            "name": "redemptionDatabaseSynchronisedAt",
            "baseName": "redemptionDatabaseSynchronisedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CampaignDto.attributeTypeMap;
    }
}

export class CampaignFinancial {
    'transactionFeeChargee'?: CampaignFinancial.TransactionFeeChargeeEnum;
    'userTransactionFeePercentage'?: number;
    'userTransactionFeeFixed'?: number;
    'mastercardVisaTransactionFeePercentage'?: number;
    'mastercardVisaTransactionFeeFixed'?: number;
    'amexTransactionFeePercentage'?: number;
    'amexTransactionFeeFixed'?: number;
    'marketingCommission'?: number;
    'distributionCommission'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionFeeChargee",
            "baseName": "transactionFeeChargee",
            "type": "CampaignFinancial.TransactionFeeChargeeEnum"
        },
        {
            "name": "userTransactionFeePercentage",
            "baseName": "userTransactionFeePercentage",
            "type": "number"
        },
        {
            "name": "userTransactionFeeFixed",
            "baseName": "userTransactionFeeFixed",
            "type": "number"
        },
        {
            "name": "mastercardVisaTransactionFeePercentage",
            "baseName": "mastercardVisaTransactionFeePercentage",
            "type": "number"
        },
        {
            "name": "mastercardVisaTransactionFeeFixed",
            "baseName": "mastercardVisaTransactionFeeFixed",
            "type": "number"
        },
        {
            "name": "amexTransactionFeePercentage",
            "baseName": "amexTransactionFeePercentage",
            "type": "number"
        },
        {
            "name": "amexTransactionFeeFixed",
            "baseName": "amexTransactionFeeFixed",
            "type": "number"
        },
        {
            "name": "marketingCommission",
            "baseName": "marketingCommission",
            "type": "number"
        },
        {
            "name": "distributionCommission",
            "baseName": "distributionCommission",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CampaignFinancial.attributeTypeMap;
    }
}

export namespace CampaignFinancial {
    export enum TransactionFeeChargeeEnum {
        MERCHANT = <any> 'MERCHANT',
        USER = <any> 'USER'
    }
}
export class CampaignFinancialDto {
    'transactionFeeChargee'?: CampaignFinancialDto.TransactionFeeChargeeEnum;
    'userTransactionFeePercentage'?: number;
    'userTransactionFeeFixed'?: number;
    'mastercardVisaTransactionFeePercentage'?: number;
    'mastercardVisaTransactionFeeFixed'?: number;
    'amexTransactionFeePercentage'?: number;
    'amexTransactionFeeFixed'?: number;
    'marketingCommission'?: number;
    'distributionCommission'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionFeeChargee",
            "baseName": "transactionFeeChargee",
            "type": "CampaignFinancialDto.TransactionFeeChargeeEnum"
        },
        {
            "name": "userTransactionFeePercentage",
            "baseName": "userTransactionFeePercentage",
            "type": "number"
        },
        {
            "name": "userTransactionFeeFixed",
            "baseName": "userTransactionFeeFixed",
            "type": "number"
        },
        {
            "name": "mastercardVisaTransactionFeePercentage",
            "baseName": "mastercardVisaTransactionFeePercentage",
            "type": "number"
        },
        {
            "name": "mastercardVisaTransactionFeeFixed",
            "baseName": "mastercardVisaTransactionFeeFixed",
            "type": "number"
        },
        {
            "name": "amexTransactionFeePercentage",
            "baseName": "amexTransactionFeePercentage",
            "type": "number"
        },
        {
            "name": "amexTransactionFeeFixed",
            "baseName": "amexTransactionFeeFixed",
            "type": "number"
        },
        {
            "name": "marketingCommission",
            "baseName": "marketingCommission",
            "type": "number"
        },
        {
            "name": "distributionCommission",
            "baseName": "distributionCommission",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CampaignFinancialDto.attributeTypeMap;
    }
}

export namespace CampaignFinancialDto {
    export enum TransactionFeeChargeeEnum {
        MERCHANT = <any> 'MERCHANT',
        USER = <any> 'USER'
    }
}
export class CampaignImage {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'campaign'?: Campaign;
    'image'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "Campaign"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignImage.attributeTypeMap;
    }
}

export class CampaignInventoryLedgerSummary {
    'campaign'?: Campaign;
    'totalQuantity'?: number;
    'totalRedeemedQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "Campaign"
        },
        {
            "name": "totalQuantity",
            "baseName": "totalQuantity",
            "type": "number"
        },
        {
            "name": "totalRedeemedQuantity",
            "baseName": "totalRedeemedQuantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CampaignInventoryLedgerSummary.attributeTypeMap;
    }
}

export class CampaignMerchant {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignMerchant.attributeTypeMap;
    }
}

export class CampaignMerchantDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignMerchantDto.attributeTypeMap;
    }
}

export class CampaignSubCategory {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'owner'?: string;
    'campaignCategory'?: CampaignCategory;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "campaignCategory",
            "baseName": "campaignCategory",
            "type": "CampaignCategory"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignSubCategory.attributeTypeMap;
    }
}

export class CampaignSubCategoryDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CampaignSubCategoryDto.attributeTypeMap;
    }
}

export class CampaignSummary {
    'campaign'?: string;
    'category'?: string;
    'subcategory'?: string;
    'tag'?: string;
    'timeslot'?: string;
    'startDateTime'?: Date;
    'startDateTimeOffset'?: string;
    'endDateTime'?: Date;
    'endDateTimeOffset'?: string;
    'expiresAt'?: Date;
    'currency'?: string;
    'price'?: number;
    'maximumPrice'?: number;
    'savings'?: number;
    'featured'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "subcategory",
            "baseName": "subcategory",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "timeslot",
            "baseName": "timeslot",
            "type": "string"
        },
        {
            "name": "startDateTime",
            "baseName": "startDateTime",
            "type": "Date"
        },
        {
            "name": "startDateTimeOffset",
            "baseName": "startDateTimeOffset",
            "type": "string"
        },
        {
            "name": "endDateTime",
            "baseName": "endDateTime",
            "type": "Date"
        },
        {
            "name": "endDateTimeOffset",
            "baseName": "endDateTimeOffset",
            "type": "string"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "maximumPrice",
            "baseName": "maximumPrice",
            "type": "number"
        },
        {
            "name": "savings",
            "baseName": "savings",
            "type": "number"
        },
        {
            "name": "featured",
            "baseName": "featured",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CampaignSummary.attributeTypeMap;
    }
}

export class CampaignTag {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'campaign'?: Campaign;
    'tag'?: Tag;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "Campaign"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "Tag"
        }    ];

    static getAttributeTypeMap() {
        return CampaignTag.attributeTypeMap;
    }
}

export class CampaignTimeslot {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'campaign'?: Campaign;
    'pricingPackage'?: PricingPackage;
    'startDateTime'?: Date;
    'startDateTimeOffset'?: string;
    'endDateTime'?: Date;
    'endDateTimeOffset'?: string;
    'expiresAt'?: Date;
    'location'?: Location;
    'redemptionExpiresAfter'?: number;
    'pricings'?: Array<Pricing>;
    'redemptions'?: Array<Redemption>;
    'offsetStartDateTime'?: Date;
    'offsetEndDateTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "Campaign"
        },
        {
            "name": "pricingPackage",
            "baseName": "pricingPackage",
            "type": "PricingPackage"
        },
        {
            "name": "startDateTime",
            "baseName": "startDateTime",
            "type": "Date"
        },
        {
            "name": "startDateTimeOffset",
            "baseName": "startDateTimeOffset",
            "type": "string"
        },
        {
            "name": "endDateTime",
            "baseName": "endDateTime",
            "type": "Date"
        },
        {
            "name": "endDateTimeOffset",
            "baseName": "endDateTimeOffset",
            "type": "string"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "Location"
        },
        {
            "name": "redemptionExpiresAfter",
            "baseName": "redemptionExpiresAfter",
            "type": "number"
        },
        {
            "name": "pricings",
            "baseName": "pricings",
            "type": "Array<Pricing>"
        },
        {
            "name": "redemptions",
            "baseName": "redemptions",
            "type": "Array<Redemption>"
        },
        {
            "name": "offsetStartDateTime",
            "baseName": "offsetStartDateTime",
            "type": "Date"
        },
        {
            "name": "offsetEndDateTime",
            "baseName": "offsetEndDateTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CampaignTimeslot.attributeTypeMap;
    }
}

export class CampaignTimeslotDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'pricingPackage'?: PricingPackageDto;
    'startDateTime'?: Date;
    'startDateTimeOffset'?: string;
    'endDateTime'?: Date;
    'endDateTimeOffset'?: string;
    'expiresAt'?: Date;
    'location'?: LocationDto;
    'redemptionExpiresAfter'?: number;
    'pricings'?: Array<PricingDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "pricingPackage",
            "baseName": "pricingPackage",
            "type": "PricingPackageDto"
        },
        {
            "name": "startDateTime",
            "baseName": "startDateTime",
            "type": "Date"
        },
        {
            "name": "startDateTimeOffset",
            "baseName": "startDateTimeOffset",
            "type": "string"
        },
        {
            "name": "endDateTime",
            "baseName": "endDateTime",
            "type": "Date"
        },
        {
            "name": "endDateTimeOffset",
            "baseName": "endDateTimeOffset",
            "type": "string"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "LocationDto"
        },
        {
            "name": "redemptionExpiresAfter",
            "baseName": "redemptionExpiresAfter",
            "type": "number"
        },
        {
            "name": "pricings",
            "baseName": "pricings",
            "type": "Array<PricingDto>"
        }    ];

    static getAttributeTypeMap() {
        return CampaignTimeslotDto.attributeTypeMap;
    }
}

export class CardIssuer {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'name'?: string;
    'issuerIdentificationNumbers'?: Array<IssuerIdentificationNumber>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "issuerIdentificationNumbers",
            "baseName": "issuerIdentificationNumbers",
            "type": "Array<IssuerIdentificationNumber>"
        }    ];

    static getAttributeTypeMap() {
        return CardIssuer.attributeTypeMap;
    }
}

export class CardIssuerDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'issuerIdentificationNumbers'?: Array<IssuerIdentificationNumberDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "issuerIdentificationNumbers",
            "baseName": "issuerIdentificationNumbers",
            "type": "Array<IssuerIdentificationNumberDto>"
        }    ];

    static getAttributeTypeMap() {
        return CardIssuerDto.attributeTypeMap;
    }
}

export class Column {
    'data'?: string;
    'name'?: string;
    'searchable': boolean;
    'orderable': boolean;
    'search': Search;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "searchable",
            "baseName": "searchable",
            "type": "boolean"
        },
        {
            "name": "orderable",
            "baseName": "orderable",
            "type": "boolean"
        },
        {
            "name": "search",
            "baseName": "search",
            "type": "Search"
        }    ];

    static getAttributeTypeMap() {
        return Column.attributeTypeMap;
    }
}

export class DataTablesInput {
    'draw': number;
    'start': number;
    'length': number;
    'search': Search;
    'order'?: Array<Order>;
    'columns'?: Array<Column>;
    'columnsAsMap'?: { [key: string]: Column; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "length",
            "baseName": "length",
            "type": "number"
        },
        {
            "name": "search",
            "baseName": "search",
            "type": "Search"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Array<Order>"
        },
        {
            "name": "columns",
            "baseName": "columns",
            "type": "Array<Column>"
        },
        {
            "name": "columnsAsMap",
            "baseName": "columnsAsMap",
            "type": "{ [key: string]: Column; }"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesInput.attributeTypeMap;
    }
}

export class DataTablesOutput {
    'draw'?: number;
    'recordsTotal'?: number;
    'recordsFiltered'?: number;
    'data'?: Array<any>;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "recordsTotal",
            "baseName": "recordsTotal",
            "type": "number"
        },
        {
            "name": "recordsFiltered",
            "baseName": "recordsFiltered",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<any>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesOutput.attributeTypeMap;
    }
}

export class DataTablesOutputCampaignCategoryDto {
    'draw'?: number;
    'recordsTotal'?: number;
    'recordsFiltered'?: number;
    'data'?: Array<CampaignCategoryDto>;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "recordsTotal",
            "baseName": "recordsTotal",
            "type": "number"
        },
        {
            "name": "recordsFiltered",
            "baseName": "recordsFiltered",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CampaignCategoryDto>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesOutputCampaignCategoryDto.attributeTypeMap;
    }
}

export class DataTablesOutputCampaignDto {
    'draw'?: number;
    'recordsTotal'?: number;
    'recordsFiltered'?: number;
    'data'?: Array<CampaignDto>;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "recordsTotal",
            "baseName": "recordsTotal",
            "type": "number"
        },
        {
            "name": "recordsFiltered",
            "baseName": "recordsFiltered",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CampaignDto>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesOutputCampaignDto.attributeTypeMap;
    }
}

export class DataTablesOutputLocationDto {
    'draw'?: number;
    'recordsTotal'?: number;
    'recordsFiltered'?: number;
    'data'?: Array<LocationDto>;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "recordsTotal",
            "baseName": "recordsTotal",
            "type": "number"
        },
        {
            "name": "recordsFiltered",
            "baseName": "recordsFiltered",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<LocationDto>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesOutputLocationDto.attributeTypeMap;
    }
}

export class DataTablesOutputTagDto {
    'draw'?: number;
    'recordsTotal'?: number;
    'recordsFiltered'?: number;
    'data'?: Array<TagDto>;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "recordsTotal",
            "baseName": "recordsTotal",
            "type": "number"
        },
        {
            "name": "recordsFiltered",
            "baseName": "recordsFiltered",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<TagDto>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesOutputTagDto.attributeTypeMap;
    }
}

export class Document {
    'id'?: string;
    'type'?: Document.TypeEnum;
    'filename'?: string;
    'contentType'?: string;
    'contentLength'?: number;
    'preSignedUrl'?: string;
    'preSignedUrlExpiredAt'?: number;
    'originalDocumentId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "Document.TypeEnum"
        },
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "contentType",
            "baseName": "contentType",
            "type": "string"
        },
        {
            "name": "contentLength",
            "baseName": "contentLength",
            "type": "number"
        },
        {
            "name": "preSignedUrl",
            "baseName": "preSignedUrl",
            "type": "string"
        },
        {
            "name": "preSignedUrlExpiredAt",
            "baseName": "preSignedUrlExpiredAt",
            "type": "number"
        },
        {
            "name": "originalDocumentId",
            "baseName": "originalDocumentId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Document.attributeTypeMap;
    }
}

export namespace Document {
    export enum TypeEnum {
        IMAGE = <any> 'IMAGE',
        TICKET = <any> 'TICKET',
        TICKETTEMPLATE = <any> 'TICKET_TEMPLATE',
        ATTACHMENT = <any> 'ATTACHMENT'
    }
}
export class ETicketTemplate {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'campaign'?: Campaign;
    'name'?: string;
    'document'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "Campaign"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "document",
            "baseName": "document",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ETicketTemplate.attributeTypeMap;
    }
}

export class ETicketTemplateDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'document'?: Document;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "document",
            "baseName": "document",
            "type": "Document"
        }    ];

    static getAttributeTypeMap() {
        return ETicketTemplateDto.attributeTypeMap;
    }
}

export class ErrorResponse {
    'errorCode'?: string;
    'errorDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errorCode",
            "baseName": "error_code",
            "type": "string"
        },
        {
            "name": "errorDescription",
            "baseName": "error_description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ErrorResponse.attributeTypeMap;
    }
}

export class Event {
    'id'?: string;
    'aliasId'?: string;
    'name'?: string;
    'category'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "aliasId",
            "baseName": "aliasId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Event.attributeTypeMap;
    }
}

export class InventoryLedger {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'pricing'?: Pricing;
    'cardIssuer'?: string;
    'pricingCardIssuer'?: PricingCardIssuer;
    'quantity'?: number;
    'expiresAt'?: Date;
    'redeemedAt'?: Date;
    'invalidatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "pricing",
            "baseName": "pricing",
            "type": "Pricing"
        },
        {
            "name": "cardIssuer",
            "baseName": "cardIssuer",
            "type": "string"
        },
        {
            "name": "pricingCardIssuer",
            "baseName": "pricingCardIssuer",
            "type": "PricingCardIssuer"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "redeemedAt",
            "baseName": "redeemedAt",
            "type": "Date"
        },
        {
            "name": "invalidatedAt",
            "baseName": "invalidatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return InventoryLedger.attributeTypeMap;
    }
}

export class InventoryLedgerDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'cardIssuer'?: string;
    'quantity'?: number;
    'expiresAt'?: Date;
    'redeemedAt'?: Date;
    'invalidatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "cardIssuer",
            "baseName": "cardIssuer",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "redeemedAt",
            "baseName": "redeemedAt",
            "type": "Date"
        },
        {
            "name": "invalidatedAt",
            "baseName": "invalidatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return InventoryLedgerDto.attributeTypeMap;
    }
}

export class IssuerIdentificationNumber {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'cardIssuer'?: CardIssuer;
    'issuerIdentificationNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "cardIssuer",
            "baseName": "cardIssuer",
            "type": "CardIssuer"
        },
        {
            "name": "issuerIdentificationNumber",
            "baseName": "issuerIdentificationNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssuerIdentificationNumber.attributeTypeMap;
    }
}

export class IssuerIdentificationNumberDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'issuerIdentificationNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "issuerIdentificationNumber",
            "baseName": "issuerIdentificationNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssuerIdentificationNumberDto.attributeTypeMap;
    }
}

export class ItemsPageResponse {
    'start'?: number;
    'rows'?: number;
    'total'?: number;
    'items'?: Array<BaseDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<BaseDto>"
        }    ];

    static getAttributeTypeMap() {
        return ItemsPageResponse.attributeTypeMap;
    }
}

export class ItemsPageResponseCampaignCategoryDto {
    'start'?: number;
    'rows'?: number;
    'total'?: number;
    'items'?: Array<CampaignCategoryDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<CampaignCategoryDto>"
        }    ];

    static getAttributeTypeMap() {
        return ItemsPageResponseCampaignCategoryDto.attributeTypeMap;
    }
}

export class ItemsPageResponseCampaignDto {
    'start'?: number;
    'rows'?: number;
    'total'?: number;
    'items'?: Array<CampaignDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<CampaignDto>"
        }    ];

    static getAttributeTypeMap() {
        return ItemsPageResponseCampaignDto.attributeTypeMap;
    }
}

export class ItemsPageResponseTagDto {
    'start'?: number;
    'rows'?: number;
    'total'?: number;
    'items'?: Array<TagDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<TagDto>"
        }    ];

    static getAttributeTypeMap() {
        return ItemsPageResponseTagDto.attributeTypeMap;
    }
}

export class Location {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'owner'?: string;
    'name'?: string;
    'image'?: string;
    'postalAddress'?: string;
    'postalCode'?: string;
    'city'?: string;
    'state'?: string;
    'iso3166CountryCode'?: string;
    'latitude'?: number;
    'longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "postalAddress",
            "baseName": "postalAddress",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "iso3166CountryCode",
            "baseName": "iso3166CountryCode",
            "type": "string"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Location.attributeTypeMap;
    }
}

export class LocationDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'image'?: string;
    'postalAddress'?: string;
    'postalCode'?: string;
    'city'?: string;
    'state'?: string;
    'iso3166CountryCode'?: string;
    'latitude'?: number;
    'longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "postalAddress",
            "baseName": "postalAddress",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "iso3166CountryCode",
            "baseName": "iso3166CountryCode",
            "type": "string"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LocationDto.attributeTypeMap;
    }
}

export class OnlineRedemptionCodeDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'redemptionCode'?: string;
    'pricingCategory'?: PricingCategoryDto;
    'redeemed'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "redemptionCode",
            "baseName": "redemptionCode",
            "type": "string"
        },
        {
            "name": "pricingCategory",
            "baseName": "pricingCategory",
            "type": "PricingCategoryDto"
        },
        {
            "name": "redeemed",
            "baseName": "redeemed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OnlineRedemptionCodeDto.attributeTypeMap;
    }
}

export class Order {
    'column': number;
    'dir': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "column",
            "baseName": "column",
            "type": "number"
        },
        {
            "name": "dir",
            "baseName": "dir",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Order.attributeTypeMap;
    }
}

export class Page {
    'totalElements'?: number;
    'totalPages'?: number;
    'size'?: number;
    'content'?: Array<any>;
    'numberOfElements'?: number;
    'first'?: boolean;
    'number'?: number;
    'sort'?: Sort;
    'pageable'?: Pageable;
    'last'?: boolean;
    'empty'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<any>"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "pageable",
            "baseName": "pageable",
            "type": "Pageable"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Page.attributeTypeMap;
    }
}

export class PageEvent {
    'totalElements'?: number;
    'totalPages'?: number;
    'size'?: number;
    'content'?: Array<Event>;
    'numberOfElements'?: number;
    'first'?: boolean;
    'number'?: number;
    'sort'?: Sort;
    'pageable'?: Pageable;
    'last'?: boolean;
    'empty'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<Event>"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "pageable",
            "baseName": "pageable",
            "type": "Pageable"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PageEvent.attributeTypeMap;
    }
}

export class Pageable {
    'offset'?: number;
    'sort'?: Sort;
    'unpaged'?: boolean;
    'paged'?: boolean;
    'pageSize'?: number;
    'pageNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "unpaged",
            "baseName": "unpaged",
            "type": "boolean"
        },
        {
            "name": "paged",
            "baseName": "paged",
            "type": "boolean"
        },
        {
            "name": "pageSize",
            "baseName": "pageSize",
            "type": "number"
        },
        {
            "name": "pageNumber",
            "baseName": "pageNumber",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Pageable.attributeTypeMap;
    }
}

export class Pricing {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'campaignTimeslot'?: CampaignTimeslot;
    'pricingCategory'?: PricingCategory;
    'salesChannel'?: Pricing.SalesChannelEnum;
    'privateDescription'?: string;
    'images'?: Array<PricingImage>;
    'entitlements'?: string;
    'currentInventory'?: number;
    'totalInventory'?: number;
    'ticketsIssuedPerInventory'?: number;
    'validFrom'?: Date;
    'validTo'?: Date;
    'inventoryAvailableFrom'?: Date;
    'inventoryAvailableTo'?: Date;
    'password'?: string;
    'pricingIntervals'?: Array<PricingInterval>;
    'pricingAddOns'?: Array<PricingAddOn>;
    'pricingCardIssuers'?: Array<PricingCardIssuer>;
    'inventoryLedgers'?: Array<InventoryLedger>;
    'valid'?: boolean;
    'inventoryAvailable'?: boolean;
    'currentPricingInterval'?: PricingInterval;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "campaignTimeslot",
            "baseName": "campaignTimeslot",
            "type": "CampaignTimeslot"
        },
        {
            "name": "pricingCategory",
            "baseName": "pricingCategory",
            "type": "PricingCategory"
        },
        {
            "name": "salesChannel",
            "baseName": "salesChannel",
            "type": "Pricing.SalesChannelEnum"
        },
        {
            "name": "privateDescription",
            "baseName": "privateDescription",
            "type": "string"
        },
        {
            "name": "images",
            "baseName": "images",
            "type": "Array<PricingImage>"
        },
        {
            "name": "entitlements",
            "baseName": "entitlements",
            "type": "string"
        },
        {
            "name": "currentInventory",
            "baseName": "currentInventory",
            "type": "number"
        },
        {
            "name": "totalInventory",
            "baseName": "totalInventory",
            "type": "number"
        },
        {
            "name": "ticketsIssuedPerInventory",
            "baseName": "ticketsIssuedPerInventory",
            "type": "number"
        },
        {
            "name": "validFrom",
            "baseName": "validFrom",
            "type": "Date"
        },
        {
            "name": "validTo",
            "baseName": "validTo",
            "type": "Date"
        },
        {
            "name": "inventoryAvailableFrom",
            "baseName": "inventoryAvailableFrom",
            "type": "Date"
        },
        {
            "name": "inventoryAvailableTo",
            "baseName": "inventoryAvailableTo",
            "type": "Date"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "pricingIntervals",
            "baseName": "pricingIntervals",
            "type": "Array<PricingInterval>"
        },
        {
            "name": "pricingAddOns",
            "baseName": "pricingAddOns",
            "type": "Array<PricingAddOn>"
        },
        {
            "name": "pricingCardIssuers",
            "baseName": "pricingCardIssuers",
            "type": "Array<PricingCardIssuer>"
        },
        {
            "name": "inventoryLedgers",
            "baseName": "inventoryLedgers",
            "type": "Array<InventoryLedger>"
        },
        {
            "name": "valid",
            "baseName": "valid",
            "type": "boolean"
        },
        {
            "name": "inventoryAvailable",
            "baseName": "inventoryAvailable",
            "type": "boolean"
        },
        {
            "name": "currentPricingInterval",
            "baseName": "currentPricingInterval",
            "type": "PricingInterval"
        }    ];

    static getAttributeTypeMap() {
        return Pricing.attributeTypeMap;
    }
}

export namespace Pricing {
    export enum SalesChannelEnum {
        PUBLICUSER = <any> 'PUBLIC_USER',
        PRIVATEUSER = <any> 'PRIVATE_USER',
        MERCHANT = <any> 'MERCHANT',
        MARKETING = <any> 'MARKETING',
        DISTRIBUTION = <any> 'DISTRIBUTION',
        ONSITE = <any> 'ONSITE'
    }
}
export class PricingAddOn {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'pricing'?: Pricing;
    'addOn'?: AddOn;
    'pricingAddOnOptions'?: Array<PricingAddOnOption>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "pricing",
            "baseName": "pricing",
            "type": "Pricing"
        },
        {
            "name": "addOn",
            "baseName": "addOn",
            "type": "AddOn"
        },
        {
            "name": "pricingAddOnOptions",
            "baseName": "pricingAddOnOptions",
            "type": "Array<PricingAddOnOption>"
        }    ];

    static getAttributeTypeMap() {
        return PricingAddOn.attributeTypeMap;
    }
}

export class PricingAddOnDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'addOn'?: AddOnDto;
    'pricingAddOnOptions'?: Array<PricingAddOnOptionDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "addOn",
            "baseName": "addOn",
            "type": "AddOnDto"
        },
        {
            "name": "pricingAddOnOptions",
            "baseName": "pricingAddOnOptions",
            "type": "Array<PricingAddOnOptionDto>"
        }    ];

    static getAttributeTypeMap() {
        return PricingAddOnDto.attributeTypeMap;
    }
}

export class PricingAddOnOption {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'pricingAddOn'?: PricingAddOn;
    'addOnOption'?: AddOnOption;
    'price'?: number;
    'costPrice'?: number;
    'maximumPrice'?: number;
    'currency'?: string;
    'currentInventory'?: number;
    'totalInventory'?: number;
    'bookingFee'?: number;
    'bookingFeeInPercent'?: boolean;
    'transactionFee'?: number;
    'pricingAddOnOptionInventoryLedgers'?: Array<PricingAddOnOptionInventoryLedger>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "pricingAddOn",
            "baseName": "pricingAddOn",
            "type": "PricingAddOn"
        },
        {
            "name": "addOnOption",
            "baseName": "addOnOption",
            "type": "AddOnOption"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "costPrice",
            "baseName": "costPrice",
            "type": "number"
        },
        {
            "name": "maximumPrice",
            "baseName": "maximumPrice",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "currentInventory",
            "baseName": "currentInventory",
            "type": "number"
        },
        {
            "name": "totalInventory",
            "baseName": "totalInventory",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "bookingFeeInPercent",
            "baseName": "bookingFeeInPercent",
            "type": "boolean"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        },
        {
            "name": "pricingAddOnOptionInventoryLedgers",
            "baseName": "pricingAddOnOptionInventoryLedgers",
            "type": "Array<PricingAddOnOptionInventoryLedger>"
        }    ];

    static getAttributeTypeMap() {
        return PricingAddOnOption.attributeTypeMap;
    }
}

export class PricingAddOnOptionDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'pricingAddOn'?: string;
    'addOnOption'?: AddOnOptionDto;
    'price'?: number;
    'costPrice'?: number;
    'maximumPrice'?: number;
    'currency'?: string;
    'currentInventory'?: number;
    'totalInventory'?: number;
    'bookingFee'?: number;
    'bookingFeeInPercent'?: boolean;
    'transactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "pricingAddOn",
            "baseName": "pricingAddOn",
            "type": "string"
        },
        {
            "name": "addOnOption",
            "baseName": "addOnOption",
            "type": "AddOnOptionDto"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "costPrice",
            "baseName": "costPrice",
            "type": "number"
        },
        {
            "name": "maximumPrice",
            "baseName": "maximumPrice",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "currentInventory",
            "baseName": "currentInventory",
            "type": "number"
        },
        {
            "name": "totalInventory",
            "baseName": "totalInventory",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "bookingFeeInPercent",
            "baseName": "bookingFeeInPercent",
            "type": "boolean"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PricingAddOnOptionDto.attributeTypeMap;
    }
}

export class PricingAddOnOptionInventoryLedger {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'pricingAddOnOption'?: PricingAddOnOption;
    'quantity'?: number;
    'expiresAt'?: Date;
    'redeemedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "pricingAddOnOption",
            "baseName": "pricingAddOnOption",
            "type": "PricingAddOnOption"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "redeemedAt",
            "baseName": "redeemedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PricingAddOnOptionInventoryLedger.attributeTypeMap;
    }
}

export class PricingAddOnOptionInventoryLedgerDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'quantity'?: number;
    'expiresAt'?: Date;
    'redeemedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "Date"
        },
        {
            "name": "redeemedAt",
            "baseName": "redeemedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PricingAddOnOptionInventoryLedgerDto.attributeTypeMap;
    }
}

export class PricingCardIssuer {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'pricing'?: Pricing;
    'cardIssuer'?: CardIssuer;
    'value'?: number;
    'currency'?: string;
    'percent'?: boolean;
    'creditedToHapz'?: boolean;
    'currentInventory'?: number;
    'totalInventory'?: number;
    'validFrom'?: Date;
    'validTo'?: Date;
    'inventoryAvailableFrom'?: Date;
    'inventoryAvailableTo'?: Date;
    'minimumQuantity'?: number;
    'quantityIncrement'?: number;
    'maximumQuantity'?: number;
    'sortKey'?: number;
    'inventoryLedgers'?: Array<InventoryLedger>;
    'valid'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "pricing",
            "baseName": "pricing",
            "type": "Pricing"
        },
        {
            "name": "cardIssuer",
            "baseName": "cardIssuer",
            "type": "CardIssuer"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "percent",
            "baseName": "percent",
            "type": "boolean"
        },
        {
            "name": "creditedToHapz",
            "baseName": "creditedToHapz",
            "type": "boolean"
        },
        {
            "name": "currentInventory",
            "baseName": "currentInventory",
            "type": "number"
        },
        {
            "name": "totalInventory",
            "baseName": "totalInventory",
            "type": "number"
        },
        {
            "name": "validFrom",
            "baseName": "validFrom",
            "type": "Date"
        },
        {
            "name": "validTo",
            "baseName": "validTo",
            "type": "Date"
        },
        {
            "name": "inventoryAvailableFrom",
            "baseName": "inventoryAvailableFrom",
            "type": "Date"
        },
        {
            "name": "inventoryAvailableTo",
            "baseName": "inventoryAvailableTo",
            "type": "Date"
        },
        {
            "name": "minimumQuantity",
            "baseName": "minimumQuantity",
            "type": "number"
        },
        {
            "name": "quantityIncrement",
            "baseName": "quantityIncrement",
            "type": "number"
        },
        {
            "name": "maximumQuantity",
            "baseName": "maximumQuantity",
            "type": "number"
        },
        {
            "name": "sortKey",
            "baseName": "sortKey",
            "type": "number"
        },
        {
            "name": "inventoryLedgers",
            "baseName": "inventoryLedgers",
            "type": "Array<InventoryLedger>"
        },
        {
            "name": "valid",
            "baseName": "valid",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PricingCardIssuer.attributeTypeMap;
    }
}

export class PricingCardIssuerDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'cardIssuer'?: CardIssuerDto;
    'value'?: number;
    'currency'?: string;
    'percent'?: boolean;
    'creditedToHapz'?: boolean;
    'currentInventory'?: number;
    'totalInventory'?: number;
    'validFrom'?: Date;
    'validTo'?: Date;
    'valid'?: boolean;
    'inventoryAvailableFrom'?: Date;
    'inventoryAvailableTo'?: Date;
    'minimumQuantity'?: number;
    'quantityIncrement'?: number;
    'maximumQuantity'?: number;
    'sortKey'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "cardIssuer",
            "baseName": "cardIssuer",
            "type": "CardIssuerDto"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "percent",
            "baseName": "percent",
            "type": "boolean"
        },
        {
            "name": "creditedToHapz",
            "baseName": "creditedToHapz",
            "type": "boolean"
        },
        {
            "name": "currentInventory",
            "baseName": "currentInventory",
            "type": "number"
        },
        {
            "name": "totalInventory",
            "baseName": "totalInventory",
            "type": "number"
        },
        {
            "name": "validFrom",
            "baseName": "validFrom",
            "type": "Date"
        },
        {
            "name": "validTo",
            "baseName": "validTo",
            "type": "Date"
        },
        {
            "name": "valid",
            "baseName": "valid",
            "type": "boolean"
        },
        {
            "name": "inventoryAvailableFrom",
            "baseName": "inventoryAvailableFrom",
            "type": "Date"
        },
        {
            "name": "inventoryAvailableTo",
            "baseName": "inventoryAvailableTo",
            "type": "Date"
        },
        {
            "name": "minimumQuantity",
            "baseName": "minimumQuantity",
            "type": "number"
        },
        {
            "name": "quantityIncrement",
            "baseName": "quantityIncrement",
            "type": "number"
        },
        {
            "name": "maximumQuantity",
            "baseName": "maximumQuantity",
            "type": "number"
        },
        {
            "name": "sortKey",
            "baseName": "sortKey",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PricingCardIssuerDto.attributeTypeMap;
    }
}

export class PricingCategory {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'campaign'?: Campaign;
    'name'?: string;
    'description'?: string;
    'sortKey'?: number;
    'defaultPricing'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "Campaign"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "sortKey",
            "baseName": "sortKey",
            "type": "number"
        },
        {
            "name": "defaultPricing",
            "baseName": "defaultPricing",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PricingCategory.attributeTypeMap;
    }
}

export class PricingCategoryDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'description'?: string;
    'sortKey'?: number;
    'defaultPricing'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "sortKey",
            "baseName": "sortKey",
            "type": "number"
        },
        {
            "name": "defaultPricing",
            "baseName": "defaultPricing",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PricingCategoryDto.attributeTypeMap;
    }
}

export class PricingDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'salesChannel'?: PricingDto.SalesChannelEnum;
    'pricingCategory'?: PricingCategoryDto;
    'currentPricingInterval'?: PricingIntervalDto;
    'privateDescription'?: string;
    'entitlements'?: string;
    'currentInventory'?: number;
    'totalInventory'?: number;
    'ticketsIssuedPerInventory'?: number;
    'validFrom'?: Date;
    'validTo'?: Date;
    'valid'?: boolean;
    'inventoryAvailableFrom'?: Date;
    'inventoryAvailableTo'?: Date;
    'inventoryAvailable'?: boolean;
    'password'?: string;
    'images'?: Array<string>;
    'pricingIntervals'?: Array<PricingIntervalDto>;
    'pricingCardIssuers'?: Array<PricingCardIssuerDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "salesChannel",
            "baseName": "salesChannel",
            "type": "PricingDto.SalesChannelEnum"
        },
        {
            "name": "pricingCategory",
            "baseName": "pricingCategory",
            "type": "PricingCategoryDto"
        },
        {
            "name": "currentPricingInterval",
            "baseName": "currentPricingInterval",
            "type": "PricingIntervalDto"
        },
        {
            "name": "privateDescription",
            "baseName": "privateDescription",
            "type": "string"
        },
        {
            "name": "entitlements",
            "baseName": "entitlements",
            "type": "string"
        },
        {
            "name": "currentInventory",
            "baseName": "currentInventory",
            "type": "number"
        },
        {
            "name": "totalInventory",
            "baseName": "totalInventory",
            "type": "number"
        },
        {
            "name": "ticketsIssuedPerInventory",
            "baseName": "ticketsIssuedPerInventory",
            "type": "number"
        },
        {
            "name": "validFrom",
            "baseName": "validFrom",
            "type": "Date"
        },
        {
            "name": "validTo",
            "baseName": "validTo",
            "type": "Date"
        },
        {
            "name": "valid",
            "baseName": "valid",
            "type": "boolean"
        },
        {
            "name": "inventoryAvailableFrom",
            "baseName": "inventoryAvailableFrom",
            "type": "Date"
        },
        {
            "name": "inventoryAvailableTo",
            "baseName": "inventoryAvailableTo",
            "type": "Date"
        },
        {
            "name": "inventoryAvailable",
            "baseName": "inventoryAvailable",
            "type": "boolean"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "images",
            "baseName": "images",
            "type": "Array<string>"
        },
        {
            "name": "pricingIntervals",
            "baseName": "pricingIntervals",
            "type": "Array<PricingIntervalDto>"
        },
        {
            "name": "pricingCardIssuers",
            "baseName": "pricingCardIssuers",
            "type": "Array<PricingCardIssuerDto>"
        }    ];

    static getAttributeTypeMap() {
        return PricingDto.attributeTypeMap;
    }
}

export namespace PricingDto {
    export enum SalesChannelEnum {
        PUBLICUSER = <any> 'PUBLIC_USER',
        PRIVATEUSER = <any> 'PRIVATE_USER',
        MERCHANT = <any> 'MERCHANT',
        MARKETING = <any> 'MARKETING',
        DISTRIBUTION = <any> 'DISTRIBUTION',
        ONSITE = <any> 'ONSITE'
    }
}
export class PricingImage {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'pricing'?: Pricing;
    'image'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "pricing",
            "baseName": "pricing",
            "type": "Pricing"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PricingImage.attributeTypeMap;
    }
}

export class PricingInterval {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'pricing'?: Pricing;
    'validFrom'?: Date;
    'validTo'?: Date;
    'currency'?: string;
    'minimumQuantity'?: number;
    'quantityIncrement'?: number;
    'maximumQuantity'?: number;
    'price'?: number;
    'costPrice'?: number;
    'maximumPrice'?: number;
    'bookingFee'?: number;
    'bookingFeeInPercent'?: boolean;
    'invalidatedAt'?: Date;
    'invalidatedBy'?: string;
    'invalidated'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "pricing",
            "baseName": "pricing",
            "type": "Pricing"
        },
        {
            "name": "validFrom",
            "baseName": "validFrom",
            "type": "Date"
        },
        {
            "name": "validTo",
            "baseName": "validTo",
            "type": "Date"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "minimumQuantity",
            "baseName": "minimumQuantity",
            "type": "number"
        },
        {
            "name": "quantityIncrement",
            "baseName": "quantityIncrement",
            "type": "number"
        },
        {
            "name": "maximumQuantity",
            "baseName": "maximumQuantity",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "costPrice",
            "baseName": "costPrice",
            "type": "number"
        },
        {
            "name": "maximumPrice",
            "baseName": "maximumPrice",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "bookingFeeInPercent",
            "baseName": "bookingFeeInPercent",
            "type": "boolean"
        },
        {
            "name": "invalidatedAt",
            "baseName": "invalidatedAt",
            "type": "Date"
        },
        {
            "name": "invalidatedBy",
            "baseName": "invalidatedBy",
            "type": "string"
        },
        {
            "name": "invalidated",
            "baseName": "invalidated",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PricingInterval.attributeTypeMap;
    }
}

export class PricingIntervalDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'validFrom'?: Date;
    'validTo'?: Date;
    'currency'?: string;
    'minimumQuantity'?: number;
    'quantityIncrement'?: number;
    'maximumQuantity'?: number;
    'minimumPrice'?: number;
    'price'?: number;
    'basePrice'?: number;
    'costPrice'?: number;
    'maximumPrice'?: number;
    'bookingFee'?: number;
    'bookingFeeInPercent'?: boolean;
    'transactionFee'?: number;
    'invalidatedAt'?: Date;
    'invalidatedBy'?: string;
    'invalidated'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "validFrom",
            "baseName": "validFrom",
            "type": "Date"
        },
        {
            "name": "validTo",
            "baseName": "validTo",
            "type": "Date"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "minimumQuantity",
            "baseName": "minimumQuantity",
            "type": "number"
        },
        {
            "name": "quantityIncrement",
            "baseName": "quantityIncrement",
            "type": "number"
        },
        {
            "name": "maximumQuantity",
            "baseName": "maximumQuantity",
            "type": "number"
        },
        {
            "name": "minimumPrice",
            "baseName": "minimumPrice",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "basePrice",
            "baseName": "basePrice",
            "type": "number"
        },
        {
            "name": "costPrice",
            "baseName": "costPrice",
            "type": "number"
        },
        {
            "name": "maximumPrice",
            "baseName": "maximumPrice",
            "type": "number"
        },
        {
            "name": "bookingFee",
            "baseName": "bookingFee",
            "type": "number"
        },
        {
            "name": "bookingFeeInPercent",
            "baseName": "bookingFeeInPercent",
            "type": "boolean"
        },
        {
            "name": "transactionFee",
            "baseName": "transactionFee",
            "type": "number"
        },
        {
            "name": "invalidatedAt",
            "baseName": "invalidatedAt",
            "type": "Date"
        },
        {
            "name": "invalidatedBy",
            "baseName": "invalidatedBy",
            "type": "string"
        },
        {
            "name": "invalidated",
            "baseName": "invalidated",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PricingIntervalDto.attributeTypeMap;
    }
}

export class PricingPackage {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'campaign'?: Campaign;
    'name'?: string;
    'startDateTime'?: Date;
    'startDateTimeOffset'?: string;
    'endDateTime'?: Date;
    'endDateTimeOffset'?: string;
    'sortKey'?: number;
    'defaultPricing'?: boolean;
    'offsetStartDateTime'?: Date;
    'offsetEndDateTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "Campaign"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "startDateTime",
            "baseName": "startDateTime",
            "type": "Date"
        },
        {
            "name": "startDateTimeOffset",
            "baseName": "startDateTimeOffset",
            "type": "string"
        },
        {
            "name": "endDateTime",
            "baseName": "endDateTime",
            "type": "Date"
        },
        {
            "name": "endDateTimeOffset",
            "baseName": "endDateTimeOffset",
            "type": "string"
        },
        {
            "name": "sortKey",
            "baseName": "sortKey",
            "type": "number"
        },
        {
            "name": "defaultPricing",
            "baseName": "defaultPricing",
            "type": "boolean"
        },
        {
            "name": "offsetStartDateTime",
            "baseName": "offsetStartDateTime",
            "type": "Date"
        },
        {
            "name": "offsetEndDateTime",
            "baseName": "offsetEndDateTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PricingPackage.attributeTypeMap;
    }
}

export class PricingPackageDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'startDateTime'?: Date;
    'startDateTimeOffset'?: string;
    'endDateTime'?: Date;
    'endDateTimeOffset'?: string;
    'sortKey'?: number;
    'defaultPricing'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "startDateTime",
            "baseName": "startDateTime",
            "type": "Date"
        },
        {
            "name": "startDateTimeOffset",
            "baseName": "startDateTimeOffset",
            "type": "string"
        },
        {
            "name": "endDateTime",
            "baseName": "endDateTime",
            "type": "Date"
        },
        {
            "name": "endDateTimeOffset",
            "baseName": "endDateTimeOffset",
            "type": "string"
        },
        {
            "name": "sortKey",
            "baseName": "sortKey",
            "type": "number"
        },
        {
            "name": "defaultPricing",
            "baseName": "defaultPricing",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PricingPackageDto.attributeTypeMap;
    }
}

export class ProductRedemptionPricingCategoryDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'pricingPackage'?: PricingPackageDto;
    'pricingCategory'?: PricingCategoryDto;
    'product'?: string;
    'productCategory'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "pricingPackage",
            "baseName": "pricingPackage",
            "type": "PricingPackageDto"
        },
        {
            "name": "pricingCategory",
            "baseName": "pricingCategory",
            "type": "PricingCategoryDto"
        },
        {
            "name": "product",
            "baseName": "product",
            "type": "string"
        },
        {
            "name": "productCategory",
            "baseName": "productCategory",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProductRedemptionPricingCategoryDto.attributeTypeMap;
    }
}

export class Redemption {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'campaignTimeslot'?: CampaignTimeslot;
    'type'?: Redemption.TypeEnum;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "campaignTimeslot",
            "baseName": "campaignTimeslot",
            "type": "CampaignTimeslot"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "Redemption.TypeEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Redemption.attributeTypeMap;
    }
}

export namespace Redemption {
    export enum TypeEnum {
        EMAILREDEMPTION = <any> 'EMAIL_REDEMPTION',
        RESERVED2 = <any> 'RESERVED_2',
        ONLINEREDEMPTION = <any> 'ONLINE_REDEMPTION',
        PRODUCTREDEMPTION = <any> 'PRODUCT_REDEMPTION',
        RESERVED5 = <any> 'RESERVED_5',
        HAPZETICKETREDEMPTION = <any> 'HAPZ_ETICKET_REDEMPTION',
        DEFAULT = <any> 'DEFAULT'
    }
}
export class RedemptionDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: RedemptionDto.TypeEnum;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "RedemptionDto.TypeEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RedemptionDto.attributeTypeMap;
    }
}

export namespace RedemptionDto {
    export enum TypeEnum {
        EMAILREDEMPTION = <any> 'EMAIL_REDEMPTION',
        RESERVED2 = <any> 'RESERVED_2',
        ONLINEREDEMPTION = <any> 'ONLINE_REDEMPTION',
        PRODUCTREDEMPTION = <any> 'PRODUCT_REDEMPTION',
        RESERVED5 = <any> 'RESERVED_5',
        HAPZETICKETREDEMPTION = <any> 'HAPZ_ETICKET_REDEMPTION',
        DEFAULT = <any> 'DEFAULT'
    }
}
export class RegistrationField {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'campaign'?: Campaign;
    'type'?: RegistrationField.TypeEnum;
    'title'?: string;
    'description'?: string;
    'tag'?: string;
    'image'?: string;
    'required'?: boolean;
    'hidden'?: boolean;
    'multiRegistration'?: boolean;
    'applicableToAllPricingCategories'?: boolean;
    'sortKey'?: number;
    'applicablePricingCategories'?: Array<RegistrationFieldApplicablePricingCategory>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "Campaign"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "RegistrationField.TypeEnum"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "hidden",
            "baseName": "hidden",
            "type": "boolean"
        },
        {
            "name": "multiRegistration",
            "baseName": "multiRegistration",
            "type": "boolean"
        },
        {
            "name": "applicableToAllPricingCategories",
            "baseName": "applicableToAllPricingCategories",
            "type": "boolean"
        },
        {
            "name": "sortKey",
            "baseName": "sortKey",
            "type": "number"
        },
        {
            "name": "applicablePricingCategories",
            "baseName": "applicablePricingCategories",
            "type": "Array<RegistrationFieldApplicablePricingCategory>"
        }    ];

    static getAttributeTypeMap() {
        return RegistrationField.attributeTypeMap;
    }
}

export namespace RegistrationField {
    export enum TypeEnum {
        NAME = <any> 'NAME',
        GENDER = <any> 'GENDER',
        EMAILADDRESS = <any> 'EMAIL_ADDRESS',
        CONTACTNUMBER = <any> 'CONTACT_NUMBER',
        BIRTHDAY = <any> 'BIRTHDAY',
        MAILINGADDRESS = <any> 'MAILING_ADDRESS',
        SHORTTEXT = <any> 'SHORT_TEXT',
        LONGTEXT = <any> 'LONG_TEXT',
        NUMBER = <any> 'NUMBER',
        MULTIPLECHOICE = <any> 'MULTIPLE_CHOICE',
        DROPDOWN = <any> 'DROPDOWN',
        DATE = <any> 'DATE',
        COUNTRY = <any> 'COUNTRY',
        LEGAL = <any> 'LEGAL'
    }
}
export class RegistrationFieldApplicablePricingCategory {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'registrationField'?: RegistrationField;
    'pricingCategory'?: PricingCategory;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "registrationField",
            "baseName": "registrationField",
            "type": "RegistrationField"
        },
        {
            "name": "pricingCategory",
            "baseName": "pricingCategory",
            "type": "PricingCategory"
        }    ];

    static getAttributeTypeMap() {
        return RegistrationFieldApplicablePricingCategory.attributeTypeMap;
    }
}

export class RegistrationFieldDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'type'?: RegistrationFieldDto.TypeEnum;
    'title'?: string;
    'description'?: string;
    'tag'?: string;
    'image'?: Document;
    'required'?: boolean;
    'hidden'?: boolean;
    'multiRegistration'?: boolean;
    'applicableToAllPricingCategories'?: boolean;
    'sortKey'?: number;
    'applicablePricingCategoryIds'?: Array<string>;

    static discriminator: string | undefined = "type";

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "RegistrationFieldDto.TypeEnum"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Document"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "hidden",
            "baseName": "hidden",
            "type": "boolean"
        },
        {
            "name": "multiRegistration",
            "baseName": "multiRegistration",
            "type": "boolean"
        },
        {
            "name": "applicableToAllPricingCategories",
            "baseName": "applicableToAllPricingCategories",
            "type": "boolean"
        },
        {
            "name": "sortKey",
            "baseName": "sortKey",
            "type": "number"
        },
        {
            "name": "applicablePricingCategoryIds",
            "baseName": "applicablePricingCategoryIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return RegistrationFieldDto.attributeTypeMap;
    }
}

export namespace RegistrationFieldDto {
    export enum TypeEnum {
        NAME = <any> 'NAME',
        GENDER = <any> 'GENDER',
        EMAILADDRESS = <any> 'EMAIL_ADDRESS',
        CONTACTNUMBER = <any> 'CONTACT_NUMBER',
        BIRTHDAY = <any> 'BIRTHDAY',
        MAILINGADDRESS = <any> 'MAILING_ADDRESS',
        SHORTTEXT = <any> 'SHORT_TEXT',
        LONGTEXT = <any> 'LONG_TEXT',
        NUMBER = <any> 'NUMBER',
        MULTIPLECHOICE = <any> 'MULTIPLE_CHOICE',
        DROPDOWN = <any> 'DROPDOWN',
        DATE = <any> 'DATE',
        COUNTRY = <any> 'COUNTRY',
        LEGAL = <any> 'LEGAL'
    }
}
export class Search {
    'value': string;
    'regex': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "regex",
            "baseName": "regex",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Search.attributeTypeMap;
    }
}

export class Sort {
    'sorted'?: boolean;
    'unsorted'?: boolean;
    'empty'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sorted",
            "baseName": "sorted",
            "type": "boolean"
        },
        {
            "name": "unsorted",
            "baseName": "unsorted",
            "type": "boolean"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Sort.attributeTypeMap;
    }
}

export class Tag {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'name'?: string;
    'description'?: string;
    'bannerImage1800x562'?: string;
    'bannerImage800x533'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "bannerImage1800x562",
            "baseName": "bannerImage1800x562",
            "type": "string"
        },
        {
            "name": "bannerImage800x533",
            "baseName": "bannerImage800x533",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tag.attributeTypeMap;
    }
}

export class TagDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'name'?: string;
    'description'?: string;
    'bannerImage1800x562'?: Document;
    'bannerImage800x533'?: Document;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "bannerImage1800x562",
            "baseName": "bannerImage1800x562",
            "type": "Document"
        },
        {
            "name": "bannerImage800x533",
            "baseName": "bannerImage800x533",
            "type": "Document"
        }    ];

    static getAttributeTypeMap() {
        return TagDto.attributeTypeMap;
    }
}

export class TicketDistributionSpreadsheet {
    'id'?: string;
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastModifiedAt'?: Date;
    'lastModifiedBy'?: string;
    'deletedAt'?: Date;
    'deletedBy'?: string;
    'campaign'?: Campaign;
    'spreadsheetId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "lastModifiedBy",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deletedAt",
            "type": "Date"
        },
        {
            "name": "deletedBy",
            "baseName": "deletedBy",
            "type": "string"
        },
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "Campaign"
        },
        {
            "name": "spreadsheetId",
            "baseName": "spreadsheetId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TicketDistributionSpreadsheet.attributeTypeMap;
    }
}

export class TicketDistributionSpreadsheetDto {
    'id'?: string;
    'createdAt'?: Date;
    'lastModifiedAt'?: Date;
    'spreadsheetId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "lastModifiedAt",
            "baseName": "lastModifiedAt",
            "type": "Date"
        },
        {
            "name": "spreadsheetId",
            "baseName": "spreadsheetId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TicketDistributionSpreadsheetDto.attributeTypeMap;
    }
}

export class ValidateRegistration {
    'registrationValue'?: { [key: string]: any; };
    'pricingCategory'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "registrationValue",
            "baseName": "registrationValue",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "pricingCategory",
            "baseName": "pricingCategory",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ValidateRegistration.attributeTypeMap;
    }
}

export class BirthdayRegistrationFieldDto extends RegistrationFieldDto {
    'minimumAge'?: number;
    'minimumAgeEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "minimumAge",
            "baseName": "minimumAge",
            "type": "number"
        },
        {
            "name": "minimumAgeEnabled",
            "baseName": "minimumAgeEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BirthdayRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace BirthdayRegistrationFieldDto {
}
export class ContactNumberRegistrationFieldDto extends RegistrationFieldDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ContactNumberRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace ContactNumberRegistrationFieldDto {
}
export class CountryRegistrationFieldDto extends RegistrationFieldDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CountryRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace CountryRegistrationFieldDto {
}
export class DateRegistrationFieldDto extends RegistrationFieldDto {
    'minDate'?: Date;
    'maxDate'?: Date;
    'dateFormat'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "minDate",
            "baseName": "minDate",
            "type": "Date"
        },
        {
            "name": "maxDate",
            "baseName": "maxDate",
            "type": "Date"
        },
        {
            "name": "dateFormat",
            "baseName": "dateFormat",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DateRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace DateRegistrationFieldDto {
}
export class DropdownRegistrationFieldDto extends RegistrationFieldDto {
    'options'?: Array<string>;
    'includeOthersTextField'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<string>"
        },
        {
            "name": "includeOthersTextField",
            "baseName": "includeOthersTextField",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DropdownRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace DropdownRegistrationFieldDto {
}
export class EmailAddressRegistrationFieldDto extends RegistrationFieldDto {
    'allowDuplicateValue'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowDuplicateValue",
            "baseName": "allowDuplicateValue",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(EmailAddressRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace EmailAddressRegistrationFieldDto {
}
export class GenderRegistrationFieldDto extends RegistrationFieldDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GenderRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace GenderRegistrationFieldDto {
}
export class LegalRegistrationFieldDto extends RegistrationFieldDto {
    'termsAndConditionsDocument'?: Document;
    'checkedByDefault'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "termsAndConditionsDocument",
            "baseName": "termsAndConditionsDocument",
            "type": "Document"
        },
        {
            "name": "checkedByDefault",
            "baseName": "checkedByDefault",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LegalRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace LegalRegistrationFieldDto {
}
export class LongTextRegistrationFieldDto extends RegistrationFieldDto {
    'maxLength'?: number;
    'maxLengthEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "maxLength",
            "baseName": "maxLength",
            "type": "number"
        },
        {
            "name": "maxLengthEnabled",
            "baseName": "maxLengthEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LongTextRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace LongTextRegistrationFieldDto {
}
export class MailingAddressRegistrationFieldDto extends RegistrationFieldDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MailingAddressRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace MailingAddressRegistrationFieldDto {
}
export class MultipleChoiceRegistrationFieldDto extends RegistrationFieldDto {
    'options'?: Array<string>;
    'allowMultipleSelection'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<string>"
        },
        {
            "name": "allowMultipleSelection",
            "baseName": "allowMultipleSelection",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MultipleChoiceRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace MultipleChoiceRegistrationFieldDto {
}
export class NameRegistrationFieldDto extends RegistrationFieldDto {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(NameRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace NameRegistrationFieldDto {
}
export class NumberRegistrationFieldDto extends RegistrationFieldDto {
    'minimumValue'?: number;
    'minimumValueEnabled'?: boolean;
    'maximumValue'?: number;
    'maximumValueEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "minimumValue",
            "baseName": "minimumValue",
            "type": "number"
        },
        {
            "name": "minimumValueEnabled",
            "baseName": "minimumValueEnabled",
            "type": "boolean"
        },
        {
            "name": "maximumValue",
            "baseName": "maximumValue",
            "type": "number"
        },
        {
            "name": "maximumValueEnabled",
            "baseName": "maximumValueEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(NumberRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace NumberRegistrationFieldDto {
}
export class ShortTextRegistrationFieldDto extends RegistrationFieldDto {
    'minLength'?: number;
    'minLengthEnabled'?: boolean;
    'maxLength'?: number;
    'maxLengthEnabled'?: boolean;
    'allowLetters'?: boolean;
    'allowNumbers'?: boolean;
    'allowSymbols'?: boolean;
    'allowWhiteSpaces'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "minLength",
            "baseName": "minLength",
            "type": "number"
        },
        {
            "name": "minLengthEnabled",
            "baseName": "minLengthEnabled",
            "type": "boolean"
        },
        {
            "name": "maxLength",
            "baseName": "maxLength",
            "type": "number"
        },
        {
            "name": "maxLengthEnabled",
            "baseName": "maxLengthEnabled",
            "type": "boolean"
        },
        {
            "name": "allowLetters",
            "baseName": "allowLetters",
            "type": "boolean"
        },
        {
            "name": "allowNumbers",
            "baseName": "allowNumbers",
            "type": "boolean"
        },
        {
            "name": "allowSymbols",
            "baseName": "allowSymbols",
            "type": "boolean"
        },
        {
            "name": "allowWhiteSpaces",
            "baseName": "allowWhiteSpaces",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ShortTextRegistrationFieldDto.attributeTypeMap);
    }
}

export namespace ShortTextRegistrationFieldDto {
}

let enumsMap: {[index: string]: any} = {
        "CampaignFinancial.TransactionFeeChargeeEnum": CampaignFinancial.TransactionFeeChargeeEnum,
        "CampaignFinancialDto.TransactionFeeChargeeEnum": CampaignFinancialDto.TransactionFeeChargeeEnum,
        "Document.TypeEnum": Document.TypeEnum,
        "Pricing.SalesChannelEnum": Pricing.SalesChannelEnum,
        "PricingDto.SalesChannelEnum": PricingDto.SalesChannelEnum,
        "Redemption.TypeEnum": Redemption.TypeEnum,
        "RedemptionDto.TypeEnum": RedemptionDto.TypeEnum,
        "RegistrationField.TypeEnum": RegistrationField.TypeEnum,
        "RegistrationFieldDto.TypeEnum": RegistrationFieldDto.TypeEnum,
}

let typeMap: {[index: string]: any} = {
    "AddOn": AddOn,
    "AddOnDto": AddOnDto,
    "AddOnOption": AddOnOption,
    "AddOnOptionDto": AddOnOptionDto,
    "BaseDto": BaseDto,
    "Campaign": Campaign,
    "CampaignCategory": CampaignCategory,
    "CampaignCategoryCount": CampaignCategoryCount,
    "CampaignCategoryDto": CampaignCategoryDto,
    "CampaignDto": CampaignDto,
    "CampaignFinancial": CampaignFinancial,
    "CampaignFinancialDto": CampaignFinancialDto,
    "CampaignImage": CampaignImage,
    "CampaignInventoryLedgerSummary": CampaignInventoryLedgerSummary,
    "CampaignMerchant": CampaignMerchant,
    "CampaignMerchantDto": CampaignMerchantDto,
    "CampaignSubCategory": CampaignSubCategory,
    "CampaignSubCategoryDto": CampaignSubCategoryDto,
    "CampaignSummary": CampaignSummary,
    "CampaignTag": CampaignTag,
    "CampaignTimeslot": CampaignTimeslot,
    "CampaignTimeslotDto": CampaignTimeslotDto,
    "CardIssuer": CardIssuer,
    "CardIssuerDto": CardIssuerDto,
    "Column": Column,
    "DataTablesInput": DataTablesInput,
    "DataTablesOutput": DataTablesOutput,
    "DataTablesOutputCampaignCategoryDto": DataTablesOutputCampaignCategoryDto,
    "DataTablesOutputCampaignDto": DataTablesOutputCampaignDto,
    "DataTablesOutputLocationDto": DataTablesOutputLocationDto,
    "DataTablesOutputTagDto": DataTablesOutputTagDto,
    "Document": Document,
    "ETicketTemplate": ETicketTemplate,
    "ETicketTemplateDto": ETicketTemplateDto,
    "ErrorResponse": ErrorResponse,
    "Event": Event,
    "InventoryLedger": InventoryLedger,
    "InventoryLedgerDto": InventoryLedgerDto,
    "IssuerIdentificationNumber": IssuerIdentificationNumber,
    "IssuerIdentificationNumberDto": IssuerIdentificationNumberDto,
    "ItemsPageResponse": ItemsPageResponse,
    "ItemsPageResponseCampaignCategoryDto": ItemsPageResponseCampaignCategoryDto,
    "ItemsPageResponseCampaignDto": ItemsPageResponseCampaignDto,
    "ItemsPageResponseTagDto": ItemsPageResponseTagDto,
    "Location": Location,
    "LocationDto": LocationDto,
    "OnlineRedemptionCodeDto": OnlineRedemptionCodeDto,
    "Order": Order,
    "Page": Page,
    "PageEvent": PageEvent,
    "Pageable": Pageable,
    "Pricing": Pricing,
    "PricingAddOn": PricingAddOn,
    "PricingAddOnDto": PricingAddOnDto,
    "PricingAddOnOption": PricingAddOnOption,
    "PricingAddOnOptionDto": PricingAddOnOptionDto,
    "PricingAddOnOptionInventoryLedger": PricingAddOnOptionInventoryLedger,
    "PricingAddOnOptionInventoryLedgerDto": PricingAddOnOptionInventoryLedgerDto,
    "PricingCardIssuer": PricingCardIssuer,
    "PricingCardIssuerDto": PricingCardIssuerDto,
    "PricingCategory": PricingCategory,
    "PricingCategoryDto": PricingCategoryDto,
    "PricingDto": PricingDto,
    "PricingImage": PricingImage,
    "PricingInterval": PricingInterval,
    "PricingIntervalDto": PricingIntervalDto,
    "PricingPackage": PricingPackage,
    "PricingPackageDto": PricingPackageDto,
    "ProductRedemptionPricingCategoryDto": ProductRedemptionPricingCategoryDto,
    "Redemption": Redemption,
    "RedemptionDto": RedemptionDto,
    "RegistrationField": RegistrationField,
    "RegistrationFieldApplicablePricingCategory": RegistrationFieldApplicablePricingCategory,
    "RegistrationFieldDto": RegistrationFieldDto,
    "Search": Search,
    "Sort": Sort,
    "Tag": Tag,
    "TagDto": TagDto,
    "TicketDistributionSpreadsheet": TicketDistributionSpreadsheet,
    "TicketDistributionSpreadsheetDto": TicketDistributionSpreadsheetDto,
    "ValidateRegistration": ValidateRegistration,
    "BirthdayRegistrationFieldDto": BirthdayRegistrationFieldDto,
    "ContactNumberRegistrationFieldDto": ContactNumberRegistrationFieldDto,
    "CountryRegistrationFieldDto": CountryRegistrationFieldDto,
    "DateRegistrationFieldDto": DateRegistrationFieldDto,
    "DropdownRegistrationFieldDto": DropdownRegistrationFieldDto,
    "EmailAddressRegistrationFieldDto": EmailAddressRegistrationFieldDto,
    "GenderRegistrationFieldDto": GenderRegistrationFieldDto,
    "LegalRegistrationFieldDto": LegalRegistrationFieldDto,
    "LongTextRegistrationFieldDto": LongTextRegistrationFieldDto,
    "MailingAddressRegistrationFieldDto": MailingAddressRegistrationFieldDto,
    "MultipleChoiceRegistrationFieldDto": MultipleChoiceRegistrationFieldDto,
    "NameRegistrationFieldDto": NameRegistrationFieldDto,
    "NumberRegistrationFieldDto": NumberRegistrationFieldDto,
    "ShortTextRegistrationFieldDto": ShortTextRegistrationFieldDto,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AddonOptionsApiApiKeys {
    JWT,
}

export class AddonOptionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AddonOptionsApiApiKeys, value: string) {
        (this.authentications as any)[AddonOptionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new add on option
     * @param campaign Campaign ID
     * @param addon Add On ID
     * @param name Add On Name
     * @param image Image
     * @param description Add On Description
     * @param sortKey Sort Key
     * @param {*} [options] Override http request options.
     */
    public addAddOnOption (campaign: string, addon: string, name: string, image?: Buffer, description?: string, sortKey?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AddOnOptionDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/addons/{addon}/options'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addAddOnOption.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling addAddOnOption.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addAddOnOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (image !== undefined) {
            localVarFormParams['image'] = image;
        }
        localVarUseFormData = true;

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (sortKey !== undefined) {
            localVarFormParams['sortKey'] = ObjectSerializer.serialize(sortKey, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AddOnOptionDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AddOnOptionDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an event add on option
     * @param campaign Campaign ID
     * @param addon Add On ID
     * @param option Add On Option ID
     * @param {*} [options] Override http request options.
     */
    public deleteAddOnOption (campaign: string, addon: string, option: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/addons/{addon}/options/{option}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)))
            .replace('{' + 'option' + '}', encodeURIComponent(String(option)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteAddOnOption.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling deleteAddOnOption.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling deleteAddOnOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves an event add on option
     * @param campaign Campaign ID
     * @param addon Add On ID
     * @param option Add On Option ID
     * @param {*} [options] Override http request options.
     */
    public getAddOnOption (campaign: string, addon: string, option: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AddOnOptionDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/addons/{addon}/options/{option}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)))
            .replace('{' + 'option' + '}', encodeURIComponent(String(option)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getAddOnOption.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling getAddOnOption.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling getAddOnOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AddOnOptionDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AddOnOptionDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all add on options from the given campaign add on
     * @param campaign Campaign ID
     * @param addon Add On ID
     * @param {*} [options] Override http request options.
     */
    public getAddOnOptions (campaign: string, addon: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<AddOnOptionDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/addons/{addon}/options'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getAddOnOptions.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling getAddOnOptions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<AddOnOptionDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AddOnOptionDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates an add on option
     * @param campaign Campaign ID
     * @param addon Add On ID
     * @param option Add On Option ID
     * @param name Add On Name
     * @param image Image
     * @param description Add On Description
     * @param sortKey Sort Key
     * @param {*} [options] Override http request options.
     */
    public updateAddOnOption (campaign: string, addon: string, option: string, name: string, image?: Buffer, description?: string, sortKey?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/addons/{addon}/options/{option}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)))
            .replace('{' + 'option' + '}', encodeURIComponent(String(option)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateAddOnOption.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling updateAddOnOption.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling updateAddOnOption.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateAddOnOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (image !== undefined) {
            localVarFormParams['image'] = image;
        }
        localVarUseFormData = true;

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (sortKey !== undefined) {
            localVarFormParams['sortKey'] = ObjectSerializer.serialize(sortKey, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AddonsApiApiKeys {
    JWT,
}

export class AddonsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AddonsApiApiKeys, value: string) {
        (this.authentications as any)[AddonsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new add on
     * @param campaign Campaign ID
     * @param name Add On Name
     * @param allowMultipleSelection Allow Multiple Selection
     * @param allowMultipleQuantity Allow Multiple Quantity
     * @param sortKey Sort Key
     * @param {*} [options] Override http request options.
     */
    public addAddOn (campaign: string, name: string, allowMultipleSelection: boolean, allowMultipleQuantity: boolean, sortKey?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AddOnDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/addons'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addAddOn.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addAddOn.');
        }

        // verify required parameter 'allowMultipleSelection' is not null or undefined
        if (allowMultipleSelection === null || allowMultipleSelection === undefined) {
            throw new Error('Required parameter allowMultipleSelection was null or undefined when calling addAddOn.');
        }

        // verify required parameter 'allowMultipleQuantity' is not null or undefined
        if (allowMultipleQuantity === null || allowMultipleQuantity === undefined) {
            throw new Error('Required parameter allowMultipleQuantity was null or undefined when calling addAddOn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (allowMultipleSelection !== undefined) {
            localVarFormParams['allowMultipleSelection'] = ObjectSerializer.serialize(allowMultipleSelection, "boolean");
        }

        if (allowMultipleQuantity !== undefined) {
            localVarFormParams['allowMultipleQuantity'] = ObjectSerializer.serialize(allowMultipleQuantity, "boolean");
        }

        if (sortKey !== undefined) {
            localVarFormParams['sortKey'] = ObjectSerializer.serialize(sortKey, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AddOnDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AddOnDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an event add on
     * @param campaign Campaign ID
     * @param addon Add On ID
     * @param {*} [options] Override http request options.
     */
    public deleteAddOn (campaign: string, addon: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/addons/{addon}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteAddOn.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling deleteAddOn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves an event add on
     * @param campaign Campaign ID
     * @param addon Add On ID
     * @param {*} [options] Override http request options.
     */
    public getAddOn (campaign: string, addon: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AddOnDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/addons/{addon}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getAddOn.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling getAddOn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AddOnDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AddOnDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all add ons from the given campaign
     * @param campaign Campaign ID
     * @param {*} [options] Override http request options.
     */
    public getAddOns (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<AddOnDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/addons'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getAddOns.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<AddOnDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AddOnDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates an add on
     * @param campaign Campaign ID
     * @param addon Add On ID
     * @param name Add On Name
     * @param allowMultipleSelection Allow Multiple Selection
     * @param allowMultipleQuantity Allow Multiple Quantity
     * @param sortKey Sort Key
     * @param {*} [options] Override http request options.
     */
    public updateAddOn (campaign: string, addon: string, name: string, allowMultipleSelection: boolean, allowMultipleQuantity: boolean, sortKey?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/addons/{addon}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateAddOn.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling updateAddOn.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateAddOn.');
        }

        // verify required parameter 'allowMultipleSelection' is not null or undefined
        if (allowMultipleSelection === null || allowMultipleSelection === undefined) {
            throw new Error('Required parameter allowMultipleSelection was null or undefined when calling updateAddOn.');
        }

        // verify required parameter 'allowMultipleQuantity' is not null or undefined
        if (allowMultipleQuantity === null || allowMultipleQuantity === undefined) {
            throw new Error('Required parameter allowMultipleQuantity was null or undefined when calling updateAddOn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (allowMultipleSelection !== undefined) {
            localVarFormParams['allowMultipleSelection'] = ObjectSerializer.serialize(allowMultipleSelection, "boolean");
        }

        if (allowMultipleQuantity !== undefined) {
            localVarFormParams['allowMultipleQuantity'] = ObjectSerializer.serialize(allowMultipleQuantity, "boolean");
        }

        if (sortKey !== undefined) {
            localVarFormParams['sortKey'] = ObjectSerializer.serialize(sortKey, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignApiApiKeys {
    JWT,
}

export class CampaignApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignApiApiKeys, value: string) {
        (this.authentications as any)[CampaignApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new event
     * @param name Event Name
     * @param description Event Description
     * @param category Event Category
     * @param subcategory Event Subcategory
     * @param currency 
     * @param bannerImage1800x562 Banner Image (1800x562)
     * @param bannerImage800x533 Banner Image (800x533)
     * @param images Promotion Images
     * @param images2 Promotion Images Details
     * @param itinerary Link to Event Itinerary
     * @param additionalInformation Additional Information
     * @param termsAndConditions Terms and Conditions
     * @param ambassadorContent Hapz Experience Ambassador Content
     * @param merchant Merchant (Optional if request is from a Merchant Account)
     * @param eventInsurance Enable Event Insurance
     * @param creditsPercentage Percentage of transaction to be returned as credits to the user
     * @param publicListing Is Public Listing
     * @param tags Tags
     * @param {*} [options] Override http request options.
     */
    public addCampaign (name: string, description: string, category: string, subcategory: string, currency: string, bannerImage1800x562?: Buffer, bannerImage800x533?: Buffer, images?: Buffer, itinerary?: string, additionalInformation?: string, termsAndConditions?: string, ambassadorContent?: string, merchant?: string, eventInsurance?: boolean, creditsPercentage?: number, publicListing?: boolean, tags?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignDto;  }> {
        const localVarPath = this.basePath + '/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addCampaign.');
        }

        // verify required parameter 'description' is not null or undefined
        if (description === null || description === undefined) {
            throw new Error('Required parameter description was null or undefined when calling addCampaign.');
        }

        // verify required parameter 'category' is not null or undefined
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling addCampaign.');
        }

        // verify required parameter 'subcategory' is not null or undefined
        if (subcategory === null || subcategory === undefined) {
            throw new Error('Required parameter subcategory was null or undefined when calling addCampaign.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling addCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (category !== undefined) {
            localVarFormParams['category'] = ObjectSerializer.serialize(category, "string");
        }

        if (subcategory !== undefined) {
            localVarFormParams['subcategory'] = ObjectSerializer.serialize(subcategory, "string");
        }

        if (bannerImage1800x562 !== undefined) {
            localVarFormParams['bannerImage1800x562'] = bannerImage1800x562;
        }
        localVarUseFormData = true;

        if (bannerImage800x533 !== undefined) {
            localVarFormParams['bannerImage800x533'] = bannerImage800x533;
        }
        localVarUseFormData = true;

        if (images !== undefined) {
            localVarFormParams['images'] = images;
        }
        localVarUseFormData = true;

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (itinerary !== undefined) {
            localVarFormParams['itinerary'] = ObjectSerializer.serialize(itinerary, "string");
        }

        if (additionalInformation !== undefined) {
            localVarFormParams['additionalInformation'] = ObjectSerializer.serialize(additionalInformation, "string");
        }

        if (termsAndConditions !== undefined) {
            localVarFormParams['termsAndConditions'] = ObjectSerializer.serialize(termsAndConditions, "string");
        }

        if (ambassadorContent !== undefined) {
            localVarFormParams['ambassadorContent'] = ObjectSerializer.serialize(ambassadorContent, "string");
        }

        if (merchant !== undefined) {
            localVarFormParams['merchant'] = ObjectSerializer.serialize(merchant, "string");
        }

        if (eventInsurance !== undefined) {
            localVarFormParams['eventInsurance'] = ObjectSerializer.serialize(eventInsurance, "boolean");
        }

        if (creditsPercentage !== undefined) {
            localVarFormParams['creditsPercentage'] = ObjectSerializer.serialize(creditsPercentage, "number");
        }

        if (publicListing !== undefined) {
            localVarFormParams['publicListing'] = ObjectSerializer.serialize(publicListing, "boolean");
        }

        if (tags !== undefined) {
            localVarFormParams['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a campaign
     * @param campaign Campaign ID
     * @param {*} [options] Override http request options.
     */
    public deleteCampaign (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Duplicate the details of an event
     * @param campaignId 
     * @param {*} [options] Override http request options.
     */
    public duplicateCampaign (campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignDto;  }> {
        const localVarPath = this.basePath + '/{campaignId}/duplicate'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling duplicateCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the details of a campaign
     * @param campaign Campaign ID
     * @param utmCampaign UTM Campaign
     * @param utmSource UTM Source
     * @param utmMedium UTM Medium
     * @param utmContent UTM Content
     * @param utmTerm UTM Term
     * @param referrerUrl Referrer URL
     * @param {*} [options] Override http request options.
     */
    public getCampaign (campaign: string, utmCampaign?: string, utmSource?: string, utmMedium?: string, utmContent?: string, utmTerm?: string, referrerUrl?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignDto;  }> {
        const localVarPath = this.basePath + '/{campaign}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getCampaign.');
        }

        if (utmCampaign !== undefined) {
            localVarQueryParameters['utm_campaign'] = ObjectSerializer.serialize(utmCampaign, "string");
        }

        if (utmSource !== undefined) {
            localVarQueryParameters['utm_source'] = ObjectSerializer.serialize(utmSource, "string");
        }

        if (utmMedium !== undefined) {
            localVarQueryParameters['utm_medium'] = ObjectSerializer.serialize(utmMedium, "string");
        }

        if (utmContent !== undefined) {
            localVarQueryParameters['utm_content'] = ObjectSerializer.serialize(utmContent, "string");
        }

        if (utmTerm !== undefined) {
            localVarQueryParameters['utm_term'] = ObjectSerializer.serialize(utmTerm, "string");
        }

        if (referrerUrl !== undefined) {
            localVarQueryParameters['referrerUrl'] = ObjectSerializer.serialize(referrerUrl, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaign Campaign ID
     * @param {*} [options] Override http request options.
     */
    public getCampaignRedemptionDatabaseSynchronisedAt (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Date;  }> {
        const localVarPath = this.basePath + '/{campaign}/redemptionDatabaseSynchronisedAt'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getCampaignRedemptionDatabaseSynchronisedAt.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Date;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Date");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve all events
     * @param start Start Row
     * @param rows Number of Rows
     * @param searchTerm Search Term
     * @param category Category ID
     * @param subcategory Subcategory ID
     * @param timeslotStartDate Timeslot Start Date (yyyy-MM-dd)
     * @param timeslotEndDate Timeslot End Date (yyyy-MM-dd)
     * @param tag Tag
     * @param merchant Merchant ID (Optional, for Account Managers and Administrators only, used to retrieve all events from a given merchant)
     * @param orderByPrice Order By Price (1 &#x3D; Ascending, 2 &#x3D; Descending)
     * @param orderBySavings Order By Savings (1 &#x3D; Ascending, 2 &#x3D; Descending)
     * @param {*} [options] Override http request options.
     */
    public getCampaigns (start: number, rows: number, searchTerm?: string, category?: string, subcategory?: string, timeslotStartDate?: Date, timeslotEndDate?: Date, tag?: string, merchant?: string, orderByPrice?: 0 | 1 | 2, orderBySavings?: 0 | 1 | 2, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemsPageResponseCampaignDto;  }> {
        const localVarPath = this.basePath + '/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getCampaigns.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getCampaigns.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(category, "string");
        }

        if (subcategory !== undefined) {
            localVarQueryParameters['subcategory'] = ObjectSerializer.serialize(subcategory, "string");
        }

        if (timeslotStartDate !== undefined) {
            localVarQueryParameters['timeslotStartDate'] = ObjectSerializer.serialize(timeslotStartDate, "Date");
        }

        if (timeslotEndDate !== undefined) {
            localVarQueryParameters['timeslotEndDate'] = ObjectSerializer.serialize(timeslotEndDate, "Date");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        if (merchant !== undefined) {
            localVarQueryParameters['merchant'] = ObjectSerializer.serialize(merchant, "string");
        }

        if (orderByPrice !== undefined) {
            localVarQueryParameters['orderByPrice'] = ObjectSerializer.serialize(orderByPrice, "0 | 1 | 2");
        }

        if (orderBySavings !== undefined) {
            localVarQueryParameters['orderBySavings'] = ObjectSerializer.serialize(orderBySavings, "0 | 1 | 2");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPageResponseCampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsPageResponseCampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the details of a campaign
     * @param campaign Campaign ID
     * @param name Event Name
     * @param description Event Description
     * @param category Event Category
     * @param subcategory Event Subcategory
     * @param currency 
     * @param aliasId Campaign Alias ID
     * @param bannerImage1800x562 Banner Image (1800x562)
     * @param bannerImage800x533 Banner Image (800x533)
     * @param images Promotion Images
     * @param images2 Promotion Images Details
     * @param itinerary Link to Event Itinerary
     * @param additionalInformation Additional Information
     * @param termsAndConditions Terms and Conditions
     * @param ambassadorContent Hapz Experience Ambassador Content
     * @param merchant Merchant (Optional if request is from a Merchant Account)
     * @param eventInsurance Enable Event Insurance
     * @param creditsPercentage Percentage of transaction to be returned as credits to the user
     * @param publicListing Is Public Listing
     * @param tags Tags
     * @param deletedImages IDs of deleted images
     * @param {*} [options] Override http request options.
     */
    public updateCampaign (campaign: string, name: string, description: string, category: string, subcategory: string, currency: string, aliasId?: string, bannerImage1800x562?: Buffer, bannerImage800x533?: Buffer, images?: Buffer, itinerary?: string, additionalInformation?: string, termsAndConditions?: string, ambassadorContent?: string, merchant?: string, eventInsurance?: boolean, creditsPercentage?: number, publicListing?: boolean, tags?: string, deletedImages?: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateCampaign.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateCampaign.');
        }

        // verify required parameter 'description' is not null or undefined
        if (description === null || description === undefined) {
            throw new Error('Required parameter description was null or undefined when calling updateCampaign.');
        }

        // verify required parameter 'category' is not null or undefined
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling updateCampaign.');
        }

        // verify required parameter 'subcategory' is not null or undefined
        if (subcategory === null || subcategory === undefined) {
            throw new Error('Required parameter subcategory was null or undefined when calling updateCampaign.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling updateCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (aliasId !== undefined) {
            localVarFormParams['aliasId'] = ObjectSerializer.serialize(aliasId, "string");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (category !== undefined) {
            localVarFormParams['category'] = ObjectSerializer.serialize(category, "string");
        }

        if (subcategory !== undefined) {
            localVarFormParams['subcategory'] = ObjectSerializer.serialize(subcategory, "string");
        }

        if (bannerImage1800x562 !== undefined) {
            localVarFormParams['bannerImage1800x562'] = bannerImage1800x562;
        }
        localVarUseFormData = true;

        if (bannerImage800x533 !== undefined) {
            localVarFormParams['bannerImage800x533'] = bannerImage800x533;
        }
        localVarUseFormData = true;

        if (images !== undefined) {
            localVarFormParams['images'] = images;
        }
        localVarUseFormData = true;

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (itinerary !== undefined) {
            localVarFormParams['itinerary'] = ObjectSerializer.serialize(itinerary, "string");
        }

        if (additionalInformation !== undefined) {
            localVarFormParams['additionalInformation'] = ObjectSerializer.serialize(additionalInformation, "string");
        }

        if (termsAndConditions !== undefined) {
            localVarFormParams['termsAndConditions'] = ObjectSerializer.serialize(termsAndConditions, "string");
        }

        if (ambassadorContent !== undefined) {
            localVarFormParams['ambassadorContent'] = ObjectSerializer.serialize(ambassadorContent, "string");
        }

        if (merchant !== undefined) {
            localVarFormParams['merchant'] = ObjectSerializer.serialize(merchant, "string");
        }

        if (eventInsurance !== undefined) {
            localVarFormParams['eventInsurance'] = ObjectSerializer.serialize(eventInsurance, "boolean");
        }

        if (creditsPercentage !== undefined) {
            localVarFormParams['creditsPercentage'] = ObjectSerializer.serialize(creditsPercentage, "number");
        }

        if (publicListing !== undefined) {
            localVarFormParams['publicListing'] = ObjectSerializer.serialize(publicListing, "boolean");
        }

        if (tags !== undefined) {
            localVarFormParams['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        if (deletedImages !== undefined) {
            localVarFormParams['deletedImages'] = ObjectSerializer.serialize(deletedImages, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaign Campaign ID
     * @param synchronisedAt Redemption Database Last Synchronised Current Date Time in milliseconds
     * @param {*} [options] Override http request options.
     */
    public updateCampaignRedemptionDatabase (campaign: string, synchronisedAt?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/redemptionDatabaseSynchronisedAt'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateCampaignRedemptionDatabase.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (synchronisedAt !== undefined) {
            localVarFormParams['synchronisedAt'] = ObjectSerializer.serialize(synchronisedAt, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Enable or disable the redemption database for this campaign
     * @param campaign Campaign ID
     * @param status Redemption Database Status (0 &#x3D; Disabled, 1 &#x3D; Enabled)
     * @param {*} [options] Override http request options.
     */
    public updateRedemptionDatabaseStatus (campaign: string, status?: 0 | 1, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/redemption/database/status'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateRedemptionDatabaseStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (status !== undefined) {
            localVarFormParams['status'] = ObjectSerializer.serialize(status, "0 | 1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignFinancialApiApiKeys {
    JWT,
}

export class CampaignFinancialApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignFinancialApiApiKeys, value: string) {
        (this.authentications as any)[CampaignFinancialApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param campaign Campaign ID
     * @param {*} [options] Override http request options.
     */
    public getCampaignFinancial (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignFinancialDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/financials'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getCampaignFinancial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignFinancialDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignFinancialDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaign Campaign ID
     * @param transactionFeeChargee 1 &#x3D; Merchant, 2 &#x3D; User
     * @param userTransactionFeePercentage 
     * @param userTransactionFeeFixed 
     * @param mastercardVisaTransactionFeePercentage 
     * @param mastercardVisaTransactionFeeFixed 
     * @param amexTransactionFeePercentage 
     * @param amexTransactionFeeFixed 
     * @param marketingCommission 
     * @param distributionCommission 
     * @param {*} [options] Override http request options.
     */
    public updateCampaignFinancial (campaign: string, transactionFeeChargee: 1 | 2, userTransactionFeePercentage: number, userTransactionFeeFixed: number, mastercardVisaTransactionFeePercentage: number, mastercardVisaTransactionFeeFixed: number, amexTransactionFeePercentage: number, amexTransactionFeeFixed: number, marketingCommission: number, distributionCommission: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/financials'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateCampaignFinancial.');
        }

        // verify required parameter 'transactionFeeChargee' is not null or undefined
        if (transactionFeeChargee === null || transactionFeeChargee === undefined) {
            throw new Error('Required parameter transactionFeeChargee was null or undefined when calling updateCampaignFinancial.');
        }

        // verify required parameter 'userTransactionFeePercentage' is not null or undefined
        if (userTransactionFeePercentage === null || userTransactionFeePercentage === undefined) {
            throw new Error('Required parameter userTransactionFeePercentage was null or undefined when calling updateCampaignFinancial.');
        }

        // verify required parameter 'userTransactionFeeFixed' is not null or undefined
        if (userTransactionFeeFixed === null || userTransactionFeeFixed === undefined) {
            throw new Error('Required parameter userTransactionFeeFixed was null or undefined when calling updateCampaignFinancial.');
        }

        // verify required parameter 'mastercardVisaTransactionFeePercentage' is not null or undefined
        if (mastercardVisaTransactionFeePercentage === null || mastercardVisaTransactionFeePercentage === undefined) {
            throw new Error('Required parameter mastercardVisaTransactionFeePercentage was null or undefined when calling updateCampaignFinancial.');
        }

        // verify required parameter 'mastercardVisaTransactionFeeFixed' is not null or undefined
        if (mastercardVisaTransactionFeeFixed === null || mastercardVisaTransactionFeeFixed === undefined) {
            throw new Error('Required parameter mastercardVisaTransactionFeeFixed was null or undefined when calling updateCampaignFinancial.');
        }

        // verify required parameter 'amexTransactionFeePercentage' is not null or undefined
        if (amexTransactionFeePercentage === null || amexTransactionFeePercentage === undefined) {
            throw new Error('Required parameter amexTransactionFeePercentage was null or undefined when calling updateCampaignFinancial.');
        }

        // verify required parameter 'amexTransactionFeeFixed' is not null or undefined
        if (amexTransactionFeeFixed === null || amexTransactionFeeFixed === undefined) {
            throw new Error('Required parameter amexTransactionFeeFixed was null or undefined when calling updateCampaignFinancial.');
        }

        // verify required parameter 'marketingCommission' is not null or undefined
        if (marketingCommission === null || marketingCommission === undefined) {
            throw new Error('Required parameter marketingCommission was null or undefined when calling updateCampaignFinancial.');
        }

        // verify required parameter 'distributionCommission' is not null or undefined
        if (distributionCommission === null || distributionCommission === undefined) {
            throw new Error('Required parameter distributionCommission was null or undefined when calling updateCampaignFinancial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (transactionFeeChargee !== undefined) {
            localVarFormParams['transactionFeeChargee'] = ObjectSerializer.serialize(transactionFeeChargee, "1 | 2");
        }

        if (userTransactionFeePercentage !== undefined) {
            localVarFormParams['userTransactionFeePercentage'] = ObjectSerializer.serialize(userTransactionFeePercentage, "number");
        }

        if (userTransactionFeeFixed !== undefined) {
            localVarFormParams['userTransactionFeeFixed'] = ObjectSerializer.serialize(userTransactionFeeFixed, "number");
        }

        if (mastercardVisaTransactionFeePercentage !== undefined) {
            localVarFormParams['mastercardVisaTransactionFeePercentage'] = ObjectSerializer.serialize(mastercardVisaTransactionFeePercentage, "number");
        }

        if (mastercardVisaTransactionFeeFixed !== undefined) {
            localVarFormParams['mastercardVisaTransactionFeeFixed'] = ObjectSerializer.serialize(mastercardVisaTransactionFeeFixed, "number");
        }

        if (amexTransactionFeePercentage !== undefined) {
            localVarFormParams['amexTransactionFeePercentage'] = ObjectSerializer.serialize(amexTransactionFeePercentage, "number");
        }

        if (amexTransactionFeeFixed !== undefined) {
            localVarFormParams['amexTransactionFeeFixed'] = ObjectSerializer.serialize(amexTransactionFeeFixed, "number");
        }

        if (marketingCommission !== undefined) {
            localVarFormParams['marketingCommission'] = ObjectSerializer.serialize(marketingCommission, "number");
        }

        if (distributionCommission !== undefined) {
            localVarFormParams['distributionCommission'] = ObjectSerializer.serialize(distributionCommission, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignSummaryApiApiKeys {
    JWT,
}

export class CampaignSummaryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignSummaryApiApiKeys, value: string) {
        (this.authentications as any)[CampaignSummaryApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve the summary of the given campaigns
     * @param campaignIds Campaign IDs (comma-seperated values)
     * @param {*} [options] Override http request options.
     */
    public getCampaignSummaries (campaignIds: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<CampaignSummary>;  }> {
        const localVarPath = this.basePath + '/summary';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignIds' is not null or undefined
        if (campaignIds === null || campaignIds === undefined) {
            throw new Error('Required parameter campaignIds was null or undefined when calling getCampaignSummaries.');
        }

        if (campaignIds !== undefined) {
            localVarQueryParameters['campaignIds'] = ObjectSerializer.serialize(campaignIds, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CampaignSummary>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CampaignSummary>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignTimeslotApiApiKeys {
    JWT,
}

export class CampaignTimeslotApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignTimeslotApiApiKeys, value: string) {
        (this.authentications as any)[CampaignTimeslotApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new event timeslot
     * @param campaign Campaign ID
     * @param startDateTime Timeslot Start Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param endDateTime Timeslot End Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param expiresAt Purchase Period expiry (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param location Location ID
     * @param packageId Pricing Package ID
     * @param expiresAfter Number of milliseconds until redemption expires (0 &#x3D; no expiry)
     * @param {*} [options] Override http request options.
     */
    public addTimeslot (campaign: string, startDateTime: Date, endDateTime: Date, expiresAt: Date, location: string, packageId?: string, expiresAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignTimeslotDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addTimeslot.');
        }

        // verify required parameter 'startDateTime' is not null or undefined
        if (startDateTime === null || startDateTime === undefined) {
            throw new Error('Required parameter startDateTime was null or undefined when calling addTimeslot.');
        }

        // verify required parameter 'endDateTime' is not null or undefined
        if (endDateTime === null || endDateTime === undefined) {
            throw new Error('Required parameter endDateTime was null or undefined when calling addTimeslot.');
        }

        // verify required parameter 'expiresAt' is not null or undefined
        if (expiresAt === null || expiresAt === undefined) {
            throw new Error('Required parameter expiresAt was null or undefined when calling addTimeslot.');
        }

        // verify required parameter 'location' is not null or undefined
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling addTimeslot.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (packageId !== undefined) {
            localVarFormParams['packageId'] = ObjectSerializer.serialize(packageId, "string");
        }

        if (startDateTime !== undefined) {
            localVarFormParams['startDateTime'] = ObjectSerializer.serialize(startDateTime, "Date");
        }

        if (endDateTime !== undefined) {
            localVarFormParams['endDateTime'] = ObjectSerializer.serialize(endDateTime, "Date");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expiresAt'] = ObjectSerializer.serialize(expiresAt, "Date");
        }

        if (location !== undefined) {
            localVarFormParams['location'] = ObjectSerializer.serialize(location, "string");
        }

        if (expiresAfter !== undefined) {
            localVarFormParams['expiresAfter'] = ObjectSerializer.serialize(expiresAfter, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignTimeslotDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignTimeslotDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an event timeslot
     * @param campaign 
     * @param timeslot 
     * @param {*} [options] Override http request options.
     */
    public deleteTimeslot (campaign: string, timeslot: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteTimeslot.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling deleteTimeslot.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Duplicate the details of an event timeslot
     * @param campaignId 
     * @param timeslotId 
     * @param targetDate Target Date (yyyy-MM-dd)
     * @param {*} [options] Override http request options.
     */
    public duplicateTimeslot (campaignId: string, timeslotId: string, targetDate?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignTimeslotDto;  }> {
        const localVarPath = this.basePath + '/{campaignId}/timeslots/{timeslotId}/duplicate'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)))
            .replace('{' + 'timeslotId' + '}', encodeURIComponent(String(timeslotId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling duplicateTimeslot.');
        }

        // verify required parameter 'timeslotId' is not null or undefined
        if (timeslotId === null || timeslotId === undefined) {
            throw new Error('Required parameter timeslotId was null or undefined when calling duplicateTimeslot.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (targetDate !== undefined) {
            localVarFormParams['targetDate'] = ObjectSerializer.serialize(targetDate, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignTimeslotDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignTimeslotDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of the first timeslot in a campaign
     * @param campaign 
     * @param {*} [options] Override http request options.
     */
    public getFirstTimeslot (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignTimeslotDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/first'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getFirstTimeslot.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignTimeslotDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignTimeslotDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of the last timeslot in a campaign
     * @param campaign 
     * @param {*} [options] Override http request options.
     */
    public getLastTimeslot (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignTimeslotDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/last'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getLastTimeslot.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignTimeslotDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignTimeslotDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of an event timeslot
     * @param campaign 
     * @param timeslot 
     * @param {*} [options] Override http request options.
     */
    public getTimeslot (campaign: string, timeslot: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignTimeslotDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getTimeslot.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getTimeslot.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignTimeslotDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignTimeslotDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve all timeslots for a given event
     * @param campaign Campaign ID
     * @param startDate Start Date (yyyy-MM-dd)
     * @param endDate End Date (yyyy-MM-dd)
     * @param {*} [options] Override http request options.
     */
    public getTimeslots (campaign: string, startDate?: Date, endDate?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<CampaignTimeslotDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getTimeslots.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CampaignTimeslotDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CampaignTimeslotDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the details of an event timeslot
     * @param campaign 
     * @param timeslot 
     * @param startDateTime Timeslot Start Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param endDateTime Timeslot End Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param expiresAt Purchase Period expiry (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param location Location ID
     * @param packageId Pricing Package ID
     * @param {*} [options] Override http request options.
     */
    public updateTimeslot (campaign: string, timeslot: string, startDateTime: Date, endDateTime: Date, expiresAt: Date, location: string, packageId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateTimeslot.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling updateTimeslot.');
        }

        // verify required parameter 'startDateTime' is not null or undefined
        if (startDateTime === null || startDateTime === undefined) {
            throw new Error('Required parameter startDateTime was null or undefined when calling updateTimeslot.');
        }

        // verify required parameter 'endDateTime' is not null or undefined
        if (endDateTime === null || endDateTime === undefined) {
            throw new Error('Required parameter endDateTime was null or undefined when calling updateTimeslot.');
        }

        // verify required parameter 'expiresAt' is not null or undefined
        if (expiresAt === null || expiresAt === undefined) {
            throw new Error('Required parameter expiresAt was null or undefined when calling updateTimeslot.');
        }

        // verify required parameter 'location' is not null or undefined
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling updateTimeslot.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (packageId !== undefined) {
            localVarFormParams['packageId'] = ObjectSerializer.serialize(packageId, "string");
        }

        if (startDateTime !== undefined) {
            localVarFormParams['startDateTime'] = ObjectSerializer.serialize(startDateTime, "Date");
        }

        if (endDateTime !== undefined) {
            localVarFormParams['endDateTime'] = ObjectSerializer.serialize(endDateTime, "Date");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expiresAt'] = ObjectSerializer.serialize(expiresAt, "Date");
        }

        if (location !== undefined) {
            localVarFormParams['location'] = ObjectSerializer.serialize(location, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsApiApiKeys {
    JWT,
}

export class CampaignsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignsApiApiKeys, value: string) {
        (this.authentications as any)[CampaignsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new product category for this redemption
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param redemption Redemption ID
     * @param pricingPackage Pricing Package ID
     * @param pricingCategory Pricing Category ID
     * @param product Product ID
     * @param productCategory Product Category ID
     * @param {*} [options] Override http request options.
     */
    public addProductRedemptionPricingCategory (campaign: string, timeslot: string, redemption: string, pricingPackage?: string, pricingCategory?: string, product?: string, productCategory?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/redemptions/{redemption}/pricingcategories'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'redemption' + '}', encodeURIComponent(String(redemption)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addProductRedemptionPricingCategory.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling addProductRedemptionPricingCategory.');
        }

        // verify required parameter 'redemption' is not null or undefined
        if (redemption === null || redemption === undefined) {
            throw new Error('Required parameter redemption was null or undefined when calling addProductRedemptionPricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (pricingPackage !== undefined) {
            localVarFormParams['pricingPackage'] = ObjectSerializer.serialize(pricingPackage, "string");
        }

        if (pricingCategory !== undefined) {
            localVarFormParams['pricingCategory'] = ObjectSerializer.serialize(pricingCategory, "string");
        }

        if (product !== undefined) {
            localVarFormParams['product'] = ObjectSerializer.serialize(product, "string");
        }

        if (productCategory !== undefined) {
            localVarFormParams['productCategory'] = ObjectSerializer.serialize(productCategory, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new redemption for this timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param redemptionType Redemption Type (1 &#x3D; Point of Sale Collection, 2 &#x3D; Phone Collection, 3 &#x3D; Online Redemption, 4 &#x3D; E-Ticket Redemption, 5 &#x3D; Website Collection, 6 &#x3D; Hapz E-Ticket Redemption)
     * @param description Redemption Details
     * @param website Redemption Website (Only for Redemption Type &#x3D; 3)
     * @param ticketDispatchDelayInSeconds Ticket Dispatch Delay in Seconds (Only for Redemption Type &#x3D; 4)
     * @param issueMultipleTickets Issue Multiple Tickets (Only for Redemption Type &#x3D; 6)
     * @param template ETicket Template Id
     * @param {*} [options] Override http request options.
     */
    public addTimeslotRedemption (campaign: string, timeslot: string, redemptionType: 1 | 2 | 3 | 4 | 5 | 6, description?: string, website?: string, ticketDispatchDelayInSeconds?: number, issueMultipleTickets?: boolean, template?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/redemptions'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addTimeslotRedemption.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling addTimeslotRedemption.');
        }

        // verify required parameter 'redemptionType' is not null or undefined
        if (redemptionType === null || redemptionType === undefined) {
            throw new Error('Required parameter redemptionType was null or undefined when calling addTimeslotRedemption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (redemptionType !== undefined) {
            localVarFormParams['redemptionType'] = ObjectSerializer.serialize(redemptionType, "1 | 2 | 3 | 4 | 5 | 6");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (website !== undefined) {
            localVarFormParams['website'] = ObjectSerializer.serialize(website, "string");
        }

        if (ticketDispatchDelayInSeconds !== undefined) {
            localVarFormParams['ticketDispatchDelayInSeconds'] = ObjectSerializer.serialize(ticketDispatchDelayInSeconds, "number");
        }

        if (issueMultipleTickets !== undefined) {
            localVarFormParams['issueMultipleTickets'] = ObjectSerializer.serialize(issueMultipleTickets, "boolean");
        }

        if (template !== undefined) {
            localVarFormParams['template'] = ObjectSerializer.serialize(template, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Allocate Online Redemption Code
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param redemption Redemption ID
     * @param pricingCategoryId Pricing Category ID
     * @param redeemedBy Redeemed By
     * @param quantity Quantity
     * @param {*} [options] Override http request options.
     */
    public allocateOnlineRedemptionCode (campaign: string, timeslot: string, redemption: string, pricingCategoryId?: string, redeemedBy?: string, quantity?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<OnlineRedemptionCodeDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/redemptions/{redemption}/allocate'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'redemption' + '}', encodeURIComponent(String(redemption)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling allocateOnlineRedemptionCode.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling allocateOnlineRedemptionCode.');
        }

        // verify required parameter 'redemption' is not null or undefined
        if (redemption === null || redemption === undefined) {
            throw new Error('Required parameter redemption was null or undefined when calling allocateOnlineRedemptionCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (pricingCategoryId !== undefined) {
            localVarFormParams['pricingCategoryId'] = ObjectSerializer.serialize(pricingCategoryId, "string");
        }

        if (redeemedBy !== undefined) {
            localVarFormParams['redeemedBy'] = ObjectSerializer.serialize(redeemedBy, "string");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<OnlineRedemptionCodeDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<OnlineRedemptionCodeDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a connected pricing categories for a given product redemption
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param redemption Redemption ID
     * @param productRedemptionPricingCategory ProductRedemptionPricingCategory ID
     * @param {*} [options] Override http request options.
     */
    public deleteProductRedemptionPricingCategory (campaign: string, timeslot: string, redemption: string, productRedemptionPricingCategory: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/redemptions/{redemption}/pricingcategories/{productRedemptionPricingCategory}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'redemption' + '}', encodeURIComponent(String(redemption)))
            .replace('{' + 'productRedemptionPricingCategory' + '}', encodeURIComponent(String(productRedemptionPricingCategory)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteProductRedemptionPricingCategory.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling deleteProductRedemptionPricingCategory.');
        }

        // verify required parameter 'redemption' is not null or undefined
        if (redemption === null || redemption === undefined) {
            throw new Error('Required parameter redemption was null or undefined when calling deleteProductRedemptionPricingCategory.');
        }

        // verify required parameter 'productRedemptionPricingCategory' is not null or undefined
        if (productRedemptionPricingCategory === null || productRedemptionPricingCategory === undefined) {
            throw new Error('Required parameter productRedemptionPricingCategory was null or undefined when calling deleteProductRedemptionPricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a redemption for an event timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param redemption Redemption ID
     * @param {*} [options] Override http request options.
     */
    public deleteTimeslotRedemption (campaign: string, timeslot: string, redemption: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/redemptions/{redemption}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'redemption' + '}', encodeURIComponent(String(redemption)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteTimeslotRedemption.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling deleteTimeslotRedemption.');
        }

        // verify required parameter 'redemption' is not null or undefined
        if (redemption === null || redemption === undefined) {
            throw new Error('Required parameter redemption was null or undefined when calling deleteTimeslotRedemption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only Administrators are allowed to feature an event
     * @summary Set a time period to feature an event
     * @param campaignId Campaign ID
     * @param {*} [options] Override http request options.
     */
    public featureEvent (campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaignId}/featured'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling featureEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getPosTerminalCampaigns (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<CampaignDto>;  }> {
        const localVarPath = this.basePath + '/pos';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CampaignDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CampaignDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all the connected pricing categories from a given product redemption
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param redemption Redemption ID
     * @param {*} [options] Override http request options.
     */
    public getProductRedemptionPricingCategories (campaign: string, timeslot: string, redemption: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ProductRedemptionPricingCategoryDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/redemptions/{redemption}/pricingcategories'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'redemption' + '}', encodeURIComponent(String(redemption)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getProductRedemptionPricingCategories.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getProductRedemptionPricingCategories.');
        }

        // verify required parameter 'redemption' is not null or undefined
        if (redemption === null || redemption === undefined) {
            throw new Error('Required parameter redemption was null or undefined when calling getProductRedemptionPricingCategories.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ProductRedemptionPricingCategoryDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ProductRedemptionPricingCategoryDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the connected pricing categories from a given product redemption
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param redemption Redemption ID
     * @param productRedemptionPricingCategory ProductRedemptionPricingCategory ID
     * @param {*} [options] Override http request options.
     */
    public getProductRedemptionPricingCategory (campaign: string, timeslot: string, redemption: string, productRedemptionPricingCategory: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ProductRedemptionPricingCategoryDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/redemptions/{redemption}/pricingcategories/{productRedemptionPricingCategory}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'redemption' + '}', encodeURIComponent(String(redemption)))
            .replace('{' + 'productRedemptionPricingCategory' + '}', encodeURIComponent(String(productRedemptionPricingCategory)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getProductRedemptionPricingCategory.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getProductRedemptionPricingCategory.');
        }

        // verify required parameter 'redemption' is not null or undefined
        if (redemption === null || redemption === undefined) {
            throw new Error('Required parameter redemption was null or undefined when calling getProductRedemptionPricingCategory.');
        }

        // verify required parameter 'productRedemptionPricingCategory' is not null or undefined
        if (productRedemptionPricingCategory === null || productRedemptionPricingCategory === undefined) {
            throw new Error('Required parameter productRedemptionPricingCategory was null or undefined when calling getProductRedemptionPricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ProductRedemptionPricingCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProductRedemptionPricingCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves promo codes from a given campaign
     * @param campaign Campaign ID
     * @param promoCode Promo Code ID
     * @param {*} [options] Override http request options.
     */
    public getPromoCode (campaign: string, promoCode: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/promoCodes/{promoCode}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'promoCode' + '}', encodeURIComponent(String(promoCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPromoCode.');
        }

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling getPromoCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all promo codes from a given campaign
     * @param campaign Campaign ID
     * @param {*} [options] Override http request options.
     */
    public getPromoCodes (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/promoCodes'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPromoCodes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of a redemption for an event timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param redemption Redemption ID
     * @param {*} [options] Override http request options.
     */
    public getTimeslotRedemption (campaign: string, timeslot: string, redemption: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RedemptionDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/redemptions/{redemption}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'redemption' + '}', encodeURIComponent(String(redemption)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getTimeslotRedemption.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getTimeslotRedemption.');
        }

        // verify required parameter 'redemption' is not null or undefined
        if (redemption === null || redemption === undefined) {
            throw new Error('Required parameter redemption was null or undefined when calling getTimeslotRedemption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RedemptionDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RedemptionDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all the redemptions from a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param {*} [options] Override http request options.
     */
    public getTimeslotRedemptions (campaign: string, timeslot: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<RedemptionDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/redemptions'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getTimeslotRedemptions.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getTimeslotRedemptions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<RedemptionDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<RedemptionDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Publish / Unpublish an event
     * @param campaignId Campaign ID
     * @param published 0 &#x3D; Unpublish, 1 &#x3D; Publish
     * @param {*} [options] Override http request options.
     */
    public publishEvent (campaignId: string, published: 0 | 1, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaignId}/publish'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling publishEvent.');
        }

        // verify required parameter 'published' is not null or undefined
        if (published === null || published === undefined) {
            throw new Error('Required parameter published was null or undefined when calling publishEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (published !== undefined) {
            localVarFormParams['published'] = ObjectSerializer.serialize(published, "0 | 1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only Administrators are allowed to unfeature an event
     * @summary Unfeature an event
     * @param campaignId Campaign ID
     * @param {*} [options] Override http request options.
     */
    public unfeatureEvent (campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaignId}/featured'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling unfeatureEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the details of a redemption for an event timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param redemption Redemption ID
     * @param description Redemption Details
     * @param website Redemption Website (Only for Redemption Type &#x3D; 3)
     * @param ticketDispatchDelayInSeconds Ticket Dispatch Delay in Seconds (Only for Redemption Type &#x3D; 4)
     * @param issueMultipleTickets Issue Multiple Tickets (Only for Redemption Type &#x3D; 6)
     * @param template ETicket Template Id
     * @param {*} [options] Override http request options.
     */
    public updateTimeslotRedemption (campaign: string, timeslot: string, redemption: string, description?: string, website?: string, ticketDispatchDelayInSeconds?: number, issueMultipleTickets?: boolean, template?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/redemptions/{redemption}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'redemption' + '}', encodeURIComponent(String(redemption)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateTimeslotRedemption.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling updateTimeslotRedemption.');
        }

        // verify required parameter 'redemption' is not null or undefined
        if (redemption === null || redemption === undefined) {
            throw new Error('Required parameter redemption was null or undefined when calling updateTimeslotRedemption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (website !== undefined) {
            localVarFormParams['website'] = ObjectSerializer.serialize(website, "string");
        }

        if (ticketDispatchDelayInSeconds !== undefined) {
            localVarFormParams['ticketDispatchDelayInSeconds'] = ObjectSerializer.serialize(ticketDispatchDelayInSeconds, "number");
        }

        if (issueMultipleTickets !== undefined) {
            localVarFormParams['issueMultipleTickets'] = ObjectSerializer.serialize(issueMultipleTickets, "boolean");
        }

        if (template !== undefined) {
            localVarFormParams['template'] = ObjectSerializer.serialize(template, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CategoriesApiApiKeys {
    JWT,
}

export class CategoriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CategoriesApiApiKeys, value: string) {
        (this.authentications as any)[CategoriesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Only Administrators are allowed to update campaign categories.
     * @summary Updates the details of a campaign category
     * @param categoryId 
     * @param name Category Name
     * @param url Category Url
     * @param {*} [options] Override http request options.
     */
    public addCategory (categoryId: string, name: string, url: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/categories/{categoryId}'
            .replace('{' + 'categoryId' + '}', encodeURIComponent(String(categoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling addCategory.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addCategory.');
        }

        // verify required parameter 'url' is not null or undefined
        if (url === null || url === undefined) {
            throw new Error('Required parameter url was null or undefined when calling addCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (url !== undefined) {
            localVarFormParams['url'] = ObjectSerializer.serialize(url, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only Administrators are allowed to create campaign categories.
     * @summary Adds a new category
     * @param name Category Name
     * @param url Category Url
     * @param {*} [options] Override http request options.
     */
    public addCategory1 (name: string, url: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignCategoryDto;  }> {
        const localVarPath = this.basePath + '/categories';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addCategory1.');
        }

        // verify required parameter 'url' is not null or undefined
        if (url === null || url === undefined) {
            throw new Error('Required parameter url was null or undefined when calling addCategory1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (url !== undefined) {
            localVarFormParams['url'] = ObjectSerializer.serialize(url, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only Administrators are allowed to delete campaign categories.
     * @summary Deletes a campaign category
     * @param categoryId 
     * @param {*} [options] Override http request options.
     */
    public deleteCategory (categoryId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/categories/{categoryId}'
            .replace('{' + 'categoryId' + '}', encodeURIComponent(String(categoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling deleteCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all categories
     * @param body Datatable Request
     * @param {*} [options] Override http request options.
     */
    public getCampaignCategories (body?: DataTablesInput, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DataTablesOutputCampaignCategoryDto;  }> {
        const localVarPath = this.basePath + '/categories/datatable';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DataTablesInput")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataTablesOutputCampaignCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataTablesOutputCampaignCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a breakdown of all event categories
     * @param {*} [options] Override http request options.
     */
    public getCampaignCategoriesCount (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<CampaignCategoryCount>;  }> {
        const localVarPath = this.basePath + '/categories/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CampaignCategoryCount>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CampaignCategoryCount>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all categories
     * @param start Start Row
     * @param rows Number of Rows
     * @param {*} [options] Override http request options.
     */
    public getCategories (start: number, rows: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemsPageResponseCampaignCategoryDto;  }> {
        const localVarPath = this.basePath + '/categories';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getCategories.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getCategories.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPageResponseCampaignCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsPageResponseCampaignCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of a campaign category
     * @param categoryId 
     * @param {*} [options] Override http request options.
     */
    public getCategory (categoryId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignCategoryDto;  }> {
        const localVarPath = this.basePath + '/categories/{categoryId}'
            .replace('{' + 'categoryId' + '}', encodeURIComponent(String(categoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling getCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DatatableApiApiKeys {
    JWT,
}

export class DatatableApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DatatableApiApiKeys, value: string) {
        (this.authentications as any)[DatatableApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve all campaigns
     * @param body Datatable Request
     * @param {*} [options] Override http request options.
     */
    public getCampaigns1 (body?: DataTablesInput, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DataTablesOutputCampaignDto;  }> {
        const localVarPath = this.basePath + '/datatable';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DataTablesInput")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataTablesOutputCampaignDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataTablesOutputCampaignDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ETicketTemplateApiApiKeys {
    JWT,
}

export class ETicketTemplateApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ETicketTemplateApiApiKeys, value: string) {
        (this.authentications as any)[ETicketTemplateApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add an eTicket template
     * @param campaign Campaign ID
     * @param name ETicket Template Name
     * @param eTicketTemplateDocx ETicket Template (.docx)
     * @param {*} [options] Override http request options.
     */
    public addTemplate (campaign: string, name: string, eTicketTemplateDocx: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ETicketTemplateDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/templates'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addTemplate.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addTemplate.');
        }

        // verify required parameter 'eTicketTemplateDocx' is not null or undefined
        if (eTicketTemplateDocx === null || eTicketTemplateDocx === undefined) {
            throw new Error('Required parameter eTicketTemplateDocx was null or undefined when calling addTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (eTicketTemplateDocx !== undefined) {
            localVarFormParams['eTicketTemplateDocx'] = eTicketTemplateDocx;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ETicketTemplateDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ETicketTemplateDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an eTicket template
     * @param campaign Campaign ID
     * @param template ETicket Template ID
     * @param {*} [options] Override http request options.
     */
    public deleteTemplate (campaign: string, template: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/templates/{template}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'template' + '}', encodeURIComponent(String(template)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteTemplate.');
        }

        // verify required parameter 'template' is not null or undefined
        if (template === null || template === undefined) {
            throw new Error('Required parameter template was null or undefined when calling deleteTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve an eTicket template
     * @param campaign Campaign ID
     * @param template ETicket Template ID
     * @param {*} [options] Override http request options.
     */
    public getTemplate (campaign: string, template: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ETicketTemplateDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/templates/{template}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'template' + '}', encodeURIComponent(String(template)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getTemplate.');
        }

        // verify required parameter 'template' is not null or undefined
        if (template === null || template === undefined) {
            throw new Error('Required parameter template was null or undefined when calling getTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ETicketTemplateDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ETicketTemplateDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve eTicket templates from campaign
     * @param campaign Campaign ID
     * @param {*} [options] Override http request options.
     */
    public getTemplates (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ETicketTemplateDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/templates'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getTemplates.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ETicketTemplateDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ETicketTemplateDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an eTicket template
     * @param campaign Campaign ID
     * @param template ETicket Template ID
     * @param name ETicket Template Name
     * @param eTicketTemplateDocx ETicket Template (.docx)
     * @param {*} [options] Override http request options.
     */
    public updateTemplate (campaign: string, template: string, name: string, eTicketTemplateDocx?: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/templates/{template}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'template' + '}', encodeURIComponent(String(template)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateTemplate.');
        }

        // verify required parameter 'template' is not null or undefined
        if (template === null || template === undefined) {
            throw new Error('Required parameter template was null or undefined when calling updateTemplate.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (eTicketTemplateDocx !== undefined) {
            localVarFormParams['eTicketTemplateDocx'] = eTicketTemplateDocx;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InventoryLedgerApiApiKeys {
    JWT,
}

export class InventoryLedgerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InventoryLedgerApiApiKeys, value: string) {
        (this.authentications as any)[InventoryLedgerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add an inventory ledger to selected pricing
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param quantity Quantity
     * @param cardIssuer Card Issuer Id
     * @param {*} [options] Override http request options.
     */
    public addInventoryLedger (campaign: string, timeslot: string, pricing: string, quantity: number, cardIssuer?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: InventoryLedgerDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/inventoryLedger'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addInventoryLedger.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling addInventoryLedger.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling addInventoryLedger.');
        }

        // verify required parameter 'quantity' is not null or undefined
        if (quantity === null || quantity === undefined) {
            throw new Error('Required parameter quantity was null or undefined when calling addInventoryLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (cardIssuer !== undefined) {
            localVarFormParams['cardIssuer'] = ObjectSerializer.serialize(cardIssuer, "string");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InventoryLedgerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InventoryLedgerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete the inventory ledger to selected pricing
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param inventoryLedgerId 
     * @param {*} [options] Override http request options.
     */
    public deleteInventoryLedger (campaign: string, timeslot: string, pricing: string, inventoryLedgerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/inventoryLedger/{inventoryLedgerId}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'inventoryLedgerId' + '}', encodeURIComponent(String(inventoryLedgerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteInventoryLedger.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling deleteInventoryLedger.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling deleteInventoryLedger.');
        }

        // verify required parameter 'inventoryLedgerId' is not null or undefined
        if (inventoryLedgerId === null || inventoryLedgerId === undefined) {
            throw new Error('Required parameter inventoryLedgerId was null or undefined when calling deleteInventoryLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve inventory ledger for a given pricing
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param inventoryLedgerId 
     * @param {*} [options] Override http request options.
     */
    public getInventoryLedger (campaign: string, timeslot: string, pricing: string, inventoryLedgerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: InventoryLedgerDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/inventoryLedger/{inventoryLedgerId}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'inventoryLedgerId' + '}', encodeURIComponent(String(inventoryLedgerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getInventoryLedger.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getInventoryLedger.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getInventoryLedger.');
        }

        // verify required parameter 'inventoryLedgerId' is not null or undefined
        if (inventoryLedgerId === null || inventoryLedgerId === undefined) {
            throw new Error('Required parameter inventoryLedgerId was null or undefined when calling getInventoryLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InventoryLedgerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InventoryLedgerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Invalidate the inventory ledger to selected pricing
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param inventoryLedgerId 
     * @param {*} [options] Override http request options.
     */
    public invalidateInventoryLedger (campaign: string, timeslot: string, pricing: string, inventoryLedgerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/inventoryLedger/{inventoryLedgerId}/invalidate'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'inventoryLedgerId' + '}', encodeURIComponent(String(inventoryLedgerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling invalidateInventoryLedger.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling invalidateInventoryLedger.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling invalidateInventoryLedger.');
        }

        // verify required parameter 'inventoryLedgerId' is not null or undefined
        if (inventoryLedgerId === null || inventoryLedgerId === undefined) {
            throw new Error('Required parameter inventoryLedgerId was null or undefined when calling invalidateInventoryLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Redeem the inventory ledger to selected pricing
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param inventoryLedgerId 
     * @param {*} [options] Override http request options.
     */
    public redeemInventoryLedger (campaign: string, timeslot: string, pricing: string, inventoryLedgerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/inventoryLedger/{inventoryLedgerId}/redeem'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'inventoryLedgerId' + '}', encodeURIComponent(String(inventoryLedgerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling redeemInventoryLedger.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling redeemInventoryLedger.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling redeemInventoryLedger.');
        }

        // verify required parameter 'inventoryLedgerId' is not null or undefined
        if (inventoryLedgerId === null || inventoryLedgerId === undefined) {
            throw new Error('Required parameter inventoryLedgerId was null or undefined when calling redeemInventoryLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update the inventory ledger to selected pricing
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param inventoryLedgerId 
     * @param quantity Quantity
     * @param cardIssuer Card Issuer Id
     * @param expiresAt Expires Date/Time of inventory ledger with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param {*} [options] Override http request options.
     */
    public updateInventoryLedger (campaign: string, timeslot: string, pricing: string, inventoryLedgerId: string, quantity: number, cardIssuer?: string, expiresAt?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/inventoryLedger/{inventoryLedgerId}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'inventoryLedgerId' + '}', encodeURIComponent(String(inventoryLedgerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateInventoryLedger.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling updateInventoryLedger.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling updateInventoryLedger.');
        }

        // verify required parameter 'inventoryLedgerId' is not null or undefined
        if (inventoryLedgerId === null || inventoryLedgerId === undefined) {
            throw new Error('Required parameter inventoryLedgerId was null or undefined when calling updateInventoryLedger.');
        }

        // verify required parameter 'quantity' is not null or undefined
        if (quantity === null || quantity === undefined) {
            throw new Error('Required parameter quantity was null or undefined when calling updateInventoryLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (cardIssuer !== undefined) {
            localVarFormParams['cardIssuer'] = ObjectSerializer.serialize(cardIssuer, "string");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expiresAt'] = ObjectSerializer.serialize(expiresAt, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LocationsApiApiKeys {
    JWT,
}

export class LocationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LocationsApiApiKeys, value: string) {
        (this.authentications as any)[LocationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new location
     * @param name Location Name
     * @param postalAddress Postal Address
     * @param postalCode Postal Code
     * @param city City
     * @param state State
     * @param country Country Code (ISO 3166)
     * @param latitude Latitude
     * @param longitude Longitude
     * @param image Location Image
     * @param {*} [options] Override http request options.
     */
    public addLocation (name: string, postalAddress: string, postalCode: string, city: string, state: string, country: string, latitude: number, longitude: number, image?: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LocationDto;  }> {
        const localVarPath = this.basePath + '/locations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addLocation.');
        }

        // verify required parameter 'postalAddress' is not null or undefined
        if (postalAddress === null || postalAddress === undefined) {
            throw new Error('Required parameter postalAddress was null or undefined when calling addLocation.');
        }

        // verify required parameter 'postalCode' is not null or undefined
        if (postalCode === null || postalCode === undefined) {
            throw new Error('Required parameter postalCode was null or undefined when calling addLocation.');
        }

        // verify required parameter 'city' is not null or undefined
        if (city === null || city === undefined) {
            throw new Error('Required parameter city was null or undefined when calling addLocation.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling addLocation.');
        }

        // verify required parameter 'country' is not null or undefined
        if (country === null || country === undefined) {
            throw new Error('Required parameter country was null or undefined when calling addLocation.');
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling addLocation.');
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling addLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (image !== undefined) {
            localVarFormParams['image'] = image;
        }
        localVarUseFormData = true;

        if (postalAddress !== undefined) {
            localVarFormParams['postalAddress'] = ObjectSerializer.serialize(postalAddress, "string");
        }

        if (postalCode !== undefined) {
            localVarFormParams['postalCode'] = ObjectSerializer.serialize(postalCode, "string");
        }

        if (city !== undefined) {
            localVarFormParams['city'] = ObjectSerializer.serialize(city, "string");
        }

        if (state !== undefined) {
            localVarFormParams['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (country !== undefined) {
            localVarFormParams['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (latitude !== undefined) {
            localVarFormParams['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarFormParams['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LocationDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LocationDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only Administrators are allowed to delete locations.
     * @summary Deletes a location
     * @param locationId 
     * @param {*} [options] Override http request options.
     */
    public deleteLocation (locationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/locations/{locationId}'
            .replace('{' + 'locationId' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of a location
     * @param locationId 
     * @param {*} [options] Override http request options.
     */
    public getLocation (locationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LocationDto;  }> {
        const localVarPath = this.basePath + '/locations/{locationId}'
            .replace('{' + 'locationId' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LocationDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LocationDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all locations
     * @param start Start Row
     * @param rows Number of Rows
     * @param {*} [options] Override http request options.
     */
    public getLocations (start: number, rows: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemsPageResponse;  }> {
        const localVarPath = this.basePath + '/locations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getLocations.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getLocations.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPageResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsPageResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all locations
     * @param body Datatable Request
     * @param {*} [options] Override http request options.
     */
    public getTags (body?: DataTablesInput, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DataTablesOutputLocationDto;  }> {
        const localVarPath = this.basePath + '/locations/datatable';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DataTablesInput")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataTablesOutputLocationDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataTablesOutputLocationDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of a location
     * @param start Start Row
     * @param rows Number of Rows
     * @param searchTerm Search Term
     * @param {*} [options] Override http request options.
     */
    public searchLocation (start: number, rows: number, searchTerm?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LocationDto;  }> {
        const localVarPath = this.basePath + '/locations/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling searchLocation.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling searchLocation.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LocationDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LocationDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only Administrators are allowed to update locations.
     * @summary Updates the details of a location
     * @param locationId 
     * @param name Location Name
     * @param postalAddress Postal Address
     * @param postalCode Postal Code
     * @param city City
     * @param state State
     * @param country Country Code (ISO 3166)
     * @param latitude Latitude
     * @param longitude Longitude
     * @param image Location Image
     * @param {*} [options] Override http request options.
     */
    public updateLocation (locationId: string, name: string, postalAddress: string, postalCode: string, city: string, state: string, country: string, latitude: number, longitude: number, image?: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/locations/{locationId}'
            .replace('{' + 'locationId' + '}', encodeURIComponent(String(locationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'postalAddress' is not null or undefined
        if (postalAddress === null || postalAddress === undefined) {
            throw new Error('Required parameter postalAddress was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'postalCode' is not null or undefined
        if (postalCode === null || postalCode === undefined) {
            throw new Error('Required parameter postalCode was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'city' is not null or undefined
        if (city === null || city === undefined) {
            throw new Error('Required parameter city was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'country' is not null or undefined
        if (country === null || country === undefined) {
            throw new Error('Required parameter country was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling updateLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (image !== undefined) {
            localVarFormParams['image'] = image;
        }
        localVarUseFormData = true;

        if (postalAddress !== undefined) {
            localVarFormParams['postalAddress'] = ObjectSerializer.serialize(postalAddress, "string");
        }

        if (postalCode !== undefined) {
            localVarFormParams['postalCode'] = ObjectSerializer.serialize(postalCode, "string");
        }

        if (city !== undefined) {
            localVarFormParams['city'] = ObjectSerializer.serialize(city, "string");
        }

        if (state !== undefined) {
            localVarFormParams['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (country !== undefined) {
            localVarFormParams['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (latitude !== undefined) {
            localVarFormParams['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarFormParams['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LookupApiApiKeys {
    JWT,
}

export class LookupApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LookupApiApiKeys, value: string) {
        (this.authentications as any)[LookupApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve the campaign ID from an alias ID
     * @param aliasId Alias ID
     * @param {*} [options] Override http request options.
     */
    public getCampaignIdByIdOrAliasId (aliasId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/lookup/alias/{aliasId}'
            .replace('{' + 'aliasId' + '}', encodeURIComponent(String(aliasId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'aliasId' is not null or undefined
        if (aliasId === null || aliasId === undefined) {
            throw new Error('Required parameter aliasId was null or undefined when calling getCampaignIdByIdOrAliasId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getRedemptionDatabaseEnabledCampaigns (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/lookup/redemptionDatabaseEnabled';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaignId 
     * @param {*} [options] Override http request options.
     */
    public isCampaignExists (campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/isCampaignExists/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isCampaignExists.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaignId 
     * @param {*} [options] Override http request options.
     */
    public isCampaignPublished (campaignId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/campaigns/{campaignId}/isPublished'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isCampaignPublished.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaignId 
     * @param timeslotId 
     * @param {*} [options] Override http request options.
     */
    public isCampaignTimeslotExists (campaignId: string, timeslotId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/isCampaignExists/{campaignId}/timeslots/{timeslotId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)))
            .replace('{' + 'timeslotId' + '}', encodeURIComponent(String(timeslotId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isCampaignTimeslotExists.');
        }

        // verify required parameter 'timeslotId' is not null or undefined
        if (timeslotId === null || timeslotId === undefined) {
            throw new Error('Required parameter timeslotId was null or undefined when calling isCampaignTimeslotExists.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaignId 
     * @param timeslotId 
     * @param {*} [options] Override http request options.
     */
    public isCampaignTimeslotPublished (campaignId: string, timeslotId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/campaigns/{campaignId}/timeslots/{timeslotId}/isPublished'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)))
            .replace('{' + 'timeslotId' + '}', encodeURIComponent(String(timeslotId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isCampaignTimeslotPublished.');
        }

        // verify required parameter 'timeslotId' is not null or undefined
        if (timeslotId === null || timeslotId === undefined) {
            throw new Error('Required parameter timeslotId was null or undefined when calling isCampaignTimeslotPublished.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param categoryId 
     * @param {*} [options] Override http request options.
     */
    public isCategoryExists (categoryId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/isCategoryExists/{categoryId}'
            .replace('{' + 'categoryId' + '}', encodeURIComponent(String(categoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling isCategoryExists.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaignId 
     * @param pricingCategoryId 
     * @param {*} [options] Override http request options.
     */
    public isPricingCategoryExists (campaignId: string, pricingCategoryId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/lookup/campaigns/{campaignId}/pricingCategories/{pricingCategoryId}/isExists'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)))
            .replace('{' + 'pricingCategoryId' + '}', encodeURIComponent(String(pricingCategoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling isPricingCategoryExists.');
        }

        // verify required parameter 'pricingCategoryId' is not null or undefined
        if (pricingCategoryId === null || pricingCategoryId === undefined) {
            throw new Error('Required parameter pricingCategoryId was null or undefined when calling isPricingCategoryExists.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PricingApiApiKeys {
    JWT,
}

export class PricingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PricingApiApiKeys, value: string) {
        (this.authentications as any)[PricingApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new pricing for this timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricingCategory Pricing Category ID
     * @param salesChannel 1 &#x3D; User (Public), 2 &#x3D; User (Private), 3 &#x3D; Merchant, 4 &#x3D; Marketing, 5 &#x3D; Distribution
     * @param totalInventory Total Inventory
     * @param currency Currency Code (ISO 4217) Eg. USD
     * @param price Price (in cents)
     * @param costPrice Cost Price (in cents)
     * @param maximumPrice Maximum Price (in cents)
     * @param privateDescription Private Description
     * @param images Pricing Images
     * @param images2 Pricing Images Details
     * @param entitlements Pricing Entitlements
     * @param ticketsIssuedPerInventory Tickets Issued Per Inventory
     * @param validFrom Pricing Valid From Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param validTo Pricing Valid To Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param inventoryAvailableFrom Inventory Available From Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param inventoryAvailableTo Inventory Available To Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param password Password
     * @param minimumQuantity Minimum Quantity
     * @param quantityIncrement Quantity Increment
     * @param maximumQuantity Maximum Quantity
     * @param bookingFee Booking Fee
     * @param bookingFeeInPercent Indicates whether Booking Fee is in percentage format
     * @param onlineRedemptionCodes Online Redemption Codes seperated by commas (For Online Redemption only)
     * @param {*} [options] Override http request options.
     */
    public addPricing (campaign: string, timeslot: string, pricingCategory: string, salesChannel: 1 | 2 | 3 | 4 | 5, totalInventory: number, currency: string, price: number, costPrice: number, maximumPrice: number, privateDescription?: string, images?: Buffer, entitlements?: string, ticketsIssuedPerInventory?: number, validFrom?: Date, validTo?: Date, inventoryAvailableFrom?: Date, inventoryAvailableTo?: Date, password?: string, minimumQuantity?: number, quantityIncrement?: number, maximumQuantity?: number, bookingFee?: number, bookingFeeInPercent?: boolean, onlineRedemptionCodes?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addPricing.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling addPricing.');
        }

        // verify required parameter 'pricingCategory' is not null or undefined
        if (pricingCategory === null || pricingCategory === undefined) {
            throw new Error('Required parameter pricingCategory was null or undefined when calling addPricing.');
        }

        // verify required parameter 'salesChannel' is not null or undefined
        if (salesChannel === null || salesChannel === undefined) {
            throw new Error('Required parameter salesChannel was null or undefined when calling addPricing.');
        }

        // verify required parameter 'totalInventory' is not null or undefined
        if (totalInventory === null || totalInventory === undefined) {
            throw new Error('Required parameter totalInventory was null or undefined when calling addPricing.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling addPricing.');
        }

        // verify required parameter 'price' is not null or undefined
        if (price === null || price === undefined) {
            throw new Error('Required parameter price was null or undefined when calling addPricing.');
        }

        // verify required parameter 'costPrice' is not null or undefined
        if (costPrice === null || costPrice === undefined) {
            throw new Error('Required parameter costPrice was null or undefined when calling addPricing.');
        }

        // verify required parameter 'maximumPrice' is not null or undefined
        if (maximumPrice === null || maximumPrice === undefined) {
            throw new Error('Required parameter maximumPrice was null or undefined when calling addPricing.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (pricingCategory !== undefined) {
            localVarFormParams['pricingCategory'] = ObjectSerializer.serialize(pricingCategory, "string");
        }

        if (salesChannel !== undefined) {
            localVarFormParams['salesChannel'] = ObjectSerializer.serialize(salesChannel, "1 | 2 | 3 | 4 | 5");
        }

        if (privateDescription !== undefined) {
            localVarFormParams['privateDescription'] = ObjectSerializer.serialize(privateDescription, "string");
        }

        if (images !== undefined) {
            localVarFormParams['images'] = images;
        }
        localVarUseFormData = true;

        if (entitlements !== undefined) {
            localVarFormParams['entitlements'] = ObjectSerializer.serialize(entitlements, "string");
        }

        if (totalInventory !== undefined) {
            localVarFormParams['totalInventory'] = ObjectSerializer.serialize(totalInventory, "number");
        }

        if (ticketsIssuedPerInventory !== undefined) {
            localVarFormParams['ticketsIssuedPerInventory'] = ObjectSerializer.serialize(ticketsIssuedPerInventory, "number");
        }

        if (validFrom !== undefined) {
            localVarFormParams['validFrom'] = ObjectSerializer.serialize(validFrom, "Date");
        }

        if (validTo !== undefined) {
            localVarFormParams['validTo'] = ObjectSerializer.serialize(validTo, "Date");
        }

        if (inventoryAvailableFrom !== undefined) {
            localVarFormParams['inventoryAvailableFrom'] = ObjectSerializer.serialize(inventoryAvailableFrom, "Date");
        }

        if (inventoryAvailableTo !== undefined) {
            localVarFormParams['inventoryAvailableTo'] = ObjectSerializer.serialize(inventoryAvailableTo, "Date");
        }

        if (password !== undefined) {
            localVarFormParams['password'] = ObjectSerializer.serialize(password, "string");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (minimumQuantity !== undefined) {
            localVarFormParams['minimumQuantity'] = ObjectSerializer.serialize(minimumQuantity, "number");
        }

        if (quantityIncrement !== undefined) {
            localVarFormParams['quantityIncrement'] = ObjectSerializer.serialize(quantityIncrement, "number");
        }

        if (maximumQuantity !== undefined) {
            localVarFormParams['maximumQuantity'] = ObjectSerializer.serialize(maximumQuantity, "number");
        }

        if (price !== undefined) {
            localVarFormParams['price'] = ObjectSerializer.serialize(price, "number");
        }

        if (costPrice !== undefined) {
            localVarFormParams['costPrice'] = ObjectSerializer.serialize(costPrice, "number");
        }

        if (maximumPrice !== undefined) {
            localVarFormParams['maximumPrice'] = ObjectSerializer.serialize(maximumPrice, "number");
        }

        if (bookingFee !== undefined) {
            localVarFormParams['bookingFee'] = ObjectSerializer.serialize(bookingFee, "number");
        }

        if (bookingFeeInPercent !== undefined) {
            localVarFormParams['bookingFeeInPercent'] = ObjectSerializer.serialize(bookingFeeInPercent, "boolean");
        }

        if (onlineRedemptionCodes !== undefined) {
            localVarFormParams['onlineRedemptionCodes'] = ObjectSerializer.serialize(onlineRedemptionCodes, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the pricing for a given timeslot
     * @param campaign 
     * @param timeslot 
     * @param pricing 
     * @param {*} [options] Override http request options.
     */
    public deletePricing (campaign: string, timeslot: string, pricing: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deletePricing.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling deletePricing.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling deletePricing.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param {*} [options] Override http request options.
     */
    public getPricing (campaign: string, timeslot: string, pricing: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricing.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getPricing.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getPricing.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing 
     * @param {*} [options] Override http request options.
     */
    public getPricingCommissionRate (campaign: string, timeslot: string, pricing: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/commissionRate'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingCommissionRate.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getPricingCommissionRate.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getPricingCommissionRate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve all pricings for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param {*} [options] Override http request options.
     */
    public getPricings (campaign: string, timeslot: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PricingDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricings.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getPricings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PricingDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PricingDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the pricing for a given timeslot
     * @param campaign 
     * @param timeslot 
     * @param pricing 
     * @param pricingCategory Pricing Category ID
     * @param salesChannel 1 &#x3D; User (Public), 2 &#x3D; User (Private), 3 &#x3D; Merchant, 4 &#x3D; Marketing, 5 &#x3D; Distribution
     * @param totalInventory Total Inventory
     * @param privateDescription Private Description
     * @param images Pricing Seatings Images
     * @param images2 Pricing Seatings Images Details
     * @param deletedImages IDs of deleted images
     * @param entitlements Pricing Entitlements
     * @param ticketsIssuedPerInventory Quantity Per Inventory
     * @param validFrom Pricing Available From Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param validTo Pricing Available To Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param inventoryAvailableFrom Inventory Available From Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param inventoryAvailableTo Inventory Available To Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param password Password
     * @param onlineRedemptionCodes Online Redemption Codes seperated by commas (For Online Redemption only)
     * @param {*} [options] Override http request options.
     */
    public updatePricing (campaign: string, timeslot: string, pricing: string, pricingCategory: string, salesChannel: 1 | 2 | 3 | 4 | 5, totalInventory: number, privateDescription?: string, images?: Buffer, deletedImages?: Array<string>, entitlements?: string, ticketsIssuedPerInventory?: number, validFrom?: Date, validTo?: Date, inventoryAvailableFrom?: Date, inventoryAvailableTo?: Date, password?: string, onlineRedemptionCodes?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updatePricing.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling updatePricing.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling updatePricing.');
        }

        // verify required parameter 'pricingCategory' is not null or undefined
        if (pricingCategory === null || pricingCategory === undefined) {
            throw new Error('Required parameter pricingCategory was null or undefined when calling updatePricing.');
        }

        // verify required parameter 'salesChannel' is not null or undefined
        if (salesChannel === null || salesChannel === undefined) {
            throw new Error('Required parameter salesChannel was null or undefined when calling updatePricing.');
        }

        // verify required parameter 'totalInventory' is not null or undefined
        if (totalInventory === null || totalInventory === undefined) {
            throw new Error('Required parameter totalInventory was null or undefined when calling updatePricing.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (pricingCategory !== undefined) {
            localVarFormParams['pricingCategory'] = ObjectSerializer.serialize(pricingCategory, "string");
        }

        if (salesChannel !== undefined) {
            localVarFormParams['salesChannel'] = ObjectSerializer.serialize(salesChannel, "1 | 2 | 3 | 4 | 5");
        }

        if (privateDescription !== undefined) {
            localVarFormParams['privateDescription'] = ObjectSerializer.serialize(privateDescription, "string");
        }

        if (images !== undefined) {
            localVarFormParams['images'] = images;
        }
        localVarUseFormData = true;

        if (deletedImages !== undefined) {
            localVarFormParams['deletedImages'] = ObjectSerializer.serialize(deletedImages, "Array<string>");
        }

        if (entitlements !== undefined) {
            localVarFormParams['entitlements'] = ObjectSerializer.serialize(entitlements, "string");
        }

        if (totalInventory !== undefined) {
            localVarFormParams['totalInventory'] = ObjectSerializer.serialize(totalInventory, "number");
        }

        if (ticketsIssuedPerInventory !== undefined) {
            localVarFormParams['ticketsIssuedPerInventory'] = ObjectSerializer.serialize(ticketsIssuedPerInventory, "number");
        }

        if (validFrom !== undefined) {
            localVarFormParams['validFrom'] = ObjectSerializer.serialize(validFrom, "Date");
        }

        if (validTo !== undefined) {
            localVarFormParams['validTo'] = ObjectSerializer.serialize(validTo, "Date");
        }

        if (inventoryAvailableFrom !== undefined) {
            localVarFormParams['inventoryAvailableFrom'] = ObjectSerializer.serialize(inventoryAvailableFrom, "Date");
        }

        if (inventoryAvailableTo !== undefined) {
            localVarFormParams['inventoryAvailableTo'] = ObjectSerializer.serialize(inventoryAvailableTo, "Date");
        }

        if (password !== undefined) {
            localVarFormParams['password'] = ObjectSerializer.serialize(password, "string");
        }

        if (onlineRedemptionCodes !== undefined) {
            localVarFormParams['onlineRedemptionCodes'] = ObjectSerializer.serialize(onlineRedemptionCodes, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PricingAddonsApiApiKeys {
    JWT,
}

export class PricingAddonsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PricingAddonsApiApiKeys, value: string) {
        (this.authentications as any)[PricingAddonsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds an add on to the selected pricing for this timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param {*} [options] Override http request options.
     */
    public addPricingAddOn (campaign: string, timeslot: string, pricing: string, addon: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingAddOnDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addPricingAddOn.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling addPricingAddOn.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling addPricingAddOn.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling addPricingAddOn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (addon !== undefined) {
            localVarFormParams['addon'] = ObjectSerializer.serialize(addon, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingAddOnDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingAddOnDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds an add on option to the selected pricing for this timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param option Option ID
     * @param price Price (in cents)
     * @param currency Currency Code (ISO 4217) Eg. USD
     * @param totalInventory Total Inventory
     * @param costPrice Cost Price
     * @param maximumPrice Maximum Price
     * @param bookingFee Booking Fee
     * @param bookingFeeInPercent Booking Fee In Percent
     * @param transactionFee Transaction Fee
     * @param {*} [options] Override http request options.
     */
    public addPricingAddOnOption (campaign: string, timeslot: string, pricing: string, addon: string, option: string, price: number, currency: string, totalInventory: number, costPrice?: number, maximumPrice?: number, bookingFee?: number, bookingFeeInPercent?: boolean, transactionFee?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingAddOnOptionDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons/{addon}/options'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addPricingAddOnOption.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling addPricingAddOnOption.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling addPricingAddOnOption.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling addPricingAddOnOption.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling addPricingAddOnOption.');
        }

        // verify required parameter 'price' is not null or undefined
        if (price === null || price === undefined) {
            throw new Error('Required parameter price was null or undefined when calling addPricingAddOnOption.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling addPricingAddOnOption.');
        }

        // verify required parameter 'totalInventory' is not null or undefined
        if (totalInventory === null || totalInventory === undefined) {
            throw new Error('Required parameter totalInventory was null or undefined when calling addPricingAddOnOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (option !== undefined) {
            localVarFormParams['option'] = ObjectSerializer.serialize(option, "string");
        }

        if (price !== undefined) {
            localVarFormParams['price'] = ObjectSerializer.serialize(price, "number");
        }

        if (costPrice !== undefined) {
            localVarFormParams['costPrice'] = ObjectSerializer.serialize(costPrice, "number");
        }

        if (maximumPrice !== undefined) {
            localVarFormParams['maximumPrice'] = ObjectSerializer.serialize(maximumPrice, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (totalInventory !== undefined) {
            localVarFormParams['totalInventory'] = ObjectSerializer.serialize(totalInventory, "number");
        }

        if (bookingFee !== undefined) {
            localVarFormParams['bookingFee'] = ObjectSerializer.serialize(bookingFee, "number");
        }

        if (bookingFeeInPercent !== undefined) {
            localVarFormParams['bookingFeeInPercent'] = ObjectSerializer.serialize(bookingFeeInPercent, "boolean");
        }

        if (transactionFee !== undefined) {
            localVarFormParams['transactionFee'] = ObjectSerializer.serialize(transactionFee, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingAddOnOptionDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingAddOnOptionDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the pricing add on for a given pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Campaign Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param {*} [options] Override http request options.
     */
    public deletePricingAddOn (campaign: string, timeslot: string, pricing: string, addon: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons/{addon}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deletePricingAddOn.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling deletePricingAddOn.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling deletePricingAddOn.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling deletePricingAddOn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the pricing add on option for a given pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Campaign Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param option Option ID
     * @param {*} [options] Override http request options.
     */
    public deletePricingAddOnOption (campaign: string, timeslot: string, pricing: string, addon: string, option: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons/{addon}/options/{option}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)))
            .replace('{' + 'option' + '}', encodeURIComponent(String(option)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deletePricingAddOnOption.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling deletePricingAddOnOption.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling deletePricingAddOnOption.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling deletePricingAddOnOption.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling deletePricingAddOnOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaign Campaign ID
     * @param timeslot Campaign Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param {*} [options] Override http request options.
     */
    public getPricingAddOn (campaign: string, timeslot: string, pricing: string, addon: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingAddOnDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons/{addon}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingAddOn.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getPricingAddOn.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getPricingAddOn.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling getPricingAddOn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingAddOnDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingAddOnDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a given add on option for a given pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Campaign Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param option Option ID
     * @param {*} [options] Override http request options.
     */
    public getPricingAddOnOption (campaign: string, timeslot: string, pricing: string, addon: string, option: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingAddOnOptionDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons/{addon}/options/{option}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)))
            .replace('{' + 'option' + '}', encodeURIComponent(String(option)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingAddOnOption.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getPricingAddOnOption.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getPricingAddOnOption.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling getPricingAddOnOption.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling getPricingAddOnOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingAddOnOptionDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingAddOnOptionDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve all pricing add ons for a given pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param {*} [options] Override http request options.
     */
    public getPricingAddOnOptions (campaign: string, timeslot: string, pricing: string, addon: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PricingAddOnOptionDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons/{addon}/options'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingAddOnOptions.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getPricingAddOnOptions.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getPricingAddOnOptions.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling getPricingAddOnOptions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PricingAddOnOptionDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PricingAddOnOptionDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve all pricing add ons for a given pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param {*} [options] Override http request options.
     */
    public getPricingAddOns (campaign: string, timeslot: string, pricing: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PricingAddOnDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingAddOns.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getPricingAddOns.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getPricingAddOns.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PricingAddOnDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PricingAddOnDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the pricing add on option for a given pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Campaign Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param option Option ID
     * @param price Price (in cents)
     * @param currency Currency Code (ISO 4217) Eg. USD
     * @param totalInventory Total Inventory
     * @param costPrice Cost Price
     * @param maximumPrice Maximum Price
     * @param bookingFee Booking Fee
     * @param bookingFeeInPercent Booking Fee In Percent
     * @param transactionFee Transaction Fee
     * @param {*} [options] Override http request options.
     */
    public updatePricingAddOnOption (campaign: string, timeslot: string, pricing: string, addon: string, option: string, price: number, currency: string, totalInventory: number, costPrice?: number, maximumPrice?: number, bookingFee?: number, bookingFeeInPercent?: boolean, transactionFee?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons/{addon}/options/{option}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)))
            .replace('{' + 'option' + '}', encodeURIComponent(String(option)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updatePricingAddOnOption.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling updatePricingAddOnOption.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling updatePricingAddOnOption.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling updatePricingAddOnOption.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling updatePricingAddOnOption.');
        }

        // verify required parameter 'price' is not null or undefined
        if (price === null || price === undefined) {
            throw new Error('Required parameter price was null or undefined when calling updatePricingAddOnOption.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling updatePricingAddOnOption.');
        }

        // verify required parameter 'totalInventory' is not null or undefined
        if (totalInventory === null || totalInventory === undefined) {
            throw new Error('Required parameter totalInventory was null or undefined when calling updatePricingAddOnOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (price !== undefined) {
            localVarFormParams['price'] = ObjectSerializer.serialize(price, "number");
        }

        if (costPrice !== undefined) {
            localVarFormParams['costPrice'] = ObjectSerializer.serialize(costPrice, "number");
        }

        if (maximumPrice !== undefined) {
            localVarFormParams['maximumPrice'] = ObjectSerializer.serialize(maximumPrice, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (totalInventory !== undefined) {
            localVarFormParams['totalInventory'] = ObjectSerializer.serialize(totalInventory, "number");
        }

        if (bookingFee !== undefined) {
            localVarFormParams['bookingFee'] = ObjectSerializer.serialize(bookingFee, "number");
        }

        if (bookingFeeInPercent !== undefined) {
            localVarFormParams['bookingFeeInPercent'] = ObjectSerializer.serialize(bookingFeeInPercent, "boolean");
        }

        if (transactionFee !== undefined) {
            localVarFormParams['transactionFee'] = ObjectSerializer.serialize(transactionFee, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PricingAddonsOptionInventoryLedgerApiApiKeys {
    JWT,
}

export class PricingAddonsOptionInventoryLedgerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PricingAddonsOptionInventoryLedgerApiApiKeys, value: string) {
        (this.authentications as any)[PricingAddonsOptionInventoryLedgerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add an inventory ledger to selected option
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param option Option ID
     * @param quantity Quantity
     * @param {*} [options] Override http request options.
     */
    public addPricingAddOnOptionInventoryLedger (campaign: string, timeslot: string, pricing: string, addon: string, option: string, quantity: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingAddOnOptionInventoryLedgerDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons/{addon}/options/{option}/inventoryLedger'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)))
            .replace('{' + 'option' + '}', encodeURIComponent(String(option)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling addPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling addPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling addPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling addPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'quantity' is not null or undefined
        if (quantity === null || quantity === undefined) {
            throw new Error('Required parameter quantity was null or undefined when calling addPricingAddOnOptionInventoryLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingAddOnOptionInventoryLedgerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingAddOnOptionInventoryLedgerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an inventory ledger to selected option
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param option Option ID
     * @param inventoryLedgerId Inventory Ledger ID
     * @param {*} [options] Override http request options.
     */
    public deletePricingAddOnOptionInventoryLedger (campaign: string, timeslot: string, pricing: string, addon: string, option: string, inventoryLedgerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons/{addon}/options/{option}/inventoryLedger/{inventoryLedgerId}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)))
            .replace('{' + 'option' + '}', encodeURIComponent(String(option)))
            .replace('{' + 'inventoryLedgerId' + '}', encodeURIComponent(String(inventoryLedgerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deletePricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling deletePricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling deletePricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling deletePricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling deletePricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'inventoryLedgerId' is not null or undefined
        if (inventoryLedgerId === null || inventoryLedgerId === undefined) {
            throw new Error('Required parameter inventoryLedgerId was null or undefined when calling deletePricingAddOnOptionInventoryLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve inventory ledger for a given option
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param option Option ID
     * @param inventoryLedgerId Inventory Ledger ID
     * @param {*} [options] Override http request options.
     */
    public getPricingAddOnOptionInventoryLedger (campaign: string, timeslot: string, pricing: string, addon: string, option: string, inventoryLedgerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingAddOnOptionInventoryLedgerDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons/{addon}/options/{option}/inventoryLedger/{inventoryLedgerId}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)))
            .replace('{' + 'option' + '}', encodeURIComponent(String(option)))
            .replace('{' + 'inventoryLedgerId' + '}', encodeURIComponent(String(inventoryLedgerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling getPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling getPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'inventoryLedgerId' is not null or undefined
        if (inventoryLedgerId === null || inventoryLedgerId === undefined) {
            throw new Error('Required parameter inventoryLedgerId was null or undefined when calling getPricingAddOnOptionInventoryLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingAddOnOptionInventoryLedgerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingAddOnOptionInventoryLedgerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Redeems the inventory ledger to selected option
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param option Option ID
     * @param inventoryLedgerId Inventory Ledger ID
     * @param {*} [options] Override http request options.
     */
    public redeemPricingAddOnOptionInventoryLedger (campaign: string, timeslot: string, pricing: string, addon: string, option: string, inventoryLedgerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons/{addon}/options/{option}/inventoryLedger/{inventoryLedgerId}/redeem'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)))
            .replace('{' + 'option' + '}', encodeURIComponent(String(option)))
            .replace('{' + 'inventoryLedgerId' + '}', encodeURIComponent(String(inventoryLedgerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling redeemPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling redeemPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling redeemPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling redeemPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling redeemPricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'inventoryLedgerId' is not null or undefined
        if (inventoryLedgerId === null || inventoryLedgerId === undefined) {
            throw new Error('Required parameter inventoryLedgerId was null or undefined when calling redeemPricingAddOnOptionInventoryLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates an inventory ledger to selected option
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param addon Add On ID
     * @param option Option ID
     * @param inventoryLedgerId Inventory Ledger ID
     * @param quantity Quantity
     * @param expiresAt Expires Date/Time of inventory ledger with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param {*} [options] Override http request options.
     */
    public updatePricingAddOnOptionInventoryLedger (campaign: string, timeslot: string, pricing: string, addon: string, option: string, inventoryLedgerId: string, quantity: number, expiresAt?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/addons/{addon}/options/{option}/inventoryLedger/{inventoryLedgerId}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'addon' + '}', encodeURIComponent(String(addon)))
            .replace('{' + 'option' + '}', encodeURIComponent(String(option)))
            .replace('{' + 'inventoryLedgerId' + '}', encodeURIComponent(String(inventoryLedgerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updatePricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling updatePricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling updatePricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'addon' is not null or undefined
        if (addon === null || addon === undefined) {
            throw new Error('Required parameter addon was null or undefined when calling updatePricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling updatePricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'inventoryLedgerId' is not null or undefined
        if (inventoryLedgerId === null || inventoryLedgerId === undefined) {
            throw new Error('Required parameter inventoryLedgerId was null or undefined when calling updatePricingAddOnOptionInventoryLedger.');
        }

        // verify required parameter 'quantity' is not null or undefined
        if (quantity === null || quantity === undefined) {
            throw new Error('Required parameter quantity was null or undefined when calling updatePricingAddOnOptionInventoryLedger.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expiresAt'] = ObjectSerializer.serialize(expiresAt, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PricingCardIssuerApiApiKeys {
    JWT,
}

export class PricingCardIssuerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PricingCardIssuerApiApiKeys, value: string) {
        (this.authentications as any)[PricingCardIssuerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a card issuer to the selected pricing for this timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param cardIssuer Card Issuer ID
     * @param percent Is Percent Bonus
     * @param creditedToHapz Is Credited to Hapz
     * @param totalInventory Total Inventory
     * @param value Value in cents or as a percentage value
     * @param currency Currency Code (ISO 4217) Eg. USD
     * @param validFrom Valid From Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param validTo Valid To Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param inventoryAvailableFrom Valid From Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param inventoryAvailableTo Valid To Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param minimumQuantity Minimum Quantity
     * @param quantityIncrement Quantity Increment
     * @param maximumQuantity Maximum Quantity
     * @param {*} [options] Override http request options.
     */
    public addPricingCardIssuer (campaign: string, timeslot: string, pricing: string, cardIssuer: string, percent: boolean, creditedToHapz: boolean, totalInventory: number, value?: number, currency?: string, validFrom?: Date, validTo?: Date, inventoryAvailableFrom?: Date, inventoryAvailableTo?: Date, minimumQuantity?: number, quantityIncrement?: number, maximumQuantity?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingCardIssuerDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/issuers'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addPricingCardIssuer.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling addPricingCardIssuer.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling addPricingCardIssuer.');
        }

        // verify required parameter 'cardIssuer' is not null or undefined
        if (cardIssuer === null || cardIssuer === undefined) {
            throw new Error('Required parameter cardIssuer was null or undefined when calling addPricingCardIssuer.');
        }

        // verify required parameter 'percent' is not null or undefined
        if (percent === null || percent === undefined) {
            throw new Error('Required parameter percent was null or undefined when calling addPricingCardIssuer.');
        }

        // verify required parameter 'creditedToHapz' is not null or undefined
        if (creditedToHapz === null || creditedToHapz === undefined) {
            throw new Error('Required parameter creditedToHapz was null or undefined when calling addPricingCardIssuer.');
        }

        // verify required parameter 'totalInventory' is not null or undefined
        if (totalInventory === null || totalInventory === undefined) {
            throw new Error('Required parameter totalInventory was null or undefined when calling addPricingCardIssuer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (cardIssuer !== undefined) {
            localVarFormParams['cardIssuer'] = ObjectSerializer.serialize(cardIssuer, "string");
        }

        if (value !== undefined) {
            localVarFormParams['value'] = ObjectSerializer.serialize(value, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (percent !== undefined) {
            localVarFormParams['percent'] = ObjectSerializer.serialize(percent, "boolean");
        }

        if (creditedToHapz !== undefined) {
            localVarFormParams['creditedToHapz'] = ObjectSerializer.serialize(creditedToHapz, "boolean");
        }

        if (totalInventory !== undefined) {
            localVarFormParams['totalInventory'] = ObjectSerializer.serialize(totalInventory, "number");
        }

        if (validFrom !== undefined) {
            localVarFormParams['validFrom'] = ObjectSerializer.serialize(validFrom, "Date");
        }

        if (validTo !== undefined) {
            localVarFormParams['validTo'] = ObjectSerializer.serialize(validTo, "Date");
        }

        if (inventoryAvailableFrom !== undefined) {
            localVarFormParams['inventoryAvailableFrom'] = ObjectSerializer.serialize(inventoryAvailableFrom, "Date");
        }

        if (inventoryAvailableTo !== undefined) {
            localVarFormParams['inventoryAvailableTo'] = ObjectSerializer.serialize(inventoryAvailableTo, "Date");
        }

        if (minimumQuantity !== undefined) {
            localVarFormParams['minimumQuantity'] = ObjectSerializer.serialize(minimumQuantity, "number");
        }

        if (quantityIncrement !== undefined) {
            localVarFormParams['quantityIncrement'] = ObjectSerializer.serialize(quantityIncrement, "number");
        }

        if (maximumQuantity !== undefined) {
            localVarFormParams['maximumQuantity'] = ObjectSerializer.serialize(maximumQuantity, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingCardIssuerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingCardIssuerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the eligible card issuer for a given pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Campaign Timeslot ID
     * @param pricing Pricing ID
     * @param cardIssuer Card Issuer ID
     * @param {*} [options] Override http request options.
     */
    public deletePricingEligibleCardIssuer (campaign: string, timeslot: string, pricing: string, cardIssuer: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/issuers/{cardIssuer}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'cardIssuer' + '}', encodeURIComponent(String(cardIssuer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deletePricingEligibleCardIssuer.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling deletePricingEligibleCardIssuer.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling deletePricingEligibleCardIssuer.');
        }

        // verify required parameter 'cardIssuer' is not null or undefined
        if (cardIssuer === null || cardIssuer === undefined) {
            throw new Error('Required parameter cardIssuer was null or undefined when calling deletePricingEligibleCardIssuer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve all card issuers for a given pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param {*} [options] Override http request options.
     */
    public getPricingCardIssuers (campaign: string, timeslot: string, pricing: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PricingCardIssuerDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/issuers'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingCardIssuers.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getPricingCardIssuers.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getPricingCardIssuers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PricingCardIssuerDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PricingCardIssuerDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the eligible card issuer for a given pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Campaign Timeslot ID
     * @param pricing Pricing ID
     * @param cardIssuer Card Issuer ID
     * @param {*} [options] Override http request options.
     */
    public getPricingEligibleCardIssuer (campaign: string, timeslot: string, pricing: string, cardIssuer: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingCardIssuer;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/issuers/{cardIssuer}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'cardIssuer' + '}', encodeURIComponent(String(cardIssuer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingEligibleCardIssuer.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getPricingEligibleCardIssuer.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getPricingEligibleCardIssuer.');
        }

        // verify required parameter 'cardIssuer' is not null or undefined
        if (cardIssuer === null || cardIssuer === undefined) {
            throw new Error('Required parameter cardIssuer was null or undefined when calling getPricingEligibleCardIssuer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingCardIssuer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingCardIssuer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the eligible card issuer for a given pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Campaign Timeslot ID
     * @param pricing Pricing ID
     * @param cardIssuer Card Issuer ID
     * @param percent Is Percent Bonus
     * @param creditedToHapz Is Credited to Hapz
     * @param totalInventory Total Inventory
     * @param value Value in cents or as a percentage value
     * @param currency Currency Code (ISO 4217) Eg. USD
     * @param validFrom Valid From Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param validTo Valid To Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param inventoryAvailableFrom Valid From Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param inventoryAvailableTo Valid To Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param minimumQuantity Minimum Quantity
     * @param quantityIncrement Quantity Increment
     * @param maximumQuantity Maximum Quantity
     * @param {*} [options] Override http request options.
     */
    public updatePricingEligibleCardIssuer (campaign: string, timeslot: string, pricing: string, cardIssuer: string, percent: boolean, creditedToHapz: boolean, totalInventory: number, value?: number, currency?: string, validFrom?: Date, validTo?: Date, inventoryAvailableFrom?: Date, inventoryAvailableTo?: Date, minimumQuantity?: number, quantityIncrement?: number, maximumQuantity?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/issuers/{cardIssuer}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'cardIssuer' + '}', encodeURIComponent(String(cardIssuer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updatePricingEligibleCardIssuer.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling updatePricingEligibleCardIssuer.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling updatePricingEligibleCardIssuer.');
        }

        // verify required parameter 'cardIssuer' is not null or undefined
        if (cardIssuer === null || cardIssuer === undefined) {
            throw new Error('Required parameter cardIssuer was null or undefined when calling updatePricingEligibleCardIssuer.');
        }

        // verify required parameter 'percent' is not null or undefined
        if (percent === null || percent === undefined) {
            throw new Error('Required parameter percent was null or undefined when calling updatePricingEligibleCardIssuer.');
        }

        // verify required parameter 'creditedToHapz' is not null or undefined
        if (creditedToHapz === null || creditedToHapz === undefined) {
            throw new Error('Required parameter creditedToHapz was null or undefined when calling updatePricingEligibleCardIssuer.');
        }

        // verify required parameter 'totalInventory' is not null or undefined
        if (totalInventory === null || totalInventory === undefined) {
            throw new Error('Required parameter totalInventory was null or undefined when calling updatePricingEligibleCardIssuer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (value !== undefined) {
            localVarFormParams['value'] = ObjectSerializer.serialize(value, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (percent !== undefined) {
            localVarFormParams['percent'] = ObjectSerializer.serialize(percent, "boolean");
        }

        if (creditedToHapz !== undefined) {
            localVarFormParams['creditedToHapz'] = ObjectSerializer.serialize(creditedToHapz, "boolean");
        }

        if (totalInventory !== undefined) {
            localVarFormParams['totalInventory'] = ObjectSerializer.serialize(totalInventory, "number");
        }

        if (validFrom !== undefined) {
            localVarFormParams['validFrom'] = ObjectSerializer.serialize(validFrom, "Date");
        }

        if (validTo !== undefined) {
            localVarFormParams['validTo'] = ObjectSerializer.serialize(validTo, "Date");
        }

        if (inventoryAvailableFrom !== undefined) {
            localVarFormParams['inventoryAvailableFrom'] = ObjectSerializer.serialize(inventoryAvailableFrom, "Date");
        }

        if (inventoryAvailableTo !== undefined) {
            localVarFormParams['inventoryAvailableTo'] = ObjectSerializer.serialize(inventoryAvailableTo, "Date");
        }

        if (minimumQuantity !== undefined) {
            localVarFormParams['minimumQuantity'] = ObjectSerializer.serialize(minimumQuantity, "number");
        }

        if (quantityIncrement !== undefined) {
            localVarFormParams['quantityIncrement'] = ObjectSerializer.serialize(quantityIncrement, "number");
        }

        if (maximumQuantity !== undefined) {
            localVarFormParams['maximumQuantity'] = ObjectSerializer.serialize(maximumQuantity, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PricingCategoriesApiApiKeys {
    JWT,
}

export class PricingCategoriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PricingCategoriesApiApiKeys, value: string) {
        (this.authentications as any)[PricingCategoriesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new pricing category
     * @param campaign Campaign ID
     * @param name Pricing Category Name
     * @param sortKey Sort Key
     * @param description Pricing Category Description
     * @param {*} [options] Override http request options.
     */
    public addPricingCategory (campaign: string, name: string, sortKey: number, description?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingCategoryDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/pricingCategories'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addPricingCategory.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addPricingCategory.');
        }

        // verify required parameter 'sortKey' is not null or undefined
        if (sortKey === null || sortKey === undefined) {
            throw new Error('Required parameter sortKey was null or undefined when calling addPricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (sortKey !== undefined) {
            localVarFormParams['sortKey'] = ObjectSerializer.serialize(sortKey, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a pricing category
     * @param campaign Campaign ID
     * @param pricingCategory Pricing Category ID
     * @param {*} [options] Override http request options.
     */
    public deletePricingCategory (campaign: string, pricingCategory: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/pricingCategories/{pricingCategory}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'pricingCategory' + '}', encodeURIComponent(String(pricingCategory)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deletePricingCategory.');
        }

        // verify required parameter 'pricingCategory' is not null or undefined
        if (pricingCategory === null || pricingCategory === undefined) {
            throw new Error('Required parameter pricingCategory was null or undefined when calling deletePricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all pricing categories from a given event
     * @param campaign Campaign ID
     * @param {*} [options] Override http request options.
     */
    public getPricingCategories (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PricingCategoryDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/pricingCategories'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingCategories.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PricingCategoryDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PricingCategoryDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of a pricing category
     * @param campaign Campaign ID
     * @param pricingCategory Pricing Category ID
     * @param {*} [options] Override http request options.
     */
    public getPricingCategory (campaign: string, pricingCategory: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingCategoryDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/pricingCategories/{pricingCategory}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'pricingCategory' + '}', encodeURIComponent(String(pricingCategory)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingCategory.');
        }

        // verify required parameter 'pricingCategory' is not null or undefined
        if (pricingCategory === null || pricingCategory === undefined) {
            throw new Error('Required parameter pricingCategory was null or undefined when calling getPricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the details of a pricing category
     * @param campaign Campaign ID
     * @param pricingCategory Pricing Category ID
     * @param name Pricing Category Name
     * @param sortKey Sort Key
     * @param defaultPricing Default Pricing
     * @param description Pricing Category Description
     * @param {*} [options] Override http request options.
     */
    public updatePricingCategory (campaign: string, pricingCategory: string, name: string, sortKey: number, defaultPricing: boolean, description?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/pricingCategories/{pricingCategory}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'pricingCategory' + '}', encodeURIComponent(String(pricingCategory)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updatePricingCategory.');
        }

        // verify required parameter 'pricingCategory' is not null or undefined
        if (pricingCategory === null || pricingCategory === undefined) {
            throw new Error('Required parameter pricingCategory was null or undefined when calling updatePricingCategory.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updatePricingCategory.');
        }

        // verify required parameter 'sortKey' is not null or undefined
        if (sortKey === null || sortKey === undefined) {
            throw new Error('Required parameter sortKey was null or undefined when calling updatePricingCategory.');
        }

        // verify required parameter 'defaultPricing' is not null or undefined
        if (defaultPricing === null || defaultPricing === undefined) {
            throw new Error('Required parameter defaultPricing was null or undefined when calling updatePricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (sortKey !== undefined) {
            localVarFormParams['sortKey'] = ObjectSerializer.serialize(sortKey, "number");
        }

        if (defaultPricing !== undefined) {
            localVarFormParams['defaultPricing'] = ObjectSerializer.serialize(defaultPricing, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PricingImageApiApiKeys {
    JWT,
}

export class PricingImageApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PricingImageApiApiKeys, value: string) {
        (this.authentications as any)[PricingImageApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves an image from a pricing
     * @param campaign Campaign ID
     * @param image Image ID
     * @param {*} [options] Override http request options.
     */
    public getImage (campaign: string, image: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/{campaign}/images/{image}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'image' + '}', encodeURIComponent(String(image)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getImage.');
        }

        // verify required parameter 'image' is not null or undefined
        if (image === null || image === undefined) {
            throw new Error('Required parameter image was null or undefined when calling getImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves an image from a pricing
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param image Image ID
     * @param {*} [options] Override http request options.
     */
    public getImage1 (campaign: string, timeslot: string, pricing: string, image: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/images/{image}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'image' + '}', encodeURIComponent(String(image)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getImage1.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getImage1.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getImage1.');
        }

        // verify required parameter 'image' is not null or undefined
        if (image === null || image === undefined) {
            throw new Error('Required parameter image was null or undefined when calling getImage1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all images from a campaign
     * @param campaign Campaign ID
     * @param {*} [options] Override http request options.
     */
    public getImages (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/{campaign}/images'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getImages.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all images from a campaign
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param {*} [options] Override http request options.
     */
    public getImages1 (campaign: string, timeslot: string, pricing: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/images'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getImages1.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getImages1.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getImages1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PricingIntervalApiApiKeys {
    JWT,
}

export class PricingIntervalApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PricingIntervalApiApiKeys, value: string) {
        (this.authentications as any)[PricingIntervalApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new pricing interval for a given pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param currency Currency Code (ISO 4217) Eg. USD
     * @param price Price (in cents)
     * @param costPrice Cost Price (in cents)
     * @param maximumPrice Maximum Price (in cents)
     * @param validFrom Valid From Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param validTo Valid To Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param minimumQuantity Minimum Quantity
     * @param quantityIncrement Quantity Increment
     * @param maximumQuantity Maximum Quantity
     * @param bookingFee Booking Fee
     * @param bookingFeeInPercent Indicates whether Booking Fee is in percentage format
     * @param addToMultipleTimeslots Indicate if this pricing interval should be added to multiple timeslots
     * @param addToMultipleTimeslotsFrom Add the pricing interval to all timeslots from this Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param addToMultipleTimeslotsTo Add the pricing interval to all timeslots till this Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param {*} [options] Override http request options.
     */
    public addPricingInterval (campaign: string, timeslot: string, pricing: string, currency: string, price: number, costPrice: number, maximumPrice: number, validFrom?: Date, validTo?: Date, minimumQuantity?: number, quantityIncrement?: number, maximumQuantity?: number, bookingFee?: number, bookingFeeInPercent?: boolean, addToMultipleTimeslots?: boolean, addToMultipleTimeslotsFrom?: Date, addToMultipleTimeslotsTo?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PricingIntervalDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/intervals'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addPricingInterval.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling addPricingInterval.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling addPricingInterval.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling addPricingInterval.');
        }

        // verify required parameter 'price' is not null or undefined
        if (price === null || price === undefined) {
            throw new Error('Required parameter price was null or undefined when calling addPricingInterval.');
        }

        // verify required parameter 'costPrice' is not null or undefined
        if (costPrice === null || costPrice === undefined) {
            throw new Error('Required parameter costPrice was null or undefined when calling addPricingInterval.');
        }

        // verify required parameter 'maximumPrice' is not null or undefined
        if (maximumPrice === null || maximumPrice === undefined) {
            throw new Error('Required parameter maximumPrice was null or undefined when calling addPricingInterval.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (validFrom !== undefined) {
            localVarFormParams['validFrom'] = ObjectSerializer.serialize(validFrom, "Date");
        }

        if (validTo !== undefined) {
            localVarFormParams['validTo'] = ObjectSerializer.serialize(validTo, "Date");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (minimumQuantity !== undefined) {
            localVarFormParams['minimumQuantity'] = ObjectSerializer.serialize(minimumQuantity, "number");
        }

        if (quantityIncrement !== undefined) {
            localVarFormParams['quantityIncrement'] = ObjectSerializer.serialize(quantityIncrement, "number");
        }

        if (maximumQuantity !== undefined) {
            localVarFormParams['maximumQuantity'] = ObjectSerializer.serialize(maximumQuantity, "number");
        }

        if (price !== undefined) {
            localVarFormParams['price'] = ObjectSerializer.serialize(price, "number");
        }

        if (costPrice !== undefined) {
            localVarFormParams['costPrice'] = ObjectSerializer.serialize(costPrice, "number");
        }

        if (maximumPrice !== undefined) {
            localVarFormParams['maximumPrice'] = ObjectSerializer.serialize(maximumPrice, "number");
        }

        if (bookingFee !== undefined) {
            localVarFormParams['bookingFee'] = ObjectSerializer.serialize(bookingFee, "number");
        }

        if (bookingFeeInPercent !== undefined) {
            localVarFormParams['bookingFeeInPercent'] = ObjectSerializer.serialize(bookingFeeInPercent, "boolean");
        }

        if (addToMultipleTimeslots !== undefined) {
            localVarFormParams['addToMultipleTimeslots'] = ObjectSerializer.serialize(addToMultipleTimeslots, "boolean");
        }

        if (addToMultipleTimeslotsFrom !== undefined) {
            localVarFormParams['addToMultipleTimeslotsFrom'] = ObjectSerializer.serialize(addToMultipleTimeslotsFrom, "Date");
        }

        if (addToMultipleTimeslotsTo !== undefined) {
            localVarFormParams['addToMultipleTimeslotsTo'] = ObjectSerializer.serialize(addToMultipleTimeslotsTo, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PricingIntervalDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PricingIntervalDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a pricing interval for this timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param interval Pricing Interval ID
     * @param {*} [options] Override http request options.
     */
    public deletePricingInterval (campaign: string, timeslot: string, pricing: string, interval: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/intervals/{interval}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'interval' + '}', encodeURIComponent(String(interval)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deletePricingInterval.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling deletePricingInterval.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling deletePricingInterval.');
        }

        // verify required parameter 'interval' is not null or undefined
        if (interval === null || interval === undefined) {
            throw new Error('Required parameter interval was null or undefined when calling deletePricingInterval.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of the selected pricing for this timeslot
     * @param campaign Campaign ID
     * @param timeslot Campaign Timeslot ID
     * @param pricing Pricing ID
     * @param interval Pricing Interval ID
     * @param {*} [options] Override http request options.
     */
    public getPricingInterval (campaign: string, timeslot: string, pricing: string, interval: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingIntervalDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/intervals/{interval}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'interval' + '}', encodeURIComponent(String(interval)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingInterval.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getPricingInterval.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getPricingInterval.');
        }

        // verify required parameter 'interval' is not null or undefined
        if (interval === null || interval === undefined) {
            throw new Error('Required parameter interval was null or undefined when calling getPricingInterval.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingIntervalDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingIntervalDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve all pricing intervals for a given pricing for a given timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param {*} [options] Override http request options.
     */
    public getPricingIntervals (campaign: string, timeslot: string, pricing: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PricingIntervalDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/intervals'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingIntervals.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling getPricingIntervals.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling getPricingIntervals.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PricingIntervalDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PricingIntervalDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a pricing interval for this timeslot
     * @param campaign Campaign ID
     * @param timeslot Timeslot ID
     * @param pricing Pricing ID
     * @param interval Pricing Interval ID
     * @param currency Currency Code (ISO 4217) Eg. USD
     * @param price Price (in cents)
     * @param costPrice Cost Price (in cents)
     * @param maximumPrice Maximum Price (in cents)
     * @param validFrom Valid From Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param validTo Valid To Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param minimumQuantity Minimum Quantity
     * @param quantityIncrement Quantity Increment
     * @param maximumQuantity Maximum Quantity
     * @param bookingFee Booking Fee
     * @param bookingFeeInPercent Indicates whether Booking Fee is in percentage format
     * @param addToMultipleTimeslots Indicate if this pricing interval should be added to multiple timeslots
     * @param addToMultipleTimeslotsFrom Add the pricing interval to all timeslots from this Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param addToMultipleTimeslotsTo Add the pricing interval to all timeslots till this Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param {*} [options] Override http request options.
     */
    public updatePricingInterval (campaign: string, timeslot: string, pricing: string, interval: string, currency: string, price: number, costPrice: number, maximumPrice: number, validFrom?: Date, validTo?: Date, minimumQuantity?: number, quantityIncrement?: number, maximumQuantity?: number, bookingFee?: number, bookingFeeInPercent?: boolean, addToMultipleTimeslots?: boolean, addToMultipleTimeslotsFrom?: Date, addToMultipleTimeslotsTo?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PricingIntervalDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/{timeslot}/pricings/{pricing}/intervals/{interval}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'timeslot' + '}', encodeURIComponent(String(timeslot)))
            .replace('{' + 'pricing' + '}', encodeURIComponent(String(pricing)))
            .replace('{' + 'interval' + '}', encodeURIComponent(String(interval)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updatePricingInterval.');
        }

        // verify required parameter 'timeslot' is not null or undefined
        if (timeslot === null || timeslot === undefined) {
            throw new Error('Required parameter timeslot was null or undefined when calling updatePricingInterval.');
        }

        // verify required parameter 'pricing' is not null or undefined
        if (pricing === null || pricing === undefined) {
            throw new Error('Required parameter pricing was null or undefined when calling updatePricingInterval.');
        }

        // verify required parameter 'interval' is not null or undefined
        if (interval === null || interval === undefined) {
            throw new Error('Required parameter interval was null or undefined when calling updatePricingInterval.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling updatePricingInterval.');
        }

        // verify required parameter 'price' is not null or undefined
        if (price === null || price === undefined) {
            throw new Error('Required parameter price was null or undefined when calling updatePricingInterval.');
        }

        // verify required parameter 'costPrice' is not null or undefined
        if (costPrice === null || costPrice === undefined) {
            throw new Error('Required parameter costPrice was null or undefined when calling updatePricingInterval.');
        }

        // verify required parameter 'maximumPrice' is not null or undefined
        if (maximumPrice === null || maximumPrice === undefined) {
            throw new Error('Required parameter maximumPrice was null or undefined when calling updatePricingInterval.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (validFrom !== undefined) {
            localVarFormParams['validFrom'] = ObjectSerializer.serialize(validFrom, "Date");
        }

        if (validTo !== undefined) {
            localVarFormParams['validTo'] = ObjectSerializer.serialize(validTo, "Date");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (minimumQuantity !== undefined) {
            localVarFormParams['minimumQuantity'] = ObjectSerializer.serialize(minimumQuantity, "number");
        }

        if (quantityIncrement !== undefined) {
            localVarFormParams['quantityIncrement'] = ObjectSerializer.serialize(quantityIncrement, "number");
        }

        if (maximumQuantity !== undefined) {
            localVarFormParams['maximumQuantity'] = ObjectSerializer.serialize(maximumQuantity, "number");
        }

        if (price !== undefined) {
            localVarFormParams['price'] = ObjectSerializer.serialize(price, "number");
        }

        if (costPrice !== undefined) {
            localVarFormParams['costPrice'] = ObjectSerializer.serialize(costPrice, "number");
        }

        if (maximumPrice !== undefined) {
            localVarFormParams['maximumPrice'] = ObjectSerializer.serialize(maximumPrice, "number");
        }

        if (bookingFee !== undefined) {
            localVarFormParams['bookingFee'] = ObjectSerializer.serialize(bookingFee, "number");
        }

        if (bookingFeeInPercent !== undefined) {
            localVarFormParams['bookingFeeInPercent'] = ObjectSerializer.serialize(bookingFeeInPercent, "boolean");
        }

        if (addToMultipleTimeslots !== undefined) {
            localVarFormParams['addToMultipleTimeslots'] = ObjectSerializer.serialize(addToMultipleTimeslots, "boolean");
        }

        if (addToMultipleTimeslotsFrom !== undefined) {
            localVarFormParams['addToMultipleTimeslotsFrom'] = ObjectSerializer.serialize(addToMultipleTimeslotsFrom, "Date");
        }

        if (addToMultipleTimeslotsTo !== undefined) {
            localVarFormParams['addToMultipleTimeslotsTo'] = ObjectSerializer.serialize(addToMultipleTimeslotsTo, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PricingIntervalDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PricingIntervalDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PricingPackagesApiApiKeys {
    JWT,
}

export class PricingPackagesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PricingPackagesApiApiKeys, value: string) {
        (this.authentications as any)[PricingPackagesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new event pricing package
     * @param campaign Campaign ID
     * @param name Pricing Package Name
     * @param startDateTime Campaign Start Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param endDateTime Campaign End Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param sortKey Sort Key
     * @param {*} [options] Override http request options.
     */
    public addPricingPackage (campaign: string, name: string, startDateTime?: Date, endDateTime?: Date, sortKey?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingPackageDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/packages'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addPricingPackage.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addPricingPackage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (startDateTime !== undefined) {
            localVarFormParams['startDateTime'] = ObjectSerializer.serialize(startDateTime, "Date");
        }

        if (endDateTime !== undefined) {
            localVarFormParams['endDateTime'] = ObjectSerializer.serialize(endDateTime, "Date");
        }

        if (sortKey !== undefined) {
            localVarFormParams['sortKey'] = ObjectSerializer.serialize(sortKey, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingPackageDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingPackageDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an event pricing package
     * @param campaign Campaign ID
     * @param _package Package ID
     * @param {*} [options] Override http request options.
     */
    public deletePricingPackage (campaign: string, _package: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/packages/{package}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'package' + '}', encodeURIComponent(String(_package)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deletePricingPackage.');
        }

        // verify required parameter '_package' is not null or undefined
        if (_package === null || _package === undefined) {
            throw new Error('Required parameter _package was null or undefined when calling deletePricingPackage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves an event pricing package
     * @param campaign Campaign ID
     * @param _package Pricing Package ID
     * @param {*} [options] Override http request options.
     */
    public getPricingPackage (campaign: string, _package: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingPackageDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/packages/{package}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'package' + '}', encodeURIComponent(String(_package)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingPackage.');
        }

        // verify required parameter '_package' is not null or undefined
        if (_package === null || _package === undefined) {
            throw new Error('Required parameter _package was null or undefined when calling getPricingPackage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingPackageDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingPackageDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all pricing packages from the given event
     * @param campaign Campaign ID
     * @param {*} [options] Override http request options.
     */
    public getPricingPackages (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PricingPackageDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/packages'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricingPackages.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PricingPackageDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PricingPackageDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates an event pricing package
     * @param campaign Campaign ID
     * @param _package Pricing Package ID
     * @param name Pricing Package Name
     * @param defaultPricing Use this pricing package for default pricing
     * @param startDateTime Campaign Start Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param endDateTime Campaign End Date/Time with ISO 8601 timezone (yyyy-MM-dd HH:mm:ssX) Eg: 2016-01-01 12:00:00+0800
     * @param sortKey Sort Key
     * @param {*} [options] Override http request options.
     */
    public updatePricingPackage (campaign: string, _package: string, name: string, defaultPricing: boolean, startDateTime?: Date, endDateTime?: Date, sortKey?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/packages/{package}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'package' + '}', encodeURIComponent(String(_package)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updatePricingPackage.');
        }

        // verify required parameter '_package' is not null or undefined
        if (_package === null || _package === undefined) {
            throw new Error('Required parameter _package was null or undefined when calling updatePricingPackage.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updatePricingPackage.');
        }

        // verify required parameter 'defaultPricing' is not null or undefined
        if (defaultPricing === null || defaultPricing === undefined) {
            throw new Error('Required parameter defaultPricing was null or undefined when calling updatePricingPackage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (startDateTime !== undefined) {
            localVarFormParams['startDateTime'] = ObjectSerializer.serialize(startDateTime, "Date");
        }

        if (endDateTime !== undefined) {
            localVarFormParams['endDateTime'] = ObjectSerializer.serialize(endDateTime, "Date");
        }

        if (sortKey !== undefined) {
            localVarFormParams['sortKey'] = ObjectSerializer.serialize(sortKey, "number");
        }

        if (defaultPricing !== undefined) {
            localVarFormParams['defaultPricing'] = ObjectSerializer.serialize(defaultPricing, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RegistrationInfoApiApiKeys {
    JWT,
}

export class RegistrationInfoApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RegistrationInfoApiApiKeys, value: string) {
        (this.authentications as any)[RegistrationInfoApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds new required registration information to this campaign
     * @param campaign Campaign ID
     * @param legalAttachment Legal Attachment only for type &#x3D; LEGAL
     * @param image Image
     * @param {*} [options] Override http request options.
     */
    public addRegistrationField (campaign: string, legalAttachment?: Buffer, image?: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RegistrationFieldDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/registrationFields'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addRegistrationField.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (legalAttachment !== undefined) {
            localVarFormParams['legalAttachment'] = legalAttachment;
        }
        localVarUseFormData = true;

        if (image !== undefined) {
            localVarFormParams['image'] = image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RegistrationFieldDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RegistrationFieldDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add registration field applicable category from a given event and registration field
     * @param campaign Campaign ID
     * @param registrationField Registration Field ID
     * @param pricingCategory Pricing CategoryId
     * @param {*} [options] Override http request options.
     */
    public addRegistrationFieldPricingCategory (campaign: string, registrationField: string, pricingCategory: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PricingCategoryDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/registrationFields/{registrationField}/pricingCategories'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'registrationField' + '}', encodeURIComponent(String(registrationField)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addRegistrationFieldPricingCategory.');
        }

        // verify required parameter 'registrationField' is not null or undefined
        if (registrationField === null || registrationField === undefined) {
            throw new Error('Required parameter registrationField was null or undefined when calling addRegistrationFieldPricingCategory.');
        }

        // verify required parameter 'pricingCategory' is not null or undefined
        if (pricingCategory === null || pricingCategory === undefined) {
            throw new Error('Required parameter pricingCategory was null or undefined when calling addRegistrationFieldPricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (pricingCategory !== undefined) {
            localVarFormParams['pricingCategory'] = ObjectSerializer.serialize(pricingCategory, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PricingCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a required registration information from a campaign
     * @param campaign Campaign ID
     * @param registrationField Registration Field ID
     * @param {*} [options] Override http request options.
     */
    public deleteRegistrationField (campaign: string, registrationField: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/registrationFields/{registrationField}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'registrationField' + '}', encodeURIComponent(String(registrationField)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteRegistrationField.');
        }

        // verify required parameter 'registrationField' is not null or undefined
        if (registrationField === null || registrationField === undefined) {
            throw new Error('Required parameter registrationField was null or undefined when calling deleteRegistrationField.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add registration field applicable category
     * @param campaign Campaign ID
     * @param registrationField Registration Field ID
     * @param pricingCategory Pricing CategoryId
     * @param {*} [options] Override http request options.
     */
    public deleteRegistrationFieldPricingCategory (campaign: string, registrationField: string, pricingCategory: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/registrationFields/{registrationField}/pricingCategories/{pricingCategory}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'registrationField' + '}', encodeURIComponent(String(registrationField)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteRegistrationFieldPricingCategory.');
        }

        // verify required parameter 'registrationField' is not null or undefined
        if (registrationField === null || registrationField === undefined) {
            throw new Error('Required parameter registrationField was null or undefined when calling deleteRegistrationFieldPricingCategory.');
        }

        // verify required parameter 'pricingCategory' is not null or undefined
        if (pricingCategory === null || pricingCategory === undefined) {
            throw new Error('Required parameter pricingCategory was null or undefined when calling deleteRegistrationFieldPricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (pricingCategory !== undefined) {
            localVarFormParams['pricingCategory'] = ObjectSerializer.serialize(pricingCategory, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves detail of registration information from a given event
     * @param campaign Campaign ID
     * @param registrationField Registration Field ID
     * @param {*} [options] Override http request options.
     */
    public getRegistrationField (campaign: string, registrationField: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RegistrationFieldDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/registrationFields/{registrationField}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'registrationField' + '}', encodeURIComponent(String(registrationField)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getRegistrationField.');
        }

        // verify required parameter 'registrationField' is not null or undefined
        if (registrationField === null || registrationField === undefined) {
            throw new Error('Required parameter registrationField was null or undefined when calling getRegistrationField.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RegistrationFieldDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RegistrationFieldDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all registration field applicable categories from a given event and registration field
     * @param campaign Campaign ID
     * @param registrationField Registration Field ID
     * @param {*} [options] Override http request options.
     */
    public getRegistrationFieldPricingCategory (campaign: string, registrationField: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PricingCategoryDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/registrationFields/{registrationField}/pricingCategories'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'registrationField' + '}', encodeURIComponent(String(registrationField)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getRegistrationFieldPricingCategory.');
        }

        // verify required parameter 'registrationField' is not null or undefined
        if (registrationField === null || registrationField === undefined) {
            throw new Error('Required parameter registrationField was null or undefined when calling getRegistrationFieldPricingCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PricingCategoryDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PricingCategoryDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all registration information from a given event
     * @param campaigns Campaign IDs (comma-seperated values)
     * @param {*} [options] Override http request options.
     */
    public getRegistrationFields (campaigns?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: { [key: string]: Array<RegistrationFieldDto>; };  }> {
        const localVarPath = this.basePath + '/registrationFields';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (campaigns !== undefined) {
            localVarQueryParameters['campaigns'] = ObjectSerializer.serialize(campaigns, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: { [key: string]: Array<RegistrationFieldDto>; };  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "{ [key: string]: Array<RegistrationFieldDto>; }");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all registration information from a given event
     * @param campaign Campaign ID
     * @param {*} [options] Override http request options.
     */
    public getRegistrationFields1 (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<RegistrationFieldDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/registrationFields'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getRegistrationFields1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<RegistrationFieldDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<RegistrationFieldDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update the sort key for a given registration field in this campaign
     * @param campaign Campaign ID
     * @param registrationField Registration Field ID
     * @param sortKey Sort Key
     * @param {*} [options] Override http request options.
     */
    public updateRegistrationField (campaign: string, registrationField: string, sortKey?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/registrationFields/{registrationField}/sortKey'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'registrationField' + '}', encodeURIComponent(String(registrationField)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateRegistrationField.');
        }

        // verify required parameter 'registrationField' is not null or undefined
        if (registrationField === null || registrationField === undefined) {
            throw new Error('Required parameter registrationField was null or undefined when calling updateRegistrationField.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (sortKey !== undefined) {
            localVarFormParams['sortKey'] = ObjectSerializer.serialize(sortKey, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update new required registration information to this campaign
     * @param campaign Campaign ID
     * @param registrationField Registration Field ID
     * @param legalAttachment Legal Attachment only for type &#x3D; LEGAL
     * @param image Image
     * @param {*} [options] Override http request options.
     */
    public updateRegistrationField1 (campaign: string, registrationField: string, legalAttachment?: Buffer, image?: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/registrationFields/{registrationField}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'registrationField' + '}', encodeURIComponent(String(registrationField)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateRegistrationField1.');
        }

        // verify required parameter 'registrationField' is not null or undefined
        if (registrationField === null || registrationField === undefined) {
            throw new Error('Required parameter registrationField was null or undefined when calling updateRegistrationField1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (legalAttachment !== undefined) {
            localVarFormParams['legalAttachment'] = legalAttachment;
        }
        localVarUseFormData = true;

        if (image !== undefined) {
            localVarFormParams['image'] = image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param campaign Campaign ID
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public validation (campaign: string, body?: ValidateRegistration, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/{campaign}/registrationFields/validate'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling validation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ValidateRegistration")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SearchApiApiKeys {
    JWT,
}

export class SearchApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SearchApiApiKeys, value: string) {
        (this.authentications as any)[SearchApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Search all campaigns
     * @param start Start Row
     * @param rows Number of Rows
     * @param searchTerm Search Term
     * @param category Category ID
     * @param subcategory Subcategory ID
     * @param timeslotStartDate Timeslot Start Date (yyyy-MM-dd)
     * @param timeslotEndDate Timeslot End Date (yyyy-MM-dd)
     * @param tag Tag
     * @param merchant Merchant ID (Optional, for Account Managers and Administrators only, used to retrieve all events from a given merchant)
     * @param orderByPrice Order By Price (1 &#x3D; Ascending, 2 &#x3D; Descending)
     * @param orderBySavings Order By Savings (1 &#x3D; Ascending, 2 &#x3D; Descending)
     * @param {*} [options] Override http request options.
     */
    public getEvents (start: number, rows: number, searchTerm?: string, category?: string, subcategory?: string, timeslotStartDate?: Date, timeslotEndDate?: Date, tag?: string, merchant?: string, orderByPrice?: 0 | 1 | 2, orderBySavings?: 0 | 1 | 2, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PageEvent;  }> {
        const localVarPath = this.basePath + '/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getEvents.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getEvents.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(category, "string");
        }

        if (subcategory !== undefined) {
            localVarQueryParameters['subcategory'] = ObjectSerializer.serialize(subcategory, "string");
        }

        if (timeslotStartDate !== undefined) {
            localVarQueryParameters['timeslotStartDate'] = ObjectSerializer.serialize(timeslotStartDate, "Date");
        }

        if (timeslotEndDate !== undefined) {
            localVarQueryParameters['timeslotEndDate'] = ObjectSerializer.serialize(timeslotEndDate, "Date");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        if (merchant !== undefined) {
            localVarQueryParameters['merchant'] = ObjectSerializer.serialize(merchant, "string");
        }

        if (orderByPrice !== undefined) {
            localVarQueryParameters['orderByPrice'] = ObjectSerializer.serialize(orderByPrice, "0 | 1 | 2");
        }

        if (orderBySavings !== undefined) {
            localVarQueryParameters['orderBySavings'] = ObjectSerializer.serialize(orderBySavings, "0 | 1 | 2");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PageEvent;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageEvent");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Migrates solr documents to new the new environment
     * @param {*} [options] Override http request options.
     */
    public migrateCampaignDocuments (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/search/migration';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SubcategoriesApiApiKeys {
    JWT,
}

export class SubcategoriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SubcategoriesApiApiKeys, value: string) {
        (this.authentications as any)[SubcategoriesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Only Administrators are allowed to create campaign subcategories.
     * @summary Adds a new subcategory
     * @param categoryId 
     * @param name Category Name
     * @param {*} [options] Override http request options.
     */
    public addSubcategory (categoryId: string, name: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignSubCategoryDto;  }> {
        const localVarPath = this.basePath + '/categories/{categoryId}/subcategories'
            .replace('{' + 'categoryId' + '}', encodeURIComponent(String(categoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling addSubcategory.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling addSubcategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignSubCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignSubCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only Administrators are allowed to delete campaign subcategories.
     * @summary Deletes a campaign subcategory
     * @param categoryId 
     * @param subcategoryId 
     * @param {*} [options] Override http request options.
     */
    public deleteSubcategory (categoryId: string, subcategoryId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/categories/{categoryId}/subcategories/{subcategoryId}'
            .replace('{' + 'categoryId' + '}', encodeURIComponent(String(categoryId)))
            .replace('{' + 'subcategoryId' + '}', encodeURIComponent(String(subcategoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling deleteSubcategory.');
        }

        // verify required parameter 'subcategoryId' is not null or undefined
        if (subcategoryId === null || subcategoryId === undefined) {
            throw new Error('Required parameter subcategoryId was null or undefined when calling deleteSubcategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all subcategories from a given category
     * @param categoryId 
     * @param {*} [options] Override http request options.
     */
    public getSubcategories (categoryId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Array<CampaignSubCategoryDto>>;  }> {
        const localVarPath = this.basePath + '/categories/{categoryId}/subcategories'
            .replace('{' + 'categoryId' + '}', encodeURIComponent(String(categoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling getSubcategories.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Array<CampaignSubCategoryDto>>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Array<CampaignSubCategoryDto>>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the details of a campaign subcategory
     * @param categoryId 
     * @param subcategoryId 
     * @param {*} [options] Override http request options.
     */
    public getSubcategory (categoryId: string, subcategoryId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CampaignSubCategoryDto;  }> {
        const localVarPath = this.basePath + '/categories/{categoryId}/subcategories/{subcategoryId}'
            .replace('{' + 'categoryId' + '}', encodeURIComponent(String(categoryId)))
            .replace('{' + 'subcategoryId' + '}', encodeURIComponent(String(subcategoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling getSubcategory.');
        }

        // verify required parameter 'subcategoryId' is not null or undefined
        if (subcategoryId === null || subcategoryId === undefined) {
            throw new Error('Required parameter subcategoryId was null or undefined when calling getSubcategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CampaignSubCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignSubCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only Administrators are allowed to update campaign subcategories.
     * @summary Updates the details of a campaign subcategory
     * @param categoryId 
     * @param subcategoryId 
     * @param name Subcategory Name
     * @param {*} [options] Override http request options.
     */
    public updateSubcategory (categoryId: string, subcategoryId: string, name: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/categories/{categoryId}/subcategories/{subcategoryId}'
            .replace('{' + 'categoryId' + '}', encodeURIComponent(String(categoryId)))
            .replace('{' + 'subcategoryId' + '}', encodeURIComponent(String(subcategoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling updateSubcategory.');
        }

        // verify required parameter 'subcategoryId' is not null or undefined
        if (subcategoryId === null || subcategoryId === undefined) {
            throw new Error('Required parameter subcategoryId was null or undefined when calling updateSubcategory.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateSubcategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TagApiApiKeys {
    JWT,
}

export class TagApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TagApiApiKeys, value: string) {
        (this.authentications as any)[TagApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a tag to an event
     * @param campaign Campaign ID
     * @param tag Tag Name
     * @param {*} [options] Override http request options.
     */
    public addTag (campaign: string, tag: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TagDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/tags'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling addTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (tag !== undefined) {
            localVarFormParams['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TagDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TagDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a tag from an event
     * @param campaign Campaign ID
     * @param tag Tag Name
     * @param {*} [options] Override http request options.
     */
    public deleteTag (campaign: string, tag: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/tags/{tag}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'tag' + '}', encodeURIComponent(String(tag)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling deleteTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the given tag from this event
     * @param campaign Campaign ID
     * @param tag Tag Name
     * @param {*} [options] Override http request options.
     */
    public getTag (campaign: string, tag: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TagDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/tags/{tag}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'tag' + '}', encodeURIComponent(String(tag)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling getTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TagDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TagDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all the tags from this event
     * @param campaign Campaign ID
     * @param {*} [options] Override http request options.
     */
    public getTags1 (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TagDto>;  }> {
        const localVarPath = this.basePath + '/{campaign}/tags'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getTags1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TagDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TagDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TagsApiApiKeys {
    JWT,
}

export class TagsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TagsApiApiKeys, value: string) {
        (this.authentications as any)[TagsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a tag
     * @param tag Tag Name
     * @param description Description
     * @param bannerImage1800x562 Banner Image (1800x562)
     * @param bannerImage800x533 Banner Image (800x533)
     * @param {*} [options] Override http request options.
     */
    public addTag1 (tag: string, description: string, bannerImage1800x562?: Buffer, bannerImage800x533?: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TagDto;  }> {
        const localVarPath = this.basePath + '/tags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling addTag1.');
        }

        // verify required parameter 'description' is not null or undefined
        if (description === null || description === undefined) {
            throw new Error('Required parameter description was null or undefined when calling addTag1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (tag !== undefined) {
            localVarFormParams['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (bannerImage1800x562 !== undefined) {
            localVarFormParams['bannerImage1800x562'] = bannerImage1800x562;
        }
        localVarUseFormData = true;

        if (bannerImage800x533 !== undefined) {
            localVarFormParams['bannerImage800x533'] = bannerImage800x533;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TagDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TagDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a tag with the given tag name
     * @param tag Tag Name
     * @param {*} [options] Override http request options.
     */
    public deleteTag1 (tag: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tags/{tag}'
            .replace('{' + 'tag' + '}', encodeURIComponent(String(tag)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling deleteTag1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the tag with the given tag name
     * @param tag Tag Name
     * @param {*} [options] Override http request options.
     */
    public getTag1 (tag: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TagDto;  }> {
        const localVarPath = this.basePath + '/tags/{tag}'
            .replace('{' + 'tag' + '}', encodeURIComponent(String(tag)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling getTag1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TagDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TagDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all tags
     * @param start Start Row
     * @param rows Number of Rows
     * @param {*} [options] Override http request options.
     */
    public getTags2 (start: number, rows: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemsPageResponseTagDto;  }> {
        const localVarPath = this.basePath + '/tags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getTags2.');
        }

        // verify required parameter 'rows' is not null or undefined
        if (rows === null || rows === undefined) {
            throw new Error('Required parameter rows was null or undefined when calling getTags2.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (rows !== undefined) {
            localVarQueryParameters['rows'] = ObjectSerializer.serialize(rows, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPageResponseTagDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsPageResponseTagDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all categories
     * @param body Datatable Request
     * @param {*} [options] Override http request options.
     */
    public getTags3 (body?: DataTablesInput, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DataTablesOutputTagDto;  }> {
        const localVarPath = this.basePath + '/tags/datatable';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DataTablesInput")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataTablesOutputTagDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataTablesOutputTagDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a tag with the given tag name
     * @param tag Tag Name
     * @param description Description
     * @param bannerImage1800x562 Banner Image (1800x562)
     * @param bannerImage800x533 Banner Image (800x533)
     * @param {*} [options] Override http request options.
     */
    public updateTag (tag: string, description: string, bannerImage1800x562?: Buffer, bannerImage800x533?: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tags/{tag}';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling updateTag.');
        }

        // verify required parameter 'description' is not null or undefined
        if (description === null || description === undefined) {
            throw new Error('Required parameter description was null or undefined when calling updateTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (tag !== undefined) {
            localVarFormParams['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (bannerImage1800x562 !== undefined) {
            localVarFormParams['bannerImage1800x562'] = bannerImage1800x562;
        }
        localVarUseFormData = true;

        if (bannerImage800x533 !== undefined) {
            localVarFormParams['bannerImage800x533'] = bannerImage800x533;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TicketDistributionSpreadsheetApiApiKeys {
    JWT,
}

export class TicketDistributionSpreadsheetApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TicketDistributionSpreadsheetApiApiKeys, value: string) {
        (this.authentications as any)[TicketDistributionSpreadsheetApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new distribution spreadsheet
     * @param campaign Campaign ID
     * @param {*} [options] Override http request options.
     */
    public addDistributionSpreadsheet (campaign: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TicketDistributionSpreadsheetDto;  }> {
        const localVarPath = this.basePath + '/{campaign}/spreadsheets/{spreadsheet}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling addDistributionSpreadsheet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TicketDistributionSpreadsheetDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TicketDistributionSpreadsheetDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a distribution spreadsheet
     * @param campaign Campaign ID
     * @param spreadsheet Spreadsheet ID
     * @param {*} [options] Override http request options.
     */
    public deleteDistributionSpreadsheet (campaign: string, spreadsheet: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{campaign}/spreadsheets/{spreadsheet}/{spreadsheet}'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)))
            .replace('{' + 'spreadsheet' + '}', encodeURIComponent(String(spreadsheet)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling deleteDistributionSpreadsheet.');
        }

        // verify required parameter 'spreadsheet' is not null or undefined
        if (spreadsheet === null || spreadsheet === undefined) {
            throw new Error('Required parameter spreadsheet was null or undefined when calling deleteDistributionSpreadsheet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TimeslotPricingApiApiKeys {
    JWT,
}

export class TimeslotPricingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'JWT': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TimeslotPricingApiApiKeys, value: string) {
        (this.authentications as any)[TimeslotPricingApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieve all pricings for multiple timeslots
     * @param campaign Campaign ID
     * @param timeslots Timeslot IDs (comma-seperated values)
     * @param {*} [options] Override http request options.
     */
    public getPricings1 (campaign: string, timeslots?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: { [key: string]: Array<PricingDto>; };  }> {
        const localVarPath = this.basePath + '/{campaign}/timeslots/pricings'
            .replace('{' + 'campaign' + '}', encodeURIComponent(String(campaign)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling getPricings1.');
        }

        if (timeslots !== undefined) {
            localVarQueryParameters['timeslots'] = ObjectSerializer.serialize(timeslots, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: { [key: string]: Array<PricingDto>; };  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "{ [key: string]: Array<PricingDto>; }");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
